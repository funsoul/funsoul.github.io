<!DOCTYPE html>
<html lang="chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"funsoul.org","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">
<meta name="keywords" content="PHP,C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="使用C++扩展PHP">
<meta property="og:url" content="http://funsoul.org/2020/06/15/使用cplusplus扩展PHP/index.html">
<meta property="og:site_name" content="Funsoul&#39;s Blog">
<meta property="og:description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">
<meta property="og:locale" content="chinese">
<meta property="og:updated_time" content="2020-06-16T07:48:25.143Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用C++扩展PHP">
<meta name="twitter:description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">

<link rel="canonical" href="http://funsoul.org/2020/06/15/使用cplusplus扩展PHP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'chinese'
  };
</script>

  <title>使用C++扩展PHP | Funsoul's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118289850-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-118289850-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Funsoul's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">开发散记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="chinese">
    <link itemprop="mainEntityOfPage" href="http://funsoul.org/2020/06/15/使用cplusplus扩展PHP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/about/avatar.jpg">
      <meta itemprop="name" content="funsoul">
      <meta itemprop="description" content="以终为始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Funsoul's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          使用C++扩展PHP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-15T00:00:00+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-16 15:48:25" itemprop="dateModified" datetime="2020-06-16T15:48:25+08:00">2020-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP" target="_blank" rel="noopener">PHP-CPP</a>是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的<a href="http://www.php-cpp.com/documentation/introduction" target="_blank" rel="noopener">文档</a>。</p>
<a id="more"></a>
<p>注意：仅适用于PHP7。这个库已经更新为适用于 PHP 7.0 及以上版本。如果你想为旧版本的 PHP 创建扩展，请使用 <a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP-LEGACY" target="_blank" rel="noopener">PHP-CPP-LEGACY</a> 库。PHP-CPP 和 PHP-CPP-LEGACY 库有（几乎）相同的 API，所以你可以很容易地将 PHP 5.*的扩展移植到 PHP 7，反之亦然。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>注意：目前，PHP-CPP仅适用于Linux或OSX系统</li>
<li>本文实验环境为OSX</li>
</ol>
<h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v2.1.0 https://github.com/CopernicaMarketingSoftware/PHP-CPP.git</span><br></pre></td></tr></table></figure>
<p>打开<code>Makefile</code>文件（Makefile是一个保存编译器设置和指令的文件），大多数情况下，该文件中的默认配置已经足够好，但是你或许需要针对自己的环境做一些轻微的改动，比如改变安装目录或者选择自己的编译器。</p>
<h3 id="开始构建PHP-CPP库"><a href="#开始构建PHP-CPP库" class="headerlink" title="开始构建PHP-CPP库"></a>开始构建PHP-CPP库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ol>
<li>如果你使用OSX来编译构建，可能会遇到<code>链接</code>和<code>unresolved symbol</code>错误，如果你正面临此问题，那么需要对<code>Makefile</code>文件做一些改动，在这个 Makefile的某个地方有一个选项<code>LINKER_FLAGS</code>。修改为<code>-shared -undefined dynamic_lookup</code>。</li>
<li><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP/issues/368" target="_blank" rel="noopener">ld: unknown option: -soname clang: error: linker command failed with exit code 1</a></li>
</ol>
<h3 id="安装PHP-CPP库到系统中"><a href="#安装PHP-CPP库到系统中" class="headerlink" title="安装PHP-CPP库到系统中"></a>安装PHP-CPP库到系统中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="PHP如何载入扩展"><a href="#PHP如何载入扩展" class="headerlink" title="PHP如何载入扩展"></a>PHP如何载入扩展</h2><p>你可能知道在类unix的系统中，本地的PHP扩展名被编译成<code>.so</code>文件，在Windows环境中，编译成<code>.dll</code>文件，而全局的<code>php.ini</code>文件保存了系统中所有可用的扩展的列表，这意味着如果你正在创建自己的扩展，你也要创建这样的<code>.so</code>或<code>.dll</code>文件，并且你必须更新PHP配置文件，以便你自己的扩展被PHP加载。</p>
<h3 id="get-module启动函数"><a href="#get-module启动函数" class="headerlink" title="get_module启动函数"></a>get_module启动函数</h3><p>在解释如何创建自己的扩展之前，我们先解释一下 PHP 如何加载一个扩展。当 PHP 启动时，它从配置目录中加载 <code>*.ini</code> 配置文件，对于这些配置文件中的每一行 <code>extension=name.so</code>，它都会打开相应的库，并调用其中的<code>get_module()</code>函数。因此，每个扩展库（你的扩展也是）都必须定义并实现这个<code>get_module()</code>函数。这个函数在库加载后就被 PHP 调用（因此在处理 pageviews 之前就被调用了），它应该返回一个指向一个结构的内存地址，这个结构保存了所有扩展库提供的函数、类、变量和常量的信息。</p>
<p><code>get_module()</code>返回的结构是在Zend引擎的头文件中定义的，但它是一个相当复杂的结构，而且没有很好的文档。幸运的是，PHP-CPP库让你的生活变得更简单，并提供了一个扩展类，可以用来代替。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  tell the compiler that the get_module is a pure C function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Function that is called by PHP right after the PHP process</span></span><br><span class="line"><span class="comment">     *  has started, and that returns an address of an internal PHP</span></span><br><span class="line"><span class="comment">     *  strucure with all the details and features of your extension</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @return void*   a pointer to an address that is understood by PHP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// static(!) Php::Extension object that should stay in memory</span></span><br><span class="line">        <span class="comment">// for the entire duration of the process (that's why it's static)</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @todo    add your own functions, classes, namespaces to the extension</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你看到了<code>get_module()</code>函数的一个非常直接的实现。每个使用 PHP-CPP 库的 PHP 扩展都或多或少地实现了这个函数，它是每个扩展的起点。有一些元素需要特别注意，首先，你看到的唯一的头文件是 phpcpp.h 头文件。如果你使用PHP-CPP库来构建你自己的扩展，你不需要包含Zend引擎的那些复杂的、非结构化的、大部分没有文档的头文件——你需要的只是PHP-CPP库的这个单一的phpcpp.h头文件。如果你坚持的话，你当然也可以包含核心 PHP 引擎的头文件——但你不必这样做。PHP-CPP 负责处理 PHP 引擎的内部，并提供给你一个简单易用的 API。</p>
<p>接下来你会注意到，我们将<code>get_module()</code>函数放在了一个 <code>extern &quot;C&quot;</code>的代码块中。正如库的名字所透露的那样，PHP-CPP 是一个 C++ 库。然而，PHP 希望你的库，尤其是 <code>get_module()</code> 函数是用 C 而不是 C++ 实现的。这就是为什么我们把 <code>get_module()</code> 函数包装在一个 <code>extern &quot;C&quot;</code> 块中。这将指示 C++ 编译器 <code>get_module()</code> 是一个常规的 C 函数，并且它不应该对它进行任何 C++ 名称的篡改。</p>
<p>PHP-CPP 库定义了一个 <code>PHPCPP_EXPORT</code> 宏，它应该放在 <code>get_module()</code> 函数的前面。这个宏确保<code>get_module()</code>函数是公开导出的，因此可以被PHP调用。这个宏根据编译器和操作系统的不同有不同的实现。</p>
<p>顺便说一下，这也是 PHP-CPP 提供的唯一一个宏。PHP-CPP打算成为一个普通的C++库，不使用魔术或预处理器的技巧。你所看到的就是你所得到的。如果某些东西看起来像函数，你可以肯定它实际上就是一个函数，而当某些东西看起来像一个变量，你可以肯定它也是一个变量。</p>
<p>我们继续往下看。在<code>get_module()</code>函数里面，<code>Php::Extension</code>对象被实例化，并被返回。至关重要的是，你必须为这个<code>Php::Extension</code>类创建一个静态实例，因为这个对象必须在PHP进程的整个生命周期内存在，而不仅仅是在调用<code>get_module()</code>的期间。构造函数有两个参数：扩展名和版本号。</p>
<p><code>get_module()</code> 函数的最后一步是返回扩展对象。这看起来很奇怪，因为get_module()函数应该返回一个指向void的指针，而不是一个完整的Php::Extension对象。为什么编译器没有报告这个问题呢？那是因为<code>Php::Extension</code>类有一个<code>cast-to-void-pointer-operator</code>。因此，虽然看起来你返回的是完整的扩展对象，但实际上你只是返回了一个指向一个数据结构的内存地址，这个数据结构被 PHP 核心引擎所理解，并且保存了你的扩展的所有细节。</p>
<p>请注意，上面的例子还没有导出任何<code>本地函数</code>或<code>本地类</code>到PHP中——它只是创建了扩展。</p>
<h2 id="编写第一个扩展"><a href="#编写第一个扩展" class="headerlink" title="编写第一个扩展"></a>编写第一个扩展</h2><p>当你创建你自己的 PHP-CPP 扩展时，你也必须编译和部署它。一个普通的PHP脚本只需要复制到web服务器上就可以部署，但是部署一个扩展需要花费更多的精力：你需要一个<code>Makefile</code>，一个扩展专用的<code>php.ini</code>文件，当然还有实现扩展的<code>*.cpp</code>文件。</p>
<p>为了帮助你完成这些步骤，我们创建了一个几乎是空的扩展，包含了所有需要的文件。它包含了一个示例<code>Makefile</code>，一个示例配置文件，以及第一个<code>main.cpp</code>文件，其中的<code>get_module()</code>调用已经被实现。这为你开发扩展提供了一个良好的开端。</p>
<p>该扩展代码在PHP-CPP源码的<code>Example</code>目录下，本文后面的所有扩展源码都在这里可以找到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">├── CallPhpFunctions</span><br><span class="line">│   ├── 30-callphpfunction.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── callphpfunction.cpp</span><br><span class="line">│   └── callphpfunction.php</span><br><span class="line">├── ConstStaticProp</span><br><span class="line">│   ├── cpp</span><br><span class="line">│   ├── readme</span><br><span class="line">│   └── test.php</span><br><span class="line">├── CppClassesInPhp</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── check_map.php</span><br><span class="line">│   ├── cppclassinphp.cpp</span><br><span class="line">│   ├── cppclassinphp.ini</span><br><span class="line">│   ├── cppclassinphp.php</span><br><span class="line">│   └── includeMyCustomClass.h</span><br><span class="line">├── DlUnrestricted</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── dlunrestricted.cpp</span><br><span class="line">│   ├── dlunrestricted.ini</span><br><span class="line">│   └── dlunrestricted.php</span><br><span class="line">├── EmptyExtension</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   └── yourextension.ini</span><br><span class="line">├── Exceptions</span><br><span class="line">│   ├── ExceptionCatch</span><br><span class="line">│   └── ExceptionThrow</span><br><span class="line">├── Extension</span><br><span class="line">│   ├── 30-phpcpp.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── extension.cpp</span><br><span class="line">│   ├── extension.o</span><br><span class="line">│   ├── extension.php</span><br><span class="line">│   └── extension.so</span><br><span class="line">├── FunctionNoParameters</span><br><span class="line">│   ├── 30-functionnoparameters.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionnoparameters.cpp</span><br><span class="line">│   └── functionnoparameters.php</span><br><span class="line">├── FunctionReturnValue</span><br><span class="line">│   ├── 30-functionreturnvalue.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionreturnvalue.cpp</span><br><span class="line">│   └── functionreturnvalue.php</span><br><span class="line">├── FunctionVoid</span><br><span class="line">│   ├── 30-functionvoid.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionvoid.cpp</span><br><span class="line">│   ├── functionvoid.o</span><br><span class="line">│   ├── functionvoid.php</span><br><span class="line">│   └── functionvoid.so</span><br><span class="line">├── FunctionWithParameters</span><br><span class="line">│   ├── 30-functionwithparameters.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionwithparameters.cpp</span><br><span class="line">│   └── functionwithparameters.php</span><br><span class="line">├── Globals</span><br><span class="line">│   ├── 30-globals.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── globals.cpp</span><br><span class="line">│   └── globals.php</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── ReturnObject</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── child.h</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   ├── master.h</span><br><span class="line">│   ├── returnobject.ini</span><br><span class="line">│   └── test.php</span><br><span class="line">└── simple</span><br><span class="line">    ├── 30-phpcpp.ini</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── simple.cpp</span><br><span class="line">    └── simple.php</span><br></pre></td></tr></table></figure>
<h3 id="查看例子：Extension"><a href="#查看例子：Extension" class="headerlink" title="查看例子：Extension"></a>查看例子：Extension</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── 30-phpcpp.ini   <span class="comment"># 扩展声明文件</span></span><br><span class="line">├── Makefile        <span class="comment"># 构建文件</span></span><br><span class="line">├── extension.cpp   <span class="comment"># 扩展源码文件</span></span><br><span class="line">└── extension.php   <span class="comment"># 测试文件</span></span><br></pre></td></tr></table></figure>
<p>修改<code>Makefile</code>文件中下面两行内容。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY_DIR		= <span class="variable">$(<span class="built_in">shell</span> php-config --extension-<span class="built_in">dir</span>)</span></span><br><span class="line">PHP_CONFIG_DIR	= /usr/local/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行用于获取扩展的目录</li>
<li>第二行为你的PHP配置目录，用于存放你的扩展声明<code>extension=name.so</code></li>
</ul>
<p>通过以下步骤安装扩展</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;make</span><br><span class="line">g++ -Wall -c -I. -O2 -std=c++11 -fpic -o extension.o extension.cpp</span><br><span class="line">g++ -Wall -shared -O2  -o extension.so extension.o -lphpcpp</span><br><span class="line">&gt;&gt;sudo make install</span><br><span class="line">cp -f extension.so /usr/<span class="built_in">local</span>/Cellar/php@7.1/7.1.30/pecl/20160303</span><br><span class="line">cp -f 30-phpcpp.ini     /usr/<span class="built_in">local</span>/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>
<p>测试扩展</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;php -m | grep extension</span><br><span class="line">my_simple_extension</span><br><span class="line">&gt;&gt;php extension.php</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [67] =&gt; my_simple_extension</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="输出和错误"><a href="#输出和错误" class="headerlink" title="输出和错误"></a>输出和错误</h2><p>你可以使用常规的C++流来进行IO，使用常规的<code>&lt;&lt;</code>操作符和特殊的函数，如<code>std::endl</code>。但是使用<code>std::cout</code>和<code>std::cerr</code>流并不是一个好主意。</p>
<p>当 PHP 作为 webserver 模块运行时，stdout 被重定向到 webserver 进程最初启动的终端。在生产服务器上，这样的终端是不活动的，所以任何发送到stdout的输出都会丢失。因此，在webserver模块中运行的扩展中使用<code>std::cout</code>是不行的。但是即使 PHP 以 <code>CLI</code> 脚本的形式运行（并且 <code>std::cout</code> 也能工作），也不应该直接向 <code>stdout</code> 写入。写入<code>stdout</code>会绕过所有PHP用户空间脚本可能设置的输出处理程序。</p>
<p>PHP-CPP 库提供了一个 <code>Php::out</code> 流用来替代标准输出。这个<code>Php::out</code>变量是众所周知的<code>std::ostream</code>类的一个实例，并且尊重PHP中所有的输出缓冲设置。它的作用与PHP脚本中的echo()函数基本相同。</p>
<p><code>Php::out</code>是一个普通的 <code>std::ostream</code> 对象。其结果是它使用了一个需要刷新的内部缓冲区。当你在输出中添加<code>std::endl</code>或明确添加<code>std::flush</code>时，刷新会自动发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function that shows how to generate output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等同于php中的echo()</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带换行符，刷新输出缓冲</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接调用flush</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span>;</span><br><span class="line">    Php::out.flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接使用echo</span></span><br><span class="line">    Php::echo(<span class="string">"Example output\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你想触发一个PHP错误（相当于PHP trigger_error()的C++函数），你可以使用<code>Php::error</code>、<code>Php::notice</code>、<code>Php::warning</code>和<code>Php::deprecated</code>流中的一个。这些也是<code>std::ostream</code>类的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function that shows how to generate output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出一个 PHP notice</span></span><br><span class="line">    Php::notice &lt;&lt; <span class="string">"this is a notice"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出一个 PHP warning</span></span><br><span class="line">    Php::warning &lt;&lt; <span class="string">"this is a warning"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知用户，该函数已经不推荐使用</span></span><br><span class="line">    Php::deprecated &lt;&lt; <span class="string">"this method is deprecated"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出一个 PHP fatal error</span></span><br><span class="line">    Php::error &lt;&lt; <span class="string">"fatal error"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当输出 fatal error 后，这一行不会执行</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"regular output"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你可以看到我们使用了 <code>std::flush</code> 而不是 <code>std::endl</code>。原因是<code>std::endl</code>内部做了两件事：它附加了一个换行符，以及它刷新了缓冲区。对于错误、通知和警告，我们不需要换行，但我们仍然需要刷新缓冲区来实际生成输出。</p>
<p><code>Php::error</code>流有一个非常奇特的地方：当你刷新它时，PHP脚本以一个致命的错误结束，而你的C++代码立即退出！！在引擎下面，PHP引擎做了一个<code>longjump</code>，到了Zend引擎深处的一个地方。在这个例子中，<code>Php::out &lt;&lt; &quot;regular output&quot;;</code> 语句从未被执行。</p>
<p>这一切都很不寻常，而且（根据我们的说法）与软件工程的一般规则相冲突。一个输出生成函数的行为不应该像抛出一个异常。看起来像正常代码的代码，也应该表现得像正常代码一样，而不应该做意想不到的事情，比如跳出当前的调用栈。因此，我们建议不要使用<code>Php::error</code>，或者在使用它时要格外小心。</p>
<h2 id="注册原生函数"><a href="#注册原生函数" class="headerlink" title="注册原生函数"></a>注册原生函数</h2><h3 id="无返回值：FunctionVoid"><a href="#无返回值：FunctionVoid" class="headerlink" title="无返回值：FunctionVoid"></a>无返回值：FunctionVoid</h3><p>在<code>get_module</code>中声明扩展信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create extension</span></span><br><span class="line"><span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_function_void"</span>,<span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;my_function_void&gt;(<span class="string">"my_void_function"</span>);</span><br></pre></td></tr></table></figure>
<p>编写一个直接打印字符串的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function_void</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"In my_function_void()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有返回值：FunctionReturnValue"><a href="#有返回值：FunctionReturnValue" class="headerlink" title="有返回值：FunctionReturnValue"></a>有返回值：FunctionReturnValue</h3><p>在<code>get_module</code>中声明扩展信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create extension</span></span><br><span class="line"><span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_function_return_value"</span>,<span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;my_return_value_function&gt;(<span class="string">"my_return_value_function"</span>);</span><br></pre></td></tr></table></figure>
<p>通过<code>Php::Value</code>来标示返回值类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  my_return_value_function()</span></span><br><span class="line"><span class="comment"> *  @return Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">my_return_value_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::Value</code>是存储在Zend引擎中的值的基类。value类的一个实例代表了在PHP环境用户空间中存在的一个变量，例如作为全局变量、函数中的局部变量、对象或数组的成员。可以是标量类型也可以是更复杂的数组或对象类型。</p>
<p>在内核中，Zend引擎使用<code>zval</code>对象来实现。这些<code>zval</code>对象持有引用计数和引用配置。PHP-CPP的<code>Value</code>类负责处理这些工作，所以你需要做的就是使用这个类的对象。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="查看例子：functionwithparameters"><a href="#查看例子：functionwithparameters" class="headerlink" title="查看例子：functionwithparameters"></a>查看例子：functionwithparameters</h3><h4 id="如何获取未定义参数"><a href="#如何获取未定义参数" class="headerlink" title="如何获取未定义参数"></a>如何获取未定义参数</h4><p>添加一个获取未定义参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with undefined parameters, to extension</span></span><br><span class="line">extension.add&lt;my_with_undefined_parameters_function&gt;(<span class="string">"my_with_undefined_parameters_function"</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过<code>Php::Parameters</code>来获取函数参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_with_undefined_parameters_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; params[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子，尽管在定义函数时没有定义参数，但是也可以通过<code>Php::Parameters</code>来获取，非常神奇。</p>
<h4 id="如何写一个加法运算函数"><a href="#如何写一个加法运算函数" class="headerlink" title="如何写一个加法运算函数"></a>如何写一个加法运算函数</h4><p>添加一个有参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined numeric parameters, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_parameters_function&gt;(<span class="string">"my_with_defined_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"x"</span>, Php::Type::Numeric),</span><br><span class="line">    Php::ByVal(<span class="string">"y"</span>, Php::Type::Numeric)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>编写函数定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  my_with_defined_parameters_function()</span></span><br><span class="line"><span class="comment"> *  @param  Php::Parameters     the given parameters</span></span><br><span class="line"><span class="comment"> *  @return Php::Value          Param[0] and Param[1] added</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">my_with_defined_parameters_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; params[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>] + params[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的含义是，接收两个整型数字，并返回求和结果。</p>
<h4 id="如何传递引用"><a href="#如何传递引用" class="headerlink" title="如何传递引用"></a>如何传递引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined parameter by reference, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_parameters_reference_function&gt;(<span class="string">"my_with_defined_parameters_reference_function"</span>, &#123;</span><br><span class="line">    Php::ByRef(<span class="string">"string"</span>, Php::Type::String)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>修改传递进来的参数值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  This functions receives a reference to a variable. When the variable is altered,</span></span><br><span class="line"><span class="comment"> *  so is the value in the php script.</span></span><br><span class="line"><span class="comment"> *  my_with_defined_parameters_reference_function()</span></span><br><span class="line"><span class="comment"> *  @param  Php::Parameters     the given parameters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_with_defined_parameters_reference_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    params[<span class="number">0</span>] = <span class="string">"I changed!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何接收数组"><a href="#如何接收数组" class="headerlink" title="如何接收数组"></a>如何接收数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined array parameter, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_array_parameters_function&gt;(<span class="string">"my_with_defined_array_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"array"</span>, Php::Type::Array)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="如何接收对象"><a href="#如何接收对象" class="headerlink" title="如何接收对象"></a>如何接收对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined object parameter, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_object_parameters_function&gt;(<span class="string">"my_with_defined_object_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"myClassObjVar"</span>, <span class="string">"MyPhpClass"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Php-Type支持情况"><a href="#Php-Type支持情况" class="headerlink" title="Php::Type支持情况"></a>Php::Type支持情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Supported types for variables</span></span><br><span class="line"><span class="comment"> *  The values are the same as the ones used internally in Zend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;</span><br><span class="line">    Undefined       =   <span class="number">0</span>,  <span class="comment">// Variable is not set</span></span><br><span class="line">    Null            =   <span class="number">1</span>,  <span class="comment">// Null will allow any type</span></span><br><span class="line">    False           =   <span class="number">2</span>,  <span class="comment">// Boolean false</span></span><br><span class="line">    True            =   <span class="number">3</span>,  <span class="comment">// Boolean true</span></span><br><span class="line">    Numeric         =   <span class="number">4</span>,  <span class="comment">// Integer type</span></span><br><span class="line">    Float           =   <span class="number">5</span>,  <span class="comment">// Floating point type</span></span><br><span class="line">    String          =   <span class="number">6</span>,  <span class="comment">// A string obviously</span></span><br><span class="line">    Array           =   <span class="number">7</span>,  <span class="comment">// An array of things</span></span><br><span class="line">    Object          =   <span class="number">8</span>,  <span class="comment">// An object</span></span><br><span class="line">    Resource        =   <span class="number">9</span>,  <span class="comment">// A resource</span></span><br><span class="line">    Reference       =  <span class="number">10</span>,  <span class="comment">// Reference to another value (can be any type!)</span></span><br><span class="line">    Constant        =  <span class="number">11</span>,  <span class="comment">// A constant value</span></span><br><span class="line">    ConstantAST     =  <span class="number">12</span>,  <span class="comment">// I think an Abstract Syntax tree, not quite sure</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// "fake types", not quite sure what that means</span></span><br><span class="line">    Bool            = <span class="number">13</span>,   <span class="comment">// You will never get this back as a type</span></span><br><span class="line">    Callable        = <span class="number">14</span>,   <span class="comment">// I don't know why this is a "fake" type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>使用<code>Php::ByVal</code>定义接收参数（值传递）</li>
<li>使用<code>Php::ByRef</code>定义接收引用</li>
<li><code>Php::Parameters</code>是一个数组，用来获取参数</li>
</ol>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>首先让我们弄清楚一件事。 运行编译后的机器码比运行PHP代码快得多。 因此，一旦最终调用了C++函数或C++方法，通常就将参数转换为本地变量，然后开始运行自己的快速算法。从那时起，您就不想调用其他PHP函数。</p>
<p>但是，如果您要调用PHP函数（无论是Zend内置的函数，在扩展中定义的函数，还是来自PHP用户空间的函数），也是可以做到的。</p>
<h3 id="查看例子：callphpfunction"><a href="#查看例子：callphpfunction" class="headerlink" title="查看例子：callphpfunction"></a>查看例子：callphpfunction</h3><p>添加一个含有两个参数的函数，第一个参数是回调函数，第二个参数是数字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;call_php_function&gt;(<span class="string">"call_php_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"addFunc"</span>, Php::Type::Callable),</span><br><span class="line">    Php::ByVal(<span class="string">"x"</span>, Php::Type::Numeric)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>函数实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  call_php_function()</span></span><br><span class="line"><span class="comment"> *  Calls a function in PHP space.</span></span><br><span class="line"><span class="comment"> *  @param      &amp;params</span></span><br><span class="line"><span class="comment"> *  @return     Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">call_php_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the parameter is callable</span></span><br><span class="line">    <span class="keyword">if</span> (!params[<span class="number">0</span>].isCallable()) <span class="keyword">throw</span> Php::Exception(<span class="string">"Not a callable type."</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// perform the callback</span></span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>](params[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda（匿名）函数"><a href="#Lambda（匿名）函数" class="headerlink" title="Lambda（匿名）函数"></a>Lambda（匿名）函数</h2><p>C++和PHP都支持lambda函数或匿名函数（在C++世界里，”lambda “这个词用得最多，PHPer讲的是 “匿名函数”）。使用 PHP-CPP 可以将这些函数从一种语言传递到另一种语言。可以从C++代码中调用一个匿名的PHP函数，也可以从PHP脚本中调用一个C++ lambda函数。</p>
<p>让我们从一个非常简单的PHP例子开始。在PHP中，你可以创建匿名函数，并将它们赋值给一个变量（或者直接将它们传递给一个函数）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 使用变量$f保存匿名函数</span></span><br><span class="line">$f = <span class="function"><span class="keyword">function</span><span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the sum of the parameters</span></span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个变量传递给另一个函数</span></span><br><span class="line">other_function($f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接传递匿名函数</span></span><br><span class="line">other_function(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the product of the parameters</span></span><br><span class="line">    <span class="keyword">return</span> $a * $b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码对于大多数PHP程序员来说应该是很熟悉的，当然’other_function’也可以在PHP用户空间中实现，但是我们要用C++来演示如何用PHP-CPP来实现。’other_function’当然可以在PHP用户空间中实现，但是为了演示如何用PHP-CPP来实现，我们将用C++来构建它。就像你在前面的例子中看到的所有其他函数一样，这样的C++函数函数接收一个<code>Php::Parameters</code>对象作为参数，它是一个由<code>Php::Value</code>对象组成的<code>std::vector</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function gets one parameter that holds a callable anonymous</span></span><br><span class="line"><span class="comment"> *  PHP function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  params      The parameters passed to the function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the function was really called with at least one parameter</span></span><br><span class="line">    <span class="keyword">if</span> (params.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function is called from PHP user space, and it is called</span></span><br><span class="line">    <span class="comment">// with a anonymous function as its first parameter</span></span><br><span class="line">    Php::Value func = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the Php::Value class has implemented the operator (), which allows</span></span><br><span class="line">    <span class="comment">// us to use the object just as if it is a real function</span></span><br><span class="line">    Php::Value result = func(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @todo do something with the result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class="line"><span class="comment"> *  to have a C style function signature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  when PHP starts, and that should return the extension details</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the example function so that it can be called from PHP scripts</span></span><br><span class="line">        extension.add&lt;other_function&gt;(<span class="string">"other_function"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension details</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这么简单。但是反过来说也是可以的。想象一下，我们在PHP用户空间代码中有一个接受回调函数的函数，下面的函数是PHP array_map()函数的简单版本。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// function that iterates over an array, and calls a function on every</span></span><br><span class="line"><span class="comment">// element in that array, it returns a new array with every item</span></span><br><span class="line"><span class="comment">// replaced by the result of the callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_array_map</span><span class="params">($array, $callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initial result variable</span></span><br><span class="line">    $result = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop through the array</span></span><br><span class="line">    <span class="keyword">foreach</span> ($array <span class="keyword">as</span> $index =&gt; $item) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the callback on the item</span></span><br><span class="line">        $result[$index] = $callback($item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done</span></span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>想象一下，我们想从你的C++代码中调用这个PHP函数，使用一个C++ lambda函数作为回调。这是有可能的，而且很简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the anonymous function</span></span><br><span class="line">    Php::<span class="function">Function <span class="title">multiply_by_two</span><span class="params">([](Php::Parameters &amp;params) -&gt; Php::Value &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// make sure the function was really called with at least one parameter</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (params.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// one parameter is passed to the function</span></span></span></span><br><span class="line"><span class="function"><span class="params">        Php::Value param = params[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// multiple the parameter by two</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> param * <span class="number">2</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the function now is callable</span></span><br><span class="line">    Php::Value four = multiply_by_two(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a Php::Function object is a derived Php::Value, and its value can </span></span><br><span class="line">    <span class="comment">// also be stored in a normal Php::Value object, it will then still </span></span><br><span class="line">    <span class="comment">// be a callback function then</span></span><br><span class="line">    Php::Value value = multiply_by_two;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the value object now also holds the function</span></span><br><span class="line">    Php::Value six = value(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an array</span></span><br><span class="line">    Php::Value <span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the user-space function</span></span><br><span class="line">    Php::Value result = Php::call(<span class="string">"my_array_map"</span>, <span class="built_in">array</span>, multiply_by_two);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @todo do something with the result variable (which now holds</span></span><br><span class="line">    <span class="comment">// an array with values 2, 4, 6 and 8).</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class="line"><span class="comment"> *  to have a C style function signature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  when PHP starts, and that should return the extension details</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the example function so that it can be called from PHP scripts</span></span><br><span class="line">        extension.add&lt;run_test&gt;(<span class="string">"run_test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension details</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们将一个C++ lambda函数分配给一个<code>Php::Function</code>对象。<code>Php::Function</code>类是由<code>Php::Value</code>类派生出来的。<code>Php::Value</code>和<code>Php::Function</code>的唯一区别是<code>Php::Function</code>的构造函数接受一个函数。尽管有这个区别，这两个类是完全相同的。事实上，我们更希望能够让C++函数直接赋值给<code>Php::Value</code>对象，而跳过<code>Php::Function</code>构造函数，但这是不可能的，因为存在调用歧义。</p>
<p><code>Php::Function</code>类可以像普通的<code>Php::Value</code>对象一样使用：你可以把它赋值给其他<code>Php::Value</code>对象，也可以在调用用户空间PHP函数时把它作为参数使用。在上面的例子中，我们正是这样做的：我们用我们自己的 “乘以二 “C++函数调用用户空间的my_iterate()函数。</p>
<h3 id="C-函数签名"><a href="#C-函数签名" class="headerlink" title="C++ 函数签名"></a>C++ 函数签名</h3><p>你可以向<code>Php::Function</code>构造函数传递不同类型的C++函数，只要它们与以下两个函数签名兼容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Php::<span class="function">Value <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">Php::<span class="function">Value <span class="title">function</span><span class="params">(Php::Parameters &amp;params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在内核，<code>Php::Function</code>类使用一个C++的<code>std::function</code>对象来存储函数，所以凡是可以存储在这样一个<code>std::function</code>对象中的东西，都可以分配给<code>Php::Function</code>类。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++和PHP都是面向对象的编程语言，你可以在其中创建类和对象。PHP-CPP 库为你提供了将这两种语言结合起来的工具，并使本地 C++ 类可以从 PHP 中访问。</p>
<p>遗憾的是（但如果你考虑一下，也是符合逻辑的），并不是每一个可以想到的C++类都可以直接导出到PHP中。这需要更多的工作（虽然不是那么多）。首先，你必须确保你的类是从<code>Php::Base</code>派生出来的，其次，当你把你的类添加到扩展对象中时，你还必须指定所有你想从PHP中访问的方法。</p>
<ol>
<li>必须公开继承自<code>Php::Base</code></li>
<li>指定访问控制</li>
</ol>
<h3 id="查看例子：cppclassinphp"><a href="#查看例子：cppclassinphp" class="headerlink" title="查看例子：cppclassinphp"></a>查看例子：cppclassinphp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we are going to define a class</span></span><br><span class="line">Php::Class&lt;MyCustomClass&gt; customClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add methods to it</span></span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class="string">"myMethod"</span>, Php::Final, &#123;&#125;);</span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class="string">"myMethod2"</span>);</span><br><span class="line">customClass.property(<span class="string">"property1"</span>, <span class="string">"prop1"</span>);</span><br><span class="line">customClass.property(<span class="string">"property2"</span>, <span class="string">"prop2"</span>, Php::Protected);</span><br><span class="line"></span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class="string">"loopArray"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"arr"</span>, Php::Type::Array)</span><br><span class="line">&#125;);</span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class="string">"loopObject"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"obj"</span>, Php::Type::Object)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在扩展对象中，</p>
<ol>
<li>通过<code>Php::Class</code>定义类;</li>
<li>使用<code>method</code>方法来指定需要php代码访问的方法，和普通函数一样，也可以定义参数;</li>
<li>使用<code>property</code>来指定类成员，并设置访问权限</li>
</ol>
<p>静态方法也支持。静态方法是指一个不能访问<code>this</code>指针的方法。因此，在C++中，这种静态方法和普通函数是一样的，普通函数也不能访问<code>this</code>指针。静态C++方法与普通C++函数的唯一区别是在编译时：编译器允许静态方法访问私有数据。然而，静态方法的签名与普通函数的签名完全相同。</p>
<p><strong>PHP-CPP允许你注册静态方法。但是由于静态方法的签名与普通函数的签名完全相同，所以你注册的方法甚至不一定是同一个类的方法。普通函数和其他类的静态方法的签名完全一样，也可以注册! 从软件架构的角度来看，最好只使用同一类的静态方法，但C++允许你做的更多。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  普通函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  因为普通函数没有this指针,</span></span><br><span class="line"><span class="comment"> *  所以它和静态方法拥有相同的签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  params      Parameters passed to the function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">regularFunction</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// @todo add implementation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  不会暴露给php调用的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PrivateClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~PrivateClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  静态方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  静态方法没有this指针</span></span><br><span class="line"><span class="comment">     *  因此它的签名和普通函数相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters passed to the method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// @todo add implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  暴露给php使用的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublicClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PublicClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~PublicClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  另一个静态方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  这个静态方法的签名和前面提到的普通函数和静态方法完全一样。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters passed to the method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// @todo add implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;PublicClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将PublicClass::staticMethod注册为一个可在PHP中调用的静态方法</span></span><br><span class="line">        myClass.method&lt;&amp;PublicClass::staticMethod&gt;(<span class="string">"static1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通函数与静态方法具有相同的签名。所以，没有什么能禁止你把普通函数也注册为静态方法。</span></span><br><span class="line">        myClass.method&lt;regularFunction&gt;(<span class="string">"static2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甚至来自完全不同类的静态方法也有相同的函数签名，因此可以注册</span></span><br><span class="line">        myClass.method&lt;&amp;PrivateClass::staticMethod&gt;(<span class="string">"static3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(myClass));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事实上，由于静态方法的签名与普通函数相同，你也可以将静态C++方法注册为普通的全局PHP函数。</span></span><br><span class="line">        myExtension.add(<span class="string">"myFunction"</span>, &amp;PrivateClass::staticMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在PHP代码中使用扩展的功能</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// this will call PublicClass::staticMethod()</span></span><br><span class="line">MyClass::static1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will call PrivateClass::staticMethod()</span></span><br><span class="line">MyClass::static2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will call regularFunction()</span></span><br><span class="line">MyClass::static3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will also call PrivateClass::staticMethod()</span></span><br><span class="line">myFunction();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>在PHP中（在C++中也是），你可以将方法标记为<code>public</code>、<code>private</code>或<code>protected</code>。为了使你的本地类也能实现这一点，你应该在向<code>Php::Class</code>对象添加方法时传递一个额外的flags参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the increment method, and specify its parameters</span></span><br><span class="line">counter.method&lt;&amp;Counter::increment&gt;(<span class="string">"increment"</span>, Php::Protected, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the decrement, and specify its parameters</span></span><br><span class="line">counter.method&lt;&amp;Counter::decrement&gt;(<span class="string">"decrement"</span>, Php::Protected, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the value method</span></span><br><span class="line">counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>, Php::Public | Php::Final);</span><br></pre></td></tr></table></figure>
<p>默认情况下，每一个方法 (还有每一个属性，但我们稍后会处理) 都是<code>公开</code>的。如果你想把一个方法标记为受保护的或私有的，你可以传递一个额外的 <code>Php::Protected</code> 或 <code>Php::Private</code> 标志。如果你也想把你的方法标记为抽象的或最终的，那么可以用<code>Php::Abstract</code>或<code>Php::Final</code>来对flag参数进行<code>位或</code>。我们对value()方法做了这样的处理，这样在派生类中就不可能覆盖这个方法了。</p>
<p>请记住，C++ 类中的导出方法必须始终是公共的(即使在 PHP 中标记为私有或保护)。这是有道理的，因为毕竟你的方法会被 PHP-CPP 库调用，如果你把它们变成私有的，它们就会被库所忽略。</p>
<h3 id="Abstract-and-final"><a href="#Abstract-and-final" class="headerlink" title="Abstract and final"></a>Abstract and final</h3><p>在上一节中，我们展示了如何使用<code>Php::Final</code>和<code>Php::Abstract</code>标志来创建一个final或抽象方法。如果你想让你的整个类成为抽象的或最终的，你可以通过把这个标志传递给<code>Php::Class</code>构造函数来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>, Php::Final);</span><br></pre></td></tr></table></figure>
<p>就像我们之前解释的那样，当你想注册一个抽象方法时，你应该在调用Php::Class::method()时传递一个Php::Abstract标志。然而，可能看起来很奇怪，这个方法也需要你传入一个真正的C++方法的地址。抽象方法通常没有实现，那么你需要提供一个方法的指针干什么呢？幸运的是，也有一种不同的方法来注册抽象方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register the decrement, and specify its parameters</span></span><br><span class="line">counter.method(<span class="string">"decrement"</span>, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要注册抽象方法，你可以简单地使用Counter::method()方法的另一种形式，它不接受指向C++方法的指针。</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><h2 id="魔术接口"><a href="#魔术接口" class="headerlink" title="魔术接口"></a>魔术接口</h2><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="全局和类常量"><a href="#全局和类常量" class="headerlink" title="全局和类常量"></a>全局和类常量</h2><h2 id="从php-ini载入配置"><a href="#从php-ini载入配置" class="headerlink" title="从php.ini载入配置"></a>从php.ini载入配置</h2><h2 id="扩展回调"><a href="#扩展回调" class="headerlink" title="扩展回调"></a>扩展回调</h2><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2>
    </div>

    
    
    
        <div class="reward-container">
  <div>不为赚钱，只为交个朋友！干杯～</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/about/wechat.jpg" alt="funsoul WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/about/ali.jpg" alt="funsoul Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/about/qrcode_wechat.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PHP/" rel="tag"># PHP</a>
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/22/可靠的PHP：契约式设计/" rel="prev" title="可靠的PHP：契约式设计">
      <i class="fa fa-chevron-left"></i> 可靠的PHP：契约式设计
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载源码"><span class="nav-number">2.1.</span> <span class="nav-text">下载源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始构建PHP-CPP库"><span class="nav-number">2.2.</span> <span class="nav-text">开始构建PHP-CPP库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见错误"><span class="nav-number">2.3.</span> <span class="nav-text">常见错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装PHP-CPP库到系统中"><span class="nav-number">2.4.</span> <span class="nav-text">安装PHP-CPP库到系统中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP如何载入扩展"><span class="nav-number">3.</span> <span class="nav-text">PHP如何载入扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get-module启动函数"><span class="nav-number">3.1.</span> <span class="nav-text">get_module启动函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写第一个扩展"><span class="nav-number">4.</span> <span class="nav-text">编写第一个扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：Extension"><span class="nav-number">4.1.</span> <span class="nav-text">查看例子：Extension</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出和错误"><span class="nav-number">5.</span> <span class="nav-text">输出和错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册原生函数"><span class="nav-number">6.</span> <span class="nav-text">注册原生函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无返回值：FunctionVoid"><span class="nav-number">6.1.</span> <span class="nav-text">无返回值：FunctionVoid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有返回值：FunctionReturnValue"><span class="nav-number">6.2.</span> <span class="nav-text">有返回值：FunctionReturnValue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数参数"><span class="nav-number">7.</span> <span class="nav-text">函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：functionwithparameters"><span class="nav-number">7.1.</span> <span class="nav-text">查看例子：functionwithparameters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何获取未定义参数"><span class="nav-number">7.1.1.</span> <span class="nav-text">如何获取未定义参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何写一个加法运算函数"><span class="nav-number">7.1.2.</span> <span class="nav-text">如何写一个加法运算函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何传递引用"><span class="nav-number">7.1.3.</span> <span class="nav-text">如何传递引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何接收数组"><span class="nav-number">7.1.4.</span> <span class="nav-text">如何接收数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何接收对象"><span class="nav-number">7.1.5.</span> <span class="nav-text">如何接收对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Php-Type支持情况"><span class="nav-number">7.2.</span> <span class="nav-text">Php::Type支持情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">7.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用函数"><span class="nav-number">8.</span> <span class="nav-text">调用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：callphpfunction"><span class="nav-number">8.1.</span> <span class="nav-text">查看例子：callphpfunction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda（匿名）函数"><span class="nav-number">9.</span> <span class="nav-text">Lambda（匿名）函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-函数签名"><span class="nav-number">9.1.</span> <span class="nav-text">C++ 函数签名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类和对象"><span class="nav-number">10.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：cppclassinphp"><span class="nav-number">10.1.</span> <span class="nav-text">查看例子：cppclassinphp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问修饰符"><span class="nav-number">10.2.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstract-and-final"><span class="nav-number">10.3.</span> <span class="nav-text">Abstract and final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造与析构"><span class="nav-number">11.</span> <span class="nav-text">构造与析构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">12.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#魔术方法"><span class="nav-number">13.</span> <span class="nav-text">魔术方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#魔术接口"><span class="nav-number">14.</span> <span class="nav-text">魔术接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-number">15.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类成员"><span class="nav-number">16.</span> <span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">17.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">18.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局和类常量"><span class="nav-number">19.</span> <span class="nav-text">全局和类常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从php-ini载入配置"><span class="nav-number">20.</span> <span class="nav-text">从php.ini载入配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展回调"><span class="nav-number">21.</span> <span class="nav-text">扩展回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间"><span class="nav-number">22.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态加载"><span class="nav-number">23.</span> <span class="nav-text">动态加载</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="funsoul"
      src="/images/about/avatar.jpg">
  <p class="site-author-name" itemprop="name">funsoul</p>
  <div class="site-description" itemprop="description">以终为始</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://funsoul.gitbook.io" title="Notebook → https://funsoul.gitbook.io" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>Notebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/funsoul" title="GitHub → https://github.com/funsoul" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://cyanming2016@gmail.com" title="E-Mail → https://cyanming2016@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/cpainter" title="Csdn → https://blog.csdn.net/cpainter" rel="noopener" target="_blank"><i class="fa fa-tags fa-fw"></i>Csdn</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">funsoul</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
