<!DOCTYPE html>
<html lang="chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shuixn.org","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">
<meta name="keywords" content="PHP,C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="使用C++扩展PHP">
<meta property="og:url" content="http://shuixn.org/2020/06/15/使用cplusplus扩展PHP/index.html">
<meta property="og:site_name" content="水行云起">
<meta property="og:description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">
<meta property="og:locale" content="chinese">
<meta property="og:updated_time" content="2020-09-02T16:51:57.264Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用C++扩展PHP">
<meta name="twitter:description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">

<link rel="canonical" href="http://shuixn.org/2020/06/15/使用cplusplus扩展PHP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'chinese'
  };
</script>

  <title>使用C++扩展PHP | 水行云起</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118289850-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-118289850-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">水行云起</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="chinese">
    <link itemprop="mainEntityOfPage" href="http://shuixn.org/2020/06/15/使用cplusplus扩展PHP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/about/avatar.jpg">
      <meta itemprop="name" content="水行">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="水行云起">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          使用C++扩展PHP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-15T00:00:00+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 00:51:57" itemprop="dateModified" datetime="2020-09-03T00:51:57+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP" target="_blank" rel="noopener">PHP-CPP</a>是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的<a href="http://www.php-cpp.com/documentation/introduction" target="_blank" rel="noopener">文档</a>。</p>
<a id="more"></a>
<p>注意：仅适用于PHP7。这个库已经更新为适用于 PHP 7.0 及以上版本。如果你想为旧版本的 PHP 创建扩展，请使用 <a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP-LEGACY" target="_blank" rel="noopener">PHP-CPP-LEGACY</a> 库。PHP-CPP 和 PHP-CPP-LEGACY 库有（几乎）相同的 API，所以你可以很容易地将 PHP 5.*的扩展移植到 PHP 7，反之亦然。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>注意：目前，PHP-CPP仅适用于Linux或OSX系统</li>
<li>本文实验环境为OSX</li>
</ol>
<h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v2.1.0 https://github.com/CopernicaMarketingSoftware/PHP-CPP.git</span><br></pre></td></tr></table></figure>
<p>打开<code>Makefile</code>文件（Makefile是一个保存编译器设置和指令的文件），大多数情况下，该文件中的默认配置已经足够好，但是你或许需要针对自己的环境做一些轻微的改动，比如改变安装目录或者选择自己的编译器。</p>
<h3 id="开始构建PHP-CPP库"><a href="#开始构建PHP-CPP库" class="headerlink" title="开始构建PHP-CPP库"></a>开始构建PHP-CPP库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ol>
<li>如果你使用OSX来编译构建，可能会遇到<code>链接</code>和<code>unresolved symbol</code>错误，如果你正面临此问题，那么需要对<code>Makefile</code>文件做一些改动，在这个 Makefile的某个地方有一个选项<code>LINKER_FLAGS</code>。修改为<code>-shared -undefined dynamic_lookup</code>。</li>
<li><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP/issues/368" target="_blank" rel="noopener">ld: unknown option: -soname clang: error: linker command failed with exit code 1</a></li>
</ol>
<h3 id="安装PHP-CPP库到系统中"><a href="#安装PHP-CPP库到系统中" class="headerlink" title="安装PHP-CPP库到系统中"></a>安装PHP-CPP库到系统中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="PHP如何载入扩展"><a href="#PHP如何载入扩展" class="headerlink" title="PHP如何载入扩展"></a>PHP如何载入扩展</h2><p>你可能知道在类unix的系统中，本地的PHP扩展名被编译成<code>.so</code>文件，在Windows环境中，编译成<code>.dll</code>文件，而全局的<code>php.ini</code>文件保存了系统中所有可用的扩展的列表，这意味着如果你正在创建自己的扩展，你也要创建这样的<code>.so</code>或<code>.dll</code>文件，并且你必须更新PHP配置文件，以便你自己的扩展被PHP加载。</p>
<h3 id="get-module启动函数"><a href="#get-module启动函数" class="headerlink" title="get_module启动函数"></a>get_module启动函数</h3><p>在解释如何创建自己的扩展之前，我们先解释一下 PHP 如何加载一个扩展。当 PHP 启动时，它从配置目录中加载 <code>*.ini</code> 配置文件，对于这些配置文件中的每一行 <code>extension=name.so</code>，它都会打开相应的库，并调用其中的<code>get_module()</code>函数。因此，每个扩展库（你的扩展也是）都必须定义并实现这个<code>get_module()</code>函数。这个函数在库加载后就被 PHP 调用（因此在处理 pageviews 之前就被调用了），它应该返回一个指向一个结构的内存地址，这个结构保存了所有扩展库提供的函数、类、变量和常量的信息。</p>
<p><code>get_module()</code>返回的结构是在Zend引擎的头文件中定义的，但它是一个相当复杂的结构，而且没有很好的文档。幸运的是，PHP-CPP库让你的生活变得更简单，并提供了一个扩展类，可以用来代替。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  tell the compiler that the get_module is a pure C function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Function that is called by PHP right after the PHP process</span></span><br><span class="line"><span class="comment">     *  has started, and that returns an address of an internal PHP</span></span><br><span class="line"><span class="comment">     *  strucure with all the details and features of your extension</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @return void*   a pointer to an address that is understood by PHP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// static(!) Php::Extension object that should stay in memory</span></span><br><span class="line">        <span class="comment">// for the entire duration of the process (that's why it's static)</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @todo    add your own functions, classes, namespaces to the extension</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你看到了<code>get_module()</code>函数的一个非常直接的实现。每个使用 PHP-CPP 库的 PHP 扩展都或多或少地实现了这个函数，它是每个扩展的起点。有一些元素需要特别注意，首先，你看到的唯一的头文件是 phpcpp.h 头文件。如果你使用PHP-CPP库来构建你自己的扩展，你不需要包含Zend引擎的那些复杂的、非结构化的、大部分没有文档的头文件——你需要的只是PHP-CPP库的这个单一的phpcpp.h头文件。如果你坚持的话，你当然也可以包含核心 PHP 引擎的头文件——但你不必这样做。PHP-CPP 负责处理 PHP 引擎的内部，并提供给你一个简单易用的 API。</p>
<p>接下来你会注意到，我们将<code>get_module()</code>函数放在了一个 <code>extern &quot;C&quot;</code>的代码块中。正如库的名字所透露的那样，PHP-CPP 是一个 C++ 库。然而，PHP 希望你的库，尤其是 <code>get_module()</code> 函数是用 C 而不是 C++ 实现的。这就是为什么我们把 <code>get_module()</code> 函数包装在一个 <code>extern &quot;C&quot;</code> 块中。这将指示 C++ 编译器 <code>get_module()</code> 是一个常规的 C 函数，并且它不应该对它进行任何 C++ 名称的篡改。</p>
<p>PHP-CPP 库定义了一个 <code>PHPCPP_EXPORT</code> 宏，它应该放在 <code>get_module()</code> 函数的前面。这个宏确保<code>get_module()</code>函数是公开导出的，因此可以被PHP调用。这个宏根据编译器和操作系统的不同有不同的实现。</p>
<p>顺便说一下，这也是 PHP-CPP 提供的唯一一个宏。PHP-CPP打算成为一个普通的C++库，不使用魔术或预处理器的技巧。你所看到的就是你所得到的。如果某些东西看起来像函数，你可以肯定它实际上就是一个函数，而当某些东西看起来像一个变量，你可以肯定它也是一个变量。</p>
<p>我们继续往下看。在<code>get_module()</code>函数里面，<code>Php::Extension</code>对象被实例化，并被返回。至关重要的是，你必须为这个<code>Php::Extension</code>类创建一个静态实例，因为这个对象必须在PHP进程的整个生命周期内存在，而不仅仅是在调用<code>get_module()</code>的期间。构造函数有两个参数：扩展名和版本号。</p>
<p><code>get_module()</code> 函数的最后一步是返回扩展对象。这看起来很奇怪，因为get_module()函数应该返回一个指向void的指针，而不是一个完整的Php::Extension对象。为什么编译器没有报告这个问题呢？那是因为<code>Php::Extension</code>类有一个<code>cast-to-void-pointer-operator</code>。因此，虽然看起来你返回的是完整的扩展对象，但实际上你只是返回了一个指向一个数据结构的内存地址，这个数据结构被 PHP 核心引擎所理解，并且保存了你的扩展的所有细节。</p>
<p>请注意，上面的例子还没有导出任何<code>本地函数</code>或<code>本地类</code>到PHP中——它只是创建了扩展。</p>
<h2 id="编写第一个扩展"><a href="#编写第一个扩展" class="headerlink" title="编写第一个扩展"></a>编写第一个扩展</h2><p>当你创建你自己的 PHP-CPP 扩展时，你也必须编译和部署它。一个普通的PHP脚本只需要复制到web服务器上就可以部署，但是部署一个扩展需要花费更多的精力：你需要一个<code>Makefile</code>，一个扩展专用的<code>php.ini</code>文件，当然还有实现扩展的<code>*.cpp</code>文件。</p>
<p>为了帮助你完成这些步骤，我们创建了一个几乎是空的扩展，包含了所有需要的文件。它包含了一个示例<code>Makefile</code>，一个示例配置文件，以及第一个<code>main.cpp</code>文件，其中的<code>get_module()</code>调用已经被实现。这为你开发扩展提供了一个良好的开端。</p>
<p>该扩展代码在PHP-CPP源码的<code>Example</code>目录下，本文后面的所有扩展源码都在这里可以找到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">├── CallPhpFunctions</span><br><span class="line">│   ├── 30-callphpfunction.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── callphpfunction.cpp</span><br><span class="line">│   └── callphpfunction.php</span><br><span class="line">├── ConstStaticProp</span><br><span class="line">│   ├── cpp</span><br><span class="line">│   ├── readme</span><br><span class="line">│   └── test.php</span><br><span class="line">├── CppClassesInPhp</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── check_map.php</span><br><span class="line">│   ├── cppclassinphp.cpp</span><br><span class="line">│   ├── cppclassinphp.ini</span><br><span class="line">│   ├── cppclassinphp.php</span><br><span class="line">│   └── includeMyCustomClass.h</span><br><span class="line">├── DlUnrestricted</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── dlunrestricted.cpp</span><br><span class="line">│   ├── dlunrestricted.ini</span><br><span class="line">│   └── dlunrestricted.php</span><br><span class="line">├── EmptyExtension</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   └── yourextension.ini</span><br><span class="line">├── Exceptions</span><br><span class="line">│   ├── ExceptionCatch</span><br><span class="line">│   └── ExceptionThrow</span><br><span class="line">├── Extension</span><br><span class="line">│   ├── 30-phpcpp.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── extension.cpp</span><br><span class="line">│   ├── extension.o</span><br><span class="line">│   ├── extension.php</span><br><span class="line">│   └── extension.so</span><br><span class="line">├── FunctionNoParameters</span><br><span class="line">│   ├── 30-functionnoparameters.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionnoparameters.cpp</span><br><span class="line">│   └── functionnoparameters.php</span><br><span class="line">├── FunctionReturnValue</span><br><span class="line">│   ├── 30-functionreturnvalue.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionreturnvalue.cpp</span><br><span class="line">│   └── functionreturnvalue.php</span><br><span class="line">├── FunctionVoid</span><br><span class="line">│   ├── 30-functionvoid.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionvoid.cpp</span><br><span class="line">│   ├── functionvoid.o</span><br><span class="line">│   ├── functionvoid.php</span><br><span class="line">│   └── functionvoid.so</span><br><span class="line">├── FunctionWithParameters</span><br><span class="line">│   ├── 30-functionwithparameters.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionwithparameters.cpp</span><br><span class="line">│   └── functionwithparameters.php</span><br><span class="line">├── Globals</span><br><span class="line">│   ├── 30-globals.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── globals.cpp</span><br><span class="line">│   └── globals.php</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── ReturnObject</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── child.h</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   ├── master.h</span><br><span class="line">│   ├── returnobject.ini</span><br><span class="line">│   └── test.php</span><br><span class="line">└── simple</span><br><span class="line">    ├── 30-phpcpp.ini</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── simple.cpp</span><br><span class="line">    └── simple.php</span><br></pre></td></tr></table></figure>
<h3 id="查看例子：Extension"><a href="#查看例子：Extension" class="headerlink" title="查看例子：Extension"></a>查看例子：Extension</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── 30-phpcpp.ini   <span class="comment"># 扩展声明文件</span></span><br><span class="line">├── Makefile        <span class="comment"># 构建文件</span></span><br><span class="line">├── extension.cpp   <span class="comment"># 扩展源码文件</span></span><br><span class="line">└── extension.php   <span class="comment"># 测试文件</span></span><br></pre></td></tr></table></figure>
<p>修改<code>Makefile</code>文件中下面两行内容。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY_DIR		= <span class="variable">$(<span class="built_in">shell</span> php-config --extension-<span class="built_in">dir</span>)</span></span><br><span class="line">PHP_CONFIG_DIR	= /usr/local/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行用于获取扩展的目录</li>
<li>第二行为你的PHP配置目录，用于存放你的扩展声明<code>extension=name.so</code></li>
</ul>
<p>通过以下步骤安装扩展</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;make</span><br><span class="line">g++ -Wall -c -I. -O2 -std=c++11 -fpic -o extension.o extension.cpp</span><br><span class="line">g++ -Wall -shared -O2  -o extension.so extension.o -lphpcpp</span><br><span class="line">&gt;&gt;sudo make install</span><br><span class="line">cp -f extension.so /usr/<span class="built_in">local</span>/Cellar/php@7.1/7.1.30/pecl/20160303</span><br><span class="line">cp -f 30-phpcpp.ini     /usr/<span class="built_in">local</span>/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>
<p>测试扩展</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;php -m | grep extension</span><br><span class="line">my_simple_extension</span><br><span class="line">&gt;&gt;php extension.php</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [67] =&gt; my_simple_extension</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="输出和错误"><a href="#输出和错误" class="headerlink" title="输出和错误"></a>输出和错误</h2><p>你可以使用常规的C++流来进行IO，使用常规的<code>&lt;&lt;</code>操作符和特殊的函数，如<code>std::endl</code>。但是使用<code>std::cout</code>和<code>std::cerr</code>流并不是一个好主意。</p>
<p>当 PHP 作为 webserver 模块运行时，stdout 被重定向到 webserver 进程最初启动的终端。在生产服务器上，这样的终端是不活动的，所以任何发送到stdout的输出都会丢失。因此，在webserver模块中运行的扩展中使用<code>std::cout</code>是不行的。但是即使 PHP 以 <code>CLI</code> 脚本的形式运行（并且 <code>std::cout</code> 也能工作），也不应该直接向 <code>stdout</code> 写入。写入<code>stdout</code>会绕过所有PHP用户空间脚本可能设置的输出处理程序。</p>
<p>PHP-CPP 库提供了一个 <code>Php::out</code> 流用来替代标准输出。这个<code>Php::out</code>变量是众所周知的<code>std::ostream</code>类的一个实例，并且尊重PHP中所有的输出缓冲设置。它的作用与PHP脚本中的echo()函数基本相同。</p>
<p><code>Php::out</code>是一个普通的 <code>std::ostream</code> 对象。其结果是它使用了一个需要刷新的内部缓冲区。当你在输出中添加<code>std::endl</code>或明确添加<code>std::flush</code>时，刷新会自动发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function that shows how to generate output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等同于php中的echo()</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带换行符，刷新输出缓冲</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接调用flush</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span>;</span><br><span class="line">    Php::out.flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接使用echo</span></span><br><span class="line">    Php::echo(<span class="string">"Example output\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你想触发一个PHP错误（相当于PHP trigger_error()的C++函数），你可以使用<code>Php::error</code>、<code>Php::notice</code>、<code>Php::warning</code>和<code>Php::deprecated</code>流中的一个。这些也是<code>std::ostream</code>类的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function that shows how to generate output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出一个 PHP notice</span></span><br><span class="line">    Php::notice &lt;&lt; <span class="string">"this is a notice"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出一个 PHP warning</span></span><br><span class="line">    Php::warning &lt;&lt; <span class="string">"this is a warning"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知用户，该函数已经不推荐使用</span></span><br><span class="line">    Php::deprecated &lt;&lt; <span class="string">"this method is deprecated"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出一个 PHP fatal error</span></span><br><span class="line">    Php::error &lt;&lt; <span class="string">"fatal error"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当输出 fatal error 后，这一行不会执行</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"regular output"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你可以看到我们使用了 <code>std::flush</code> 而不是 <code>std::endl</code>。原因是<code>std::endl</code>内部做了两件事：它附加了一个换行符，以及它刷新了缓冲区。对于错误、通知和警告，我们不需要换行，但我们仍然需要刷新缓冲区来实际生成输出。</p>
<p><code>Php::error</code>流有一个非常奇特的地方：当你刷新它时，PHP脚本以一个致命的错误结束，而你的C++代码立即退出！！在引擎下面，PHP引擎做了一个<code>longjump</code>，到了Zend引擎深处的一个地方。在这个例子中，<code>Php::out &lt;&lt; &quot;regular output&quot;;</code> 语句从未被执行。</p>
<p>这一切都很不寻常，而且（根据我们的说法）与软件工程的一般规则相冲突。一个输出生成函数的行为不应该像抛出一个异常。看起来像正常代码的代码，也应该表现得像正常代码一样，而不应该做意想不到的事情，比如跳出当前的调用栈。因此，我们建议不要使用<code>Php::error</code>，或者在使用它时要格外小心。</p>
<h2 id="注册原生函数"><a href="#注册原生函数" class="headerlink" title="注册原生函数"></a>注册原生函数</h2><h3 id="无返回值：FunctionVoid"><a href="#无返回值：FunctionVoid" class="headerlink" title="无返回值：FunctionVoid"></a>无返回值：FunctionVoid</h3><p>在<code>get_module</code>中声明扩展信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create extension</span></span><br><span class="line"><span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_function_void"</span>,<span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;my_function_void&gt;(<span class="string">"my_void_function"</span>);</span><br></pre></td></tr></table></figure>
<p>编写一个直接打印字符串的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function_void</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"In my_function_void()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有返回值：FunctionReturnValue"><a href="#有返回值：FunctionReturnValue" class="headerlink" title="有返回值：FunctionReturnValue"></a>有返回值：FunctionReturnValue</h3><p>在<code>get_module</code>中声明扩展信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create extension</span></span><br><span class="line"><span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_function_return_value"</span>,<span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;my_return_value_function&gt;(<span class="string">"my_return_value_function"</span>);</span><br></pre></td></tr></table></figure>
<p>通过<code>Php::Value</code>来标示返回值类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  my_return_value_function()</span></span><br><span class="line"><span class="comment"> *  @return Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">my_return_value_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::Value</code>是存储在Zend引擎中的值的基类。value类的一个实例代表了在PHP环境用户空间中存在的一个变量，例如作为全局变量、函数中的局部变量、对象或数组的成员。可以是标量类型也可以是更复杂的数组或对象类型。</p>
<p>在内核中，Zend引擎使用<code>zval</code>对象来实现。这些<code>zval</code>对象持有引用计数和引用配置。PHP-CPP的<code>Value</code>类负责处理这些工作，所以你需要做的就是使用这个类的对象。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="查看例子：functionwithparameters"><a href="#查看例子：functionwithparameters" class="headerlink" title="查看例子：functionwithparameters"></a>查看例子：functionwithparameters</h3><h4 id="如何获取未定义参数"><a href="#如何获取未定义参数" class="headerlink" title="如何获取未定义参数"></a>如何获取未定义参数</h4><p>添加一个获取未定义参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with undefined parameters, to extension</span></span><br><span class="line">extension.add&lt;my_with_undefined_parameters_function&gt;(<span class="string">"my_with_undefined_parameters_function"</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过<code>Php::Parameters</code>来获取函数参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_with_undefined_parameters_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; params[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子，尽管在定义函数时没有定义参数，但是也可以通过<code>Php::Parameters</code>来获取，非常神奇。</p>
<h4 id="如何写一个加法运算函数"><a href="#如何写一个加法运算函数" class="headerlink" title="如何写一个加法运算函数"></a>如何写一个加法运算函数</h4><p>添加一个有参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined numeric parameters, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_parameters_function&gt;(<span class="string">"my_with_defined_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"x"</span>, Php::Type::Numeric),</span><br><span class="line">    Php::ByVal(<span class="string">"y"</span>, Php::Type::Numeric)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>编写函数定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  my_with_defined_parameters_function()</span></span><br><span class="line"><span class="comment"> *  @param  Php::Parameters     the given parameters</span></span><br><span class="line"><span class="comment"> *  @return Php::Value          Param[0] and Param[1] added</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">my_with_defined_parameters_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; params[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>] + params[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的含义是，接收两个整型数字，并返回求和结果。</p>
<h4 id="如何传递引用"><a href="#如何传递引用" class="headerlink" title="如何传递引用"></a>如何传递引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined parameter by reference, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_parameters_reference_function&gt;(<span class="string">"my_with_defined_parameters_reference_function"</span>, &#123;</span><br><span class="line">    Php::ByRef(<span class="string">"string"</span>, Php::Type::String)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>修改传递进来的参数值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  This functions receives a reference to a variable. When the variable is altered,</span></span><br><span class="line"><span class="comment"> *  so is the value in the php script.</span></span><br><span class="line"><span class="comment"> *  my_with_defined_parameters_reference_function()</span></span><br><span class="line"><span class="comment"> *  @param  Php::Parameters     the given parameters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_with_defined_parameters_reference_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    params[<span class="number">0</span>] = <span class="string">"I changed!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何接收数组"><a href="#如何接收数组" class="headerlink" title="如何接收数组"></a>如何接收数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined array parameter, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_array_parameters_function&gt;(<span class="string">"my_with_defined_array_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"array"</span>, Php::Type::Array)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="如何接收对象"><a href="#如何接收对象" class="headerlink" title="如何接收对象"></a>如何接收对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined object parameter, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_object_parameters_function&gt;(<span class="string">"my_with_defined_object_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"myClassObjVar"</span>, <span class="string">"MyPhpClass"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Php-Type支持情况"><a href="#Php-Type支持情况" class="headerlink" title="Php::Type支持情况"></a>Php::Type支持情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Supported types for variables</span></span><br><span class="line"><span class="comment"> *  The values are the same as the ones used internally in Zend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;</span><br><span class="line">    Undefined       =   <span class="number">0</span>,  <span class="comment">// Variable is not set</span></span><br><span class="line">    Null            =   <span class="number">1</span>,  <span class="comment">// Null will allow any type</span></span><br><span class="line">    False           =   <span class="number">2</span>,  <span class="comment">// Boolean false</span></span><br><span class="line">    True            =   <span class="number">3</span>,  <span class="comment">// Boolean true</span></span><br><span class="line">    Numeric         =   <span class="number">4</span>,  <span class="comment">// Integer type</span></span><br><span class="line">    Float           =   <span class="number">5</span>,  <span class="comment">// Floating point type</span></span><br><span class="line">    String          =   <span class="number">6</span>,  <span class="comment">// A string obviously</span></span><br><span class="line">    Array           =   <span class="number">7</span>,  <span class="comment">// An array of things</span></span><br><span class="line">    Object          =   <span class="number">8</span>,  <span class="comment">// An object</span></span><br><span class="line">    Resource        =   <span class="number">9</span>,  <span class="comment">// A resource</span></span><br><span class="line">    Reference       =  <span class="number">10</span>,  <span class="comment">// Reference to another value (can be any type!)</span></span><br><span class="line">    Constant        =  <span class="number">11</span>,  <span class="comment">// A constant value</span></span><br><span class="line">    ConstantAST     =  <span class="number">12</span>,  <span class="comment">// I think an Abstract Syntax tree, not quite sure</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// "fake types", not quite sure what that means</span></span><br><span class="line">    Bool            = <span class="number">13</span>,   <span class="comment">// You will never get this back as a type</span></span><br><span class="line">    Callable        = <span class="number">14</span>,   <span class="comment">// I don't know why this is a "fake" type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>使用<code>Php::ByVal</code>定义接收参数（值传递）</li>
<li>使用<code>Php::ByRef</code>定义接收引用</li>
<li><code>Php::Parameters</code>是一个数组，用来获取参数</li>
</ol>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>首先让我们弄清楚一件事。 运行编译后的机器码比运行PHP代码快得多。 因此，一旦最终调用了C++函数或C++方法，通常就将参数转换为本地变量，然后开始运行自己的快速算法。从那时起，您就不想调用其他PHP函数。</p>
<p>但是，如果您要调用PHP函数（无论是Zend内置的函数，在扩展中定义的函数，还是来自PHP用户空间的函数），也是可以做到的。</p>
<h3 id="查看例子：callphpfunction"><a href="#查看例子：callphpfunction" class="headerlink" title="查看例子：callphpfunction"></a>查看例子：callphpfunction</h3><p>添加一个含有两个参数的函数，第一个参数是回调函数，第二个参数是数字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;call_php_function&gt;(<span class="string">"call_php_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"addFunc"</span>, Php::Type::Callable),</span><br><span class="line">    Php::ByVal(<span class="string">"x"</span>, Php::Type::Numeric)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>函数实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  call_php_function()</span></span><br><span class="line"><span class="comment"> *  Calls a function in PHP space.</span></span><br><span class="line"><span class="comment"> *  @param      &amp;params</span></span><br><span class="line"><span class="comment"> *  @return     Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">call_php_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the parameter is callable</span></span><br><span class="line">    <span class="keyword">if</span> (!params[<span class="number">0</span>].isCallable()) <span class="keyword">throw</span> Php::Exception(<span class="string">"Not a callable type."</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// perform the callback</span></span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>](params[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda（匿名）函数"><a href="#Lambda（匿名）函数" class="headerlink" title="Lambda（匿名）函数"></a>Lambda（匿名）函数</h2><p>C++和PHP都支持lambda函数或匿名函数（在C++世界里，”lambda “这个词用得最多，PHPer讲的是 “匿名函数”）。使用 PHP-CPP 可以将这些函数从一种语言传递到另一种语言。可以从C++代码中调用一个匿名的PHP函数，也可以从PHP脚本中调用一个C++ lambda函数。</p>
<p>让我们从一个非常简单的PHP例子开始。在PHP中，你可以创建匿名函数，并将它们赋值给一个变量（或者直接将它们传递给一个函数）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 使用变量$f保存匿名函数</span></span><br><span class="line">$f = <span class="function"><span class="keyword">function</span><span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the sum of the parameters</span></span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个变量传递给另一个函数</span></span><br><span class="line">other_function($f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接传递匿名函数</span></span><br><span class="line">other_function(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the product of the parameters</span></span><br><span class="line">    <span class="keyword">return</span> $a * $b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码对于大多数PHP程序员来说应该是很熟悉的，当然’other_function’也可以在PHP用户空间中实现，但是我们要用C++来演示如何用PHP-CPP来实现。’other_function’当然可以在PHP用户空间中实现，但是为了演示如何用PHP-CPP来实现，我们将用C++来构建它。就像你在前面的例子中看到的所有其他函数一样，这样的C++函数函数接收一个<code>Php::Parameters</code>对象作为参数，它是一个由<code>Php::Value</code>对象组成的<code>std::vector</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function gets one parameter that holds a callable anonymous</span></span><br><span class="line"><span class="comment"> *  PHP function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  params      The parameters passed to the function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the function was really called with at least one parameter</span></span><br><span class="line">    <span class="keyword">if</span> (params.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function is called from PHP user space, and it is called</span></span><br><span class="line">    <span class="comment">// with a anonymous function as its first parameter</span></span><br><span class="line">    Php::Value func = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the Php::Value class has implemented the operator (), which allows</span></span><br><span class="line">    <span class="comment">// us to use the object just as if it is a real function</span></span><br><span class="line">    Php::Value result = func(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @todo do something with the result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class="line"><span class="comment"> *  to have a C style function signature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  when PHP starts, and that should return the extension details</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the example function so that it can be called from PHP scripts</span></span><br><span class="line">        extension.add&lt;other_function&gt;(<span class="string">"other_function"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension details</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这么简单。但是反过来说也是可以的。想象一下，我们在PHP用户空间代码中有一个接受回调函数的函数，下面的函数是PHP array_map()函数的简单版本。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// function that iterates over an array, and calls a function on every</span></span><br><span class="line"><span class="comment">// element in that array, it returns a new array with every item</span></span><br><span class="line"><span class="comment">// replaced by the result of the callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_array_map</span><span class="params">($array, $callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initial result variable</span></span><br><span class="line">    $result = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop through the array</span></span><br><span class="line">    <span class="keyword">foreach</span> ($array <span class="keyword">as</span> $index =&gt; $item) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the callback on the item</span></span><br><span class="line">        $result[$index] = $callback($item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done</span></span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>想象一下，我们想从你的C++代码中调用这个PHP函数，使用一个C++ lambda函数作为回调。这是有可能的，而且很简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the anonymous function</span></span><br><span class="line">    Php::<span class="function">Function <span class="title">multiply_by_two</span><span class="params">([](Php::Parameters &amp;params) -&gt; Php::Value &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// make sure the function was really called with at least one parameter</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (params.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// one parameter is passed to the function</span></span></span></span><br><span class="line"><span class="function"><span class="params">        Php::Value param = params[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// multiple the parameter by two</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> param * <span class="number">2</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the function now is callable</span></span><br><span class="line">    Php::Value four = multiply_by_two(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a Php::Function object is a derived Php::Value, and its value can </span></span><br><span class="line">    <span class="comment">// also be stored in a normal Php::Value object, it will then still </span></span><br><span class="line">    <span class="comment">// be a callback function then</span></span><br><span class="line">    Php::Value value = multiply_by_two;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the value object now also holds the function</span></span><br><span class="line">    Php::Value six = value(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an array</span></span><br><span class="line">    Php::Value <span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the user-space function</span></span><br><span class="line">    Php::Value result = Php::call(<span class="string">"my_array_map"</span>, <span class="built_in">array</span>, multiply_by_two);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @todo do something with the result variable (which now holds</span></span><br><span class="line">    <span class="comment">// an array with values 2, 4, 6 and 8).</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class="line"><span class="comment"> *  to have a C style function signature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  when PHP starts, and that should return the extension details</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the example function so that it can be called from PHP scripts</span></span><br><span class="line">        extension.add&lt;run_test&gt;(<span class="string">"run_test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension details</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们将一个C++ lambda函数分配给一个<code>Php::Function</code>对象。<code>Php::Function</code>类是由<code>Php::Value</code>类派生出来的。<code>Php::Value</code>和<code>Php::Function</code>的唯一区别是<code>Php::Function</code>的构造函数接受一个函数。尽管有这个区别，这两个类是完全相同的。事实上，我们更希望能够让C++函数直接赋值给<code>Php::Value</code>对象，而跳过<code>Php::Function</code>构造函数，但这是不可能的，因为存在调用歧义。</p>
<p><code>Php::Function</code>类可以像普通的<code>Php::Value</code>对象一样使用：你可以把它赋值给其他<code>Php::Value</code>对象，也可以在调用用户空间PHP函数时把它作为参数使用。在上面的例子中，我们正是这样做的：我们用我们自己的 “乘以二 “C++函数调用用户空间的my_iterate()函数。</p>
<h3 id="C-函数签名"><a href="#C-函数签名" class="headerlink" title="C++ 函数签名"></a>C++ 函数签名</h3><p>你可以向<code>Php::Function</code>构造函数传递不同类型的C++函数，只要它们与以下两个函数签名兼容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Php::<span class="function">Value <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">Php::<span class="function">Value <span class="title">function</span><span class="params">(Php::Parameters &amp;params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在内核，<code>Php::Function</code>类使用一个C++的<code>std::function</code>对象来存储函数，所以凡是可以存储在这样一个<code>std::function</code>对象中的东西，都可以分配给<code>Php::Function</code>类。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++和PHP都是面向对象的编程语言，你可以在其中创建类和对象。PHP-CPP 库为你提供了将这两种语言结合起来的工具，并使本地 C++ 类可以从 PHP 中访问。</p>
<p>遗憾的是（但如果你考虑一下，也是符合逻辑的），并不是每一个可以想到的C++类都可以直接导出到PHP中。这需要更多的工作（虽然不是那么多）。首先，你必须确保你的类是从<code>Php::Base</code>派生出来的，其次，当你把你的类添加到扩展对象中时，你还必须指定所有你想从PHP中访问的方法。</p>
<ol>
<li>必须公开继承自<code>Php::Base</code></li>
<li>指定访问控制</li>
</ol>
<h3 id="查看例子：cppclassinphp"><a href="#查看例子：cppclassinphp" class="headerlink" title="查看例子：cppclassinphp"></a>查看例子：cppclassinphp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we are going to define a class</span></span><br><span class="line">Php::Class&lt;MyCustomClass&gt; customClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add methods to it</span></span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class="string">"myMethod"</span>, Php::Final, &#123;&#125;);</span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class="string">"myMethod2"</span>);</span><br><span class="line">customClass.property(<span class="string">"property1"</span>, <span class="string">"prop1"</span>);</span><br><span class="line">customClass.property(<span class="string">"property2"</span>, <span class="string">"prop2"</span>, Php::Protected);</span><br><span class="line"></span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class="string">"loopArray"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"arr"</span>, Php::Type::Array)</span><br><span class="line">&#125;);</span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class="string">"loopObject"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"obj"</span>, Php::Type::Object)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在扩展对象中，</p>
<ol>
<li>通过<code>Php::Class</code>定义类;</li>
<li>使用<code>method</code>方法来指定需要php代码访问的方法，和普通函数一样，也可以定义参数;</li>
<li>使用<code>property</code>来指定类成员，并设置访问权限</li>
</ol>
<p>静态方法也支持。静态方法是指一个不能访问<code>this</code>指针的方法。因此，在C++中，这种静态方法和普通函数是一样的，普通函数也不能访问<code>this</code>指针。静态C++方法与普通C++函数的唯一区别是在编译时：编译器允许静态方法访问私有数据。然而，静态方法的签名与普通函数的签名完全相同。</p>
<p><strong>PHP-CPP允许你注册静态方法。但是由于静态方法的签名与普通函数的签名完全相同，所以你注册的方法甚至不一定是同一个类的方法。普通函数和其他类的静态方法的签名完全一样，也可以注册! 从软件架构的角度来看，最好只使用同一类的静态方法，但C++允许你做的更多。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  普通函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  因为普通函数没有this指针,</span></span><br><span class="line"><span class="comment"> *  所以它和静态方法拥有相同的签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  params      Parameters passed to the function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">regularFunction</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// @todo add implementation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  不会暴露给php调用的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PrivateClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~PrivateClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  静态方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  静态方法没有this指针</span></span><br><span class="line"><span class="comment">     *  因此它的签名和普通函数相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters passed to the method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// @todo add implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  暴露给php使用的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublicClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PublicClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~PublicClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  另一个静态方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  这个静态方法的签名和前面提到的普通函数和静态方法完全一样。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters passed to the method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// @todo add implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;PublicClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将PublicClass::staticMethod注册为一个可在PHP中调用的静态方法</span></span><br><span class="line">        myClass.method&lt;&amp;PublicClass::staticMethod&gt;(<span class="string">"static1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通函数与静态方法具有相同的签名。所以，没有什么能禁止你把普通函数也注册为静态方法。</span></span><br><span class="line">        myClass.method&lt;regularFunction&gt;(<span class="string">"static2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甚至来自完全不同类的静态方法也有相同的函数签名，因此可以注册</span></span><br><span class="line">        myClass.method&lt;&amp;PrivateClass::staticMethod&gt;(<span class="string">"static3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(myClass));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事实上，由于静态方法的签名与普通函数相同，你也可以将静态C++方法注册为普通的全局PHP函数。</span></span><br><span class="line">        myExtension.add(<span class="string">"myFunction"</span>, &amp;PrivateClass::staticMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在PHP代码中使用扩展的功能</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// this will call PublicClass::staticMethod()</span></span><br><span class="line">MyClass::static1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will call PrivateClass::staticMethod()</span></span><br><span class="line">MyClass::static2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will call regularFunction()</span></span><br><span class="line">MyClass::static3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will also call PrivateClass::staticMethod()</span></span><br><span class="line">myFunction();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>在PHP中（在C++中也是），你可以将方法标记为<code>public</code>、<code>private</code>或<code>protected</code>。为了使你的本地类也能实现这一点，你应该在向<code>Php::Class</code>对象添加方法时传递一个额外的flags参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the increment method, and specify its parameters</span></span><br><span class="line">counter.method&lt;&amp;Counter::increment&gt;(<span class="string">"increment"</span>, Php::Protected, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the decrement, and specify its parameters</span></span><br><span class="line">counter.method&lt;&amp;Counter::decrement&gt;(<span class="string">"decrement"</span>, Php::Protected, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the value method</span></span><br><span class="line">counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>, Php::Public | Php::Final);</span><br></pre></td></tr></table></figure>
<p>默认情况下，每一个方法 (还有每一个属性，但我们稍后会处理) 都是<code>公开</code>的。如果你想把一个方法标记为受保护的或私有的，你可以传递一个额外的 <code>Php::Protected</code> 或 <code>Php::Private</code> 标志。如果你也想把你的方法标记为抽象的或最终的，那么可以用<code>Php::Abstract</code>或<code>Php::Final</code>来对flag参数进行<code>位或</code>。PHP-CPP对value()方法做了这样的处理，这样在派生类中就不可能覆盖这个方法了。</p>
<p>请记住，C++ 类中的导出方法必须始终是公共的(即使在 PHP 中标记为私有或保护)。这是有道理的，因为毕竟你的方法会被 PHP-CPP 库调用，如果你把它们变成私有的，它们就会被库所忽略。</p>
<h3 id="Abstract-and-final"><a href="#Abstract-and-final" class="headerlink" title="Abstract and final"></a>Abstract and final</h3><p>在上一节中，我们展示了如何使用<code>Php::Final</code>和<code>Php::Abstract</code>标志来创建一个final或抽象方法。如果你想让你的整个类成为抽象的或最终的，你可以通过把这个标志传递给<code>Php::Class</code>构造函数来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>, Php::Final);</span><br></pre></td></tr></table></figure>
<p>就像我们之前解释的那样，当你想注册一个抽象方法时，你应该在调用Php::Class::method()时传递一个Php::Abstract标志。然而，可能看起来很奇怪，这个方法也需要你传入一个真正的C++方法的地址。抽象方法通常没有实现，那么你需要提供一个方法的指针干什么呢？幸运的是，也有一种不同的方法来注册抽象方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register the decrement, and specify its parameters</span></span><br><span class="line">counter.method(<span class="string">"decrement"</span>, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要注册抽象方法，你可以简单地使用Counter::method()方法的另一种形式，它不接受指向C++方法的指针。</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>在 C++ 中的构造函数和析构函数与 PHP 中的 <strong>construct() 和 </strong>destruct() 方法之间有一个很小但非常重要的区别。</p>
<p>C++ 中的构造函数是在一个正在初始化的对象上调用的，但这个对象还没有处于初始化状态。你可以通过调用构造函数中的一个虚拟方法来体验这种情况。即使这个虚拟方法在派生类中被重写，这也将始终执行类本身的方法，而不是重写的实现。原因是在调用C++构造函数的过程中，对象还没有完全初始化，对象还不知道自己在类层次结构中的位置。因此对虚拟方法的调用不能传递给派生对象。</p>
<p>然而在 PHP 中，__construct() 方法有不同的行为。当它被调用时，对象已经被初始化了，因此对派生类中实现的抽象方法的调用是完全合法的。下面的 PHP 脚本是完全有效的，但是在 C++ 中不可能做类似的事情。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base class in PHP, in which the an abstract method is called</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BASE</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// call abstract method</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abstract method to be implemented by derived classes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the derived class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DERIVED</span> <span class="keyword">extends</span> <span class="title">BASE</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// implement the abstract method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">"doSomething()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create an instance of the derived class</span></span><br><span class="line">$d = <span class="keyword">new</span> DERIVED();</span><br></pre></td></tr></table></figure>
<p>这个脚本输出的是’doSomething()’。原因是<code>__construct()</code>根本就不是一个构造函数，而是一个很普通的方法，只是恰好是第一个被调用的方法，而且是在对象被构造后自动调用的。</p>
<p>这个区别对于作为一个C++程序员的你来说是很重要的，因为你千万不要把你的C++构造函数和PHP的<code>__construct()</code>方法混淆。在C++构造函数中，对象正在被构造，而且还不是所有的数据都可用。虚拟方法不能被调用，对象也还不存在于 PHP 用户空间中。</p>
<p>在构造函数完成后，PHP引擎接管控制并创建PHP对象，然后PHP-CPP库将该PHP对象链接到你的C++对象。只有在PHP对象和C++对象都完全构造完成之后，才会调用<strong>construct()方法（就像普通方法一样）。因此，在你的类中同时拥有 C++ 构造函数和 </strong>construct() 方法是很常见的。<strong>C++ 构造函数用来初始化成员变量，而 __construct() 方法用来激活对象。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple counter class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Internal value</span></span><br><span class="line"><span class="comment">     *  @var int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  php "constructor"</span></span><br><span class="line"><span class="comment">     *  @param  params</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> __construct(Php::Parameters &amp;params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// copy first parameter (if available)</span></span><br><span class="line">        <span class="keyword">if</span> (!params.empty()) _value = params[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  functions to increment and decrement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++_value; &#125;</span><br><span class="line">    Php::<span class="function">Value <span class="title">decrement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> --_value; &#125;</span><br><span class="line">    Php::<span class="function">Value <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function for the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::__construct&gt;(<span class="string">"__construct"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::increment&gt;(<span class="string">"increment"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::decrement&gt;(<span class="string">"decrement"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码显示 <code>__construct()</code> 被注册为一个普通的方法。我们之前使用的例子（有Counter类的例子）现在被扩展了，这样就可以通过向 “构造函数”传递一个值来给它一个计数器的初始值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$counter = <span class="keyword">new</span> Counter(<span class="number">10</span>);</span><br><span class="line">$counter-&gt;increment();</span><br><span class="line"><span class="keyword">echo</span>($counter-&gt;value().<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>__construct()</code>方法被看作是一个普通的方法，所以你也可以指定它的参数，以及该方法是公共的、私有的还是保护的。<code>__construct()</code>也可以从PHP用户空间直接调用，所以派生方法可以显式调用<code>parent::__construct()</code>。</p>
<h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>就像其他方法一样，<strong>construct()方法也可以被标记为私有或保护。如果你这样做，你将使你的类无法从PHP脚本中创建实例。重要的是要意识到，在这种情况下，C++ 构造函数和 C++ 解构函数仍然会被调用，因为会失败的是<code></code></strong>construct()<code></code>调用，而不是实际的对象构造。</p>
<p>是的，如果你把<code>__construct()</code>方法设为私有，并且在 PHP 脚本中执行了<code>new Counter()</code>调用，PHP-CPP 库将首先实例化你的类的一个新实例，然后报告一个错误，因为<code>__construct()</code>方法是私有的，然后立即析构对象（并调用 C++ 析构函数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a private __construct method to the class, so that objects can </span></span><br><span class="line"><span class="comment">// not be constructed from PHP scripts. Be aware that the C++ constructer </span></span><br><span class="line"><span class="comment">// does get called - it will be the call to the first __construct() </span></span><br><span class="line"><span class="comment">// function that will fail, and not the actual object construction.</span></span><br><span class="line">counter.method&lt;&amp;Counter::__construct&gt;(<span class="string">"__construct"</span>, Php::Private);</span><br></pre></td></tr></table></figure>
<h3 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h3><p>如果你的类有一个复制构造函数，它就会自动成为可克隆的类。如果你不希望你的类可以被 PHP 脚本克隆，你可以做两件事：</p>
<ol>
<li>你可以从你的类中删除复制构造函数;</li>
<li>你可以注册一个私有的 <code>__clone()</code> 方法，就像我们之前注册一个私有的 <code>__construct()</code> 方法一样。</li>
</ol>
<p>删除复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  Remove the copy constructor</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">*  By removing the copy constructor, the PHP clone operator will</span></span><br><span class="line"><span class="comment">*  automatically be deactivated. PHP will trigger an error if </span></span><br><span class="line"><span class="comment">*  an object is attempted to be cloned.</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">*  @param  counter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Counter(<span class="keyword">const</span> Counter &amp;counter) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>把克隆方法注册为私有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alternative way to make an object unclonable</span></span><br><span class="line">counter.method(<span class="string">"__clone"</span>, Php::Private);</span><br></pre></td></tr></table></figure>
<h3 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h3><p><code>Php::Value</code>类可以作为一个常规的PHP <code>$variable</code>使用，因此你也可以用它来存储对象实例。但是如何创建全新的对象呢？为此，我们有 <code>Php::Object</code> 类，它是一个简单的重写的 <code>Php::Value</code> 类，带有可供选择的构造函数，还有一些额外的检查，以防止你使用 <code>Php::Object</code> 对象来存储对象以外的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new variable holding the string "Counter"</span></span><br><span class="line">Php::<span class="function">Value <span class="title">counter0</span><span class="params">(<span class="string">"Counter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new variable holding a newly created object of type "Counter",</span></span><br><span class="line"><span class="comment">// the __construct() gets called without parameters</span></span><br><span class="line">Php::<span class="function">Object <span class="title">counter1</span><span class="params">(<span class="string">"Counter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new variable holding a newly created object, and </span></span><br><span class="line"><span class="comment">// the __construct() is being called with value 10</span></span><br><span class="line">Php::<span class="function">Object <span class="title">counter2</span><span class="params">(<span class="string">"Counter"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new built-in DateTime object, constructed with "now"</span></span><br><span class="line">Php::<span class="function">Object <span class="title">time</span><span class="params">(<span class="string">"DateTime"</span>, <span class="string">"now"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// valid, a Php::Object is an extended Php::Value, and </span></span><br><span class="line"><span class="comment">// can thus be assigned to a base Php::Value object</span></span><br><span class="line">Php::Value copy1 = counter1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invalid statement, a Php::Object can only be used for storing objects</span></span><br><span class="line">Php::Object copy2 = counter0;</span><br></pre></td></tr></table></figure>
<p><code>Php::Object</code> 的构造函数接收一个类的名称，以及一个可选的参数列表，这些参数将被传递给 <code>__construct()</code> 函数。你可以使用内置的 PHP 类和其他扩展的名称（如 DateTime），你的扩展的类（如 Counter），甚至是 PHP 用户空间的类。</p>
<p>如果你想在不调用 <code>__construct()</code> 函数的情况下构造一个你自己的 C++ 类的实例，也可以使用 <code>Php::Object</code> 类。例如，当 <code>__construct()</code> 方法是私有的，或者当你想绕过对你自己的 <code>__construct()</code> 方法的调用时，这就很有用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actual class implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// c++ constructor</span></span><br><span class="line">    Counter(<span class="keyword">int</span> value) : _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++ destructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// php "constructor"</span></span><br><span class="line">    <span class="keyword">void</span> __construct() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// functions to increment and decrement</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to create a new timer</span></span><br><span class="line">Php::<span class="function">Value <span class="title">createTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Php::Object(<span class="string">"Counter"</span>, <span class="keyword">new</span> Counter(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible,</span></span><br><span class="line">        <span class="comment">// the __construct method is private because PHP scripts are not allowed</span></span><br><span class="line">        <span class="comment">// to create Counter instances</span></span><br><span class="line">        Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::__construct&gt;(<span class="string">"__construct"</span>, Php::Private);</span><br><span class="line">        counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the factory function to create a timer to the extension</span></span><br><span class="line">        myExtension.add(<span class="string">"createTimer"</span>, createTimer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们将 Counter 类的 <code>__construct()</code> 函数设为私有。这使得不可能创建这个类的实例（无论是从 PHP 用户脚本中，还是通过调用 <code>Php::Object(&quot;Counter&quot;)</code>），因为用这些方法构造对象最终会导致一个被禁止的 <code>__construct()</code> 调用。</p>
<p><code>Php::Object</code> 确实有一种替代的语法，它可以接受一个指向 C++ 类的指针（在堆上分配，使用运算符 <code>new</code>！），并将这个指针变成一个 PHP 变量，而无需调用 <code>__construct()</code> 方法。请注意，你还必须指定类名，因为 C++ 类不保存任何关于它们自己的信息（比如它们的名字），而在 PHP 中，这样的信息是处理<code>反射</code>和 <code>get_class()</code> 等函数所需要的。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>PHP和C++都是支持类继承的面向对象编程语言。有一些区别。C++支持多继承，而PHP类只能有一个基类。为了弥补没有多重继承的不足，PHP支持接口和<code>traits</code>。</p>
<p>PHP-CPP库还允许你定义PHP接口，并创建PHP类和PHP接口的层次结构。</p>
<h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><p>如果你想让你的扩展定义一个接口，这样接口就可以从 PHP 用户空间脚本中实现，你可以用类似于定义类的方式来实现。唯一不同的是，你不使用<code>Php::Class&lt;YourClass&gt;</code>，而是使用<code>Php::Interface</code>实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the interface so that PHP knows which methods </span></span><br><span class="line"><span class="comment">// are defined by it</span></span><br><span class="line">Php::<span class="function">Interface <span class="title">interface</span><span class="params">(<span class="string">"MyInterface"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define an interface method</span></span><br><span class="line">interface.method(<span class="string">"myMethod"</span>, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"value"</span>, Php::Type::String, <span class="literal">true</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="派生和实现"><a href="#派生和实现" class="headerlink" title="派生和实现"></a>派生和实现</h3><p>PHP-CPP 库试图使 PHP 和 C++ 的工作尽可能的透明。C++函数可以从PHP用户空间脚本中调用，C++类可以从PHP中访问。然而，归根结底PHP和C++还是不同的语言，由于C++没有PHP那样的反射功能，所以你必须显式地告诉PHP引擎该类实现了哪些基类和接口。</p>
<p><code>Php::Class&lt;YourClass&gt;</code>对象有一个方法 <code>extends()</code>和一个方法 <code>implements()</code>，可以用来指定基类和实现的接口。你需要传入一个你之前配置的类或接口。我们来看一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the interface so that PHP knows which methods </span></span><br><span class="line">        <span class="comment">// are defined by it</span></span><br><span class="line">        Php::<span class="function">Interface <span class="title">myInterface</span><span class="params">(<span class="string">"MyInterface"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// define an interface method</span></span><br><span class="line">        myInterface.method(<span class="string">"myMethod"</span>, &#123; </span><br><span class="line">            Php::ByVal(<span class="string">"value"</span>, Php::Type::String, <span class="literal">true</span>) </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register our own class</span></span><br><span class="line">        Php::Class&lt;MyClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// from PHP user space scripts, it must look like the myClass implements</span></span><br><span class="line">        <span class="comment">// the MyInterface interface</span></span><br><span class="line">        myClass.implements(myInterface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the interface requires that the myMethod method is implemented</span></span><br><span class="line">        myClass.method&lt;&amp;MyClass::myMethod&gt;(<span class="string">"myMethod"</span>, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"value"</span>, Php::Type::String, <span class="literal">true</span>) </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a third class</span></span><br><span class="line">        Php::Class&lt;DerivedClass&gt; derivedClass(<span class="string">"DerivedClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// in PHP scripts, it should look like DerivedClass has "MyClass" </span></span><br><span class="line">        <span class="comment">// as its base</span></span><br><span class="line">        derivedClass.extends(myClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the interface and the classes to the extension</span></span><br><span class="line">        myExtension.add(myInterface);</span><br><span class="line">        myExtension.add(myClass);</span><br><span class="line">        myExtension.add(derivedClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在 <code>get_module()</code> 函数中定义的 PHP 类的层次结构不一定要和 C++ 类的层次结构一致。你的 C++ 类 <code>DerivedClass</code> 根本不需要以 “MyClass”为基础，尽管在 PHP 脚本中它看起来像这样。为了代码的可维护性，当然最好让 PHP 的签名与 C++ 的实现多少有些相似。</p>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>每个PHP类都有 “魔术方法”。你可能已经在写PHP代码时知道这些方法：这些方法以两个下划线开头，名字像<code>__set()</code>,<code>__isset()</code>,<code>__call()</code>等等。</p>
<p>PHP-CPP库也支持这些魔术方法。使用一些C++编译器的技巧，C++编译器会检测你的类中是否存在方法，如果存在，它们会被编译到你的扩展中，并从PHP访问时被调用。</p>
<h3 id="编译时检测"><a href="#编译时检测" class="headerlink" title="编译时检测"></a>编译时检测</h3><p>虽然你可能已经预料到这些魔术方法是<code>Php::Base</code>类中的虚函数，可以被重写，但其实不然。这些方法在编译时被C++编译器检测到（而且是非常正常的方法），只是碰巧有一个特定的名字。</p>
<p>由于编译时的检测，方法的签名有一定的灵活性。许多魔术方法的返回值都是分配给<code>Php::Value</code>对象的，这意味着只要你确保你的魔术方法返回的类型是可以分配给<code>Php::Value</code>的，你就可以在你的类中使用它。因此，你的 <code>__toString()</code> 方法可以返回一个 <code>char*</code>、一个 <code>std::string</code>、<code>Php::Value</code> (甚至是一个整数！)，因为所有这些类型都可以分配给 <code>Php::Value</code>。</p>
<p>用PHP-CPP实现的魔术方法的好处是，它们不会在PHP用户空间中变得可见。换句话说，当你在你的 C++ 类中定义了 <code>__set()</code> 或 <code>__unset()</code> 这样的函数时，这些函数不能被 PHP 脚本显式地调用，但是当一个属性被访问时，它们会被调用。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>一般情况下，魔术方法不需要注册就可以使用。当你在你的类中添加了一个像<code>__toString()</code>或<code>__get()</code>这样的魔术方法时，当一个对象被转换为字符串或一个属性被访问时，它将被自动调用。不需要在<code>get_module()</code>启动函数中显式启用魔术方法。</p>
<p>这个规则的唯一例外是<code>__construct()</code>方法。这个方法必须要明确注册。这其中的原因有很多。首先，<code>__construct()</code>方法没有固定的签名，通过显式添加到扩展中，你还可以指定它接受什么参数，以及<code>__construct()</code>方法应该是公共的、私有的还是保护的（如果你想创建不能从PHP实例化的类）。</p>
<p>另一个必须显式注册 <code>__construct()</code> 方法的原因是，与其他魔术方法不同，<code>__construct</code> 方法必须在 PHP 中可见。在派生类的构造函数里面，经常需要对<code>parent::__construct()</code>进行调用。通过在<code>get_module()</code>函数中注册<code>__construct()</code>方法，你可以使该函数在PHP中可见。</p>
<h3 id="克隆和析构"><a href="#克隆和析构" class="headerlink" title="克隆和析构"></a>克隆和析构</h3><p><code>__clone()</code>方法与<code>__construct()</code>方法非常相似。它也是在构造对象后直接调用的方法。区别在于<code>__clone()</code>是在一个对象被复制构造（克隆）后调用的，而<code>__construct()</code>是在普通构造函数之后调用的。</p>
<p><code>__destruct()</code>方法会在对象被销毁之前被调用（也就是在C++的<code>destructor</code>运行之前）。</p>
<p><code>__clone()</code> 和 <code>__destruct()</code> 方法是常规的魔术方法（与 <code>__construct()</code>不同），因此你不需要注册它们就可以使它们生效。如果你把这两个方法中的一个添加到你的类中，你将不必对<code>get_module()</code>启动函数做任何修改。如果有的话，PHP-CPP 库会自动调用它们。</p>
<p>在正常情况下，你可能不需要这些方法，也可以使用C++复制构造函数和C++析构函数。唯一不同的是，魔术方法是在处于完全初始化状态的对象上调用的，而C++复制构造函数和C++析构函数则是针对正在初始化的对象，或者是针对正在销毁的对象。</p>
<h3 id="伪属性"><a href="#伪属性" class="headerlink" title="伪属性"></a>伪属性</h3><p>通过<code>__get()</code>、<code>__set()</code>、<code>__unset()</code>和<code>__isset()</code>等方法，你可以定义伪属性。例如，它允许您创建只读属性，或在设置时检查其有效性的属性。</p>
<p>这些魔术方法与PHP脚本中的对应方法的工作原理完全一样，所以你可以轻松地将使用这些属性的PHP代码移植到C++中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample class, that has some pseudo properties that map to native types</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Name of the user</span></span><br><span class="line"><span class="comment">     *  @var    std::string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Email address of the user</span></span><br><span class="line"><span class="comment">     *  @var    std::string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructpr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~User() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Get access to a property</span></span><br><span class="line"><span class="comment">     *  @param  name        Name of the property</span></span><br><span class="line"><span class="comment">     *  @return Value       Property value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::Value __get(<span class="keyword">const</span> Php::Value &amp;name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// check if the property name is supported</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">"name"</span>) <span class="keyword">return</span> _name;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">"email"</span>) <span class="keyword">return</span> _email;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// property not supported, fall back on default</span></span><br><span class="line">        <span class="keyword">return</span> Php::Base::__get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Overwrite a property</span></span><br><span class="line"><span class="comment">     *  @param  name        Name of the property</span></span><br><span class="line"><span class="comment">     *  @param  value       New property value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> __set(<span class="keyword">const</span> Php::Value &amp;name, <span class="keyword">const</span> Php::Value &amp;value) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// check the property name</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">"name"</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// store member</span></span><br><span class="line">            _name = value.stringValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we check emails for validity</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">"email"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// store the email in a string</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> email = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// must have a '@' character in it</span></span><br><span class="line">            <span class="keyword">if</span> (email.find(<span class="string">'@'</span>) == <span class="built_in">std</span>::<span class="built_in">string</span>::npos) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// email address is invalid, throw exception</span></span><br><span class="line">                <span class="keyword">throw</span> Php::Exception(<span class="string">"Invalid email address"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// store the member</span></span><br><span class="line">            _email = email;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// other properties fall back to default</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// call default</span></span><br><span class="line">            Php::Base::__set(name, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Check if a property is set</span></span><br><span class="line"><span class="comment">     *  @param  name        Name of the property</span></span><br><span class="line"><span class="comment">     *  @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> __isset(<span class="keyword">const</span> Php::Value &amp;name) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// true for name and email address</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">"name"</span> || name == <span class="string">"email"</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fallback to default</span></span><br><span class="line">        <span class="keyword">return</span> Php::Base::__isset(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Remove a property</span></span><br><span class="line"><span class="comment">     *  @param  name        Name of the property to remove</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> __unset(<span class="keyword">const</span> Php::Value &amp;name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// name and email can not be unset</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">"name"</span> || name == <span class="string">"email"</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// warn the user with an exception that this is impossible</span></span><br><span class="line">            <span class="keyword">throw</span> Php::Exception(<span class="string">"Name and email address can not be removed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fallback to default</span></span><br><span class="line">        Php::Base::__unset(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows </span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;User&gt; user(<span class="string">"User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(user));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子展示了如何创建一个User类，该类似乎有一个名称和电子邮件属性，但不允许你分配一个没有‘@’字符的电子邮件地址，也不允许你删除属性。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize user and set its name and email address</span></span><br><span class="line">$user = <span class="keyword">new</span> User();</span><br><span class="line">$user-&gt;name = <span class="string">"John Doe"</span>;</span><br><span class="line">$user-&gt;email = <span class="string">"john.doe@example.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// show the email address</span></span><br><span class="line"><span class="keyword">echo</span>($user-&gt;email.<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove the email address (this will cause an exception)</span></span><br><span class="line"><span class="keyword">unset</span>($user-&gt;email);</span><br></pre></td></tr></table></figure>
<h3 id="魔术方法-call-callStatic-and-invoke"><a href="#魔术方法-call-callStatic-and-invoke" class="headerlink" title="魔术方法 call(), callStatic() and __invoke()"></a>魔术方法 <strong>call(), </strong>callStatic() and __invoke()</h3><p>C++方法需要在你的扩展<code>get_module()</code>启动函数中明确注册，才能从PHP用户空间访问。然而，当你重写 <code>__call()</code> 方法时，你可以接受所有的调用（甚至是对不存在的方法的调用）。当有人从用户空间对一些看起来像方法的东西进行调用时，它将被传递给这个<code>__call()</code>方法。在脚本中，你可以这样使用<code>$object-&gt;something()</code>，<code>$object-&gt;whatever()</code>或者<code>$object-&gt;anything()</code>（方法的名称是什么并不重要），所有这些调用都会传递给C++类中的<code>__call()</code>方法。</p>
<p><code>__callStatic()</code>方法类似于<code>__call()</code>方法，但适用于静态方法。对<code>YourClass::someMethod()</code>的静态调用可以自动传递给你的C++类的<code>__callStatic()</code>方法。</p>
<p>除了<code>__call()</code>和<code>__callStatic</code>函数，PHP-CPP库还支持<code>__invoke()</code>方法。这是一个当对象实例被当作函数使用时被调用的方法。这可以与C++类中的运算符<code>（）</code>重载相比。通过实现<code>__invoke()</code>方法，PHP用户空间的脚本可以创建一个对象，然后将其作为函数使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample class, that accepts all thinkable method calls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructpr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~MyClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Regular method</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters that were passed to the method</span></span><br><span class="line"><span class="comment">     *  @return Value       The return value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">regular</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is a regular method"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Overriden __call() method to accept all method calls</span></span><br><span class="line"><span class="comment">     *  @param  name        Name of the method that is called</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters that were passed to the method</span></span><br><span class="line"><span class="comment">     *  @return Value       The return value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::Value __call(<span class="keyword">const</span> <span class="keyword">char</span> *name, Php::Parameters &amp;params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the return value</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> retval = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"__call "</span>) + name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop through the parameters</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;param : params)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// append parameter string value to return value</span></span><br><span class="line">            retval += <span class="string">" "</span> + param.stringValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// done</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Overriden __callStatic() method to accept all static method calls</span></span><br><span class="line"><span class="comment">     *  @param  name        Name of the method that is called</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters that were passed to the method</span></span><br><span class="line"><span class="comment">     *  @return Value       The return value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Php::Value __callStatic(<span class="keyword">const</span> <span class="keyword">char</span> *name, Php::Parameters &amp;params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the return value</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> retval = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"__callStatic "</span>) + name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop through the parameters</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;param : params)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// append parameter string value to return value</span></span><br><span class="line">            retval += <span class="string">" "</span> + param.stringValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// done</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Overridden __invoke() method so that objects can be called directly</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters that were passed to the method</span></span><br><span class="line"><span class="comment">     *  @return Value       The return value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::Value __invoke(Php::Parameters &amp;params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// the return value</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> retval = <span class="string">"invoke"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop through the parameters</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;param : params)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// append parameter string value to return value</span></span><br><span class="line">            retval += <span class="string">" "</span> + param.stringValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// done</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows </span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;MyClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register the regular method</span></span><br><span class="line">        myClass.method&lt;&amp;MyClass::regular&gt;(<span class="string">"regular"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(myClass));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在php中使用</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize an object</span></span><br><span class="line">$object = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// call a regular method</span></span><br><span class="line"><span class="keyword">echo</span>($object-&gt;regular().<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call some pseudo-methods</span></span><br><span class="line"><span class="keyword">echo</span>($object-&gt;something().<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>($object-&gt;myMethod(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>($object-&gt;whatever(<span class="string">"a"</span>,<span class="string">"b"</span>).<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call some pseudo-methods in a static context</span></span><br><span class="line"><span class="keyword">echo</span>(MyClass::something().<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MyClass::myMethod(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>).<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MyClass::whatever(<span class="string">"x"</span>,<span class="string">"y"</span>).<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the object as if it was a function</span></span><br><span class="line"><span class="keyword">echo</span>($object(<span class="string">"parameter"</span>,<span class="string">"passed"</span>,<span class="string">"to"</span>,<span class="string">"invoke"</span>).<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regular</span><br><span class="line">__call something</span><br><span class="line">__call myMethod 1 2 3 4</span><br><span class="line">__call whatever a b</span><br><span class="line">__callStatic something</span><br><span class="line">__callStatic myMethod 5 6 7</span><br><span class="line">__callStatic whatever x y</span><br><span class="line">invoke parameter passed to invoke</span><br></pre></td></tr></table></figure>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>在PHP中，你可以在一个类中添加一个<code>__toString()</code>方法。当一个对象被转换为字符串时，或者当一个对象在字符串上下文中被使用时，这个方法会被自动调用。PHP-CPP 也支持这个 <code>__toString()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample class, with methods to cast objects to scalars</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructpr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~MyClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a string</span></span><br><span class="line"><span class="comment">     *  @return Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::Value __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abcd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows </span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;MyClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(myClass));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了这里描述的魔术方法，你可能已经在编写PHP脚本时知道了，PHP-CPP库还引入了一些额外的魔术方法。这些方法包括额外的转换方法，以及比较对象的方法。</p>
<h2 id="魔术接口"><a href="#魔术接口" class="headerlink" title="魔术接口"></a>魔术接口</h2><p>在PHP内核中，自带了一些特殊的”魔术”PHP接口，脚本编写者可以通过这些接口来实现为一个类添加特殊功能。这些接口的名称是’Countable’、’ArrayAccess’和’Serializable’。这些接口带来的功能，也可以用PHP-CPP来实现。</p>
<p>你可能会好奇为什么PHP有时会使用魔术方法（例如<code>__set</code>和<code>__unset</code>），有时会使用接口来改变一个类的行为。这种选择似乎并不统一。对我们来说，不清楚为什么有些特殊功能是用魔术方法来实现的，而有些特殊功能是通过实现接口来激活的。在我们看来，<code>Serializable</code>接口也可以用神奇的<code>__serialize()</code>和<code>__unserialize()</code>方法来实现，或者<code>__invoke()</code>方法也可以是一个”Invokable”接口。PHP 不是一种标准化的语言，有些东西看起来就是这样，因为有人觉得这样或那样的方式来实现它。</p>
<p>尽管如此，PHP-CPP库还是试图尽可能地接近PHP。这就是为什么在你的C++类中，你也可以使用特殊的接口（因为C++没有像PHP那样的接口），所以用纯虚函数的类来代替。</p>
<h3 id="SPL的支持"><a href="#SPL的支持" class="headerlink" title="SPL的支持"></a>SPL的支持</h3><p>一个标准的PHP安装程序会附带标准PHP库（SPL）。这是一个建立在Zend引擎之上的扩展，它使用Zend引擎的特性来创建类和接口，如Countable、Iterator和ArrayAccess。</p>
<p>PHP-CPP 库也有这些名称的接口，它们的行为方式与 SPL 接口大致相同。但在内核中，PHP-CPP库不依赖于SPL。如果你实现了像<code>Php::ArrayAccess</code>或<code>Php::Countable</code>这样的C++接口，这和在PHP中写一个实现SPL接口的类是不同的。</p>
<p>PHP-CPP和SPL都是直接建立在Zend核心之上的，并且提供了相同的功能，但它们并不相互依赖。因此，如果没有加载SPL扩展，可以安全地使用PHP-CPP。</p>
<h3 id="Countable接口"><a href="#Countable接口" class="headerlink" title="Countable接口"></a>Countable接口</h3><p>通过实现<code>Php::Countable</code>接口，你可以创建能传递给PHP <code>count()</code>函数的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The famous counter class, now also implements</span></span><br><span class="line"><span class="comment"> *  the Php::Countable interface</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> Php::Base, <span class="keyword">public</span> Php::Countable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The internal counter value</span></span><br><span class="line"><span class="comment">     *  @var int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Counter() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Counter() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Methods to increment and decrement the counter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++_value; &#125;</span><br><span class="line">    Php::<span class="function">Value <span class="title">decrement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> --_value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method from the Php::Countable interface, that</span></span><br><span class="line"><span class="comment">     *  is used when a Counter instance is passed to the</span></span><br><span class="line"><span class="comment">     *  PHP count() function</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     *  @return long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> override </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows</span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add methods</span></span><br><span class="line">        counter.method(<span class="string">"increment"</span>, &amp;Counter::increment);</span><br><span class="line">        counter.method(<span class="string">"decrement"</span>, &amp;Counter::decrement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前使用的Counter类已经被修改，展示了如何制作实现<code>Php::Countable</code>接口的类。这很简单，你只需要添加<code>Php::Countable</code>类作为基类。这个<code>Php::Countable</code>类有一个纯虚函数<code>count()</code>，必须要实现。</p>
<p>而这就是你要做的一切。不需要在<code>get_module()</code>函数里面注册专门的<code>count()</code>函数，添加<code>Php::Countable</code>作为基类即可。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a counter</span></span><br><span class="line">$counter = <span class="keyword">new</span> Counter();</span><br><span class="line">$counter-&gt;increment();</span><br><span class="line">$counter-&gt;increment();</span><br><span class="line">$counter-&gt;increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// show the current value</span></span><br><span class="line"><span class="keyword">echo</span>(count($counter).<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>输出的结果是，正如预期的那样，数值为3。</p>
<h3 id="ArrayAccess接口"><a href="#ArrayAccess接口" class="headerlink" title="ArrayAccess接口"></a>ArrayAccess接口</h3><p>一个PHP对象可以通过实现<code>Php::ArrayAccess</code>接口变成一个变量，它的行为就像一个数组。当你这样做的时候，可以使用数组访问操作符（<code>$object[&quot;property&quot;]</code>）访问对象。</p>
<p>在下面的例子中，我们使用<code>Php::Countable</code>和<code>Php::ArrayAccess</code>接口来创建一个可以用来存储字符串的关联数组类（记住：这只是一个例子，PHP已经支持关联数组了，所以这个例子有多大用处还值得商榷）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample Map class, that can be used to map string-to-strings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span> :</span> <span class="keyword">public</span> Php::Base, <span class="keyword">public</span> Php::Countable, <span class="keyword">public</span> Php::ArrayAccess</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Internally, a C++ map is used</span></span><br><span class="line"><span class="comment">     *  @var    std::map&lt;std::string,std::string&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; _map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructpr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Map() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method from the Php::Countable interface that</span></span><br><span class="line"><span class="comment">     *  returns the number of elements in the map</span></span><br><span class="line"><span class="comment">     *  @return long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method from the Php::ArrayAccess interface that is</span></span><br><span class="line"><span class="comment">     *  called to check if a certain key exists in the map</span></span><br><span class="line"><span class="comment">     *  @param  key</span></span><br><span class="line"><span class="comment">     *  @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">offsetExists</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _map.find(key) != _map.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Set a member</span></span><br><span class="line"><span class="comment">     *  @param  key</span></span><br><span class="line"><span class="comment">     *  @param  value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">offsetSet</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key, <span class="keyword">const</span> Php::Value &amp;value)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _map[key] = value.stringValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Retrieve a member</span></span><br><span class="line"><span class="comment">     *  @param  key</span></span><br><span class="line"><span class="comment">     *  @return value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> Php::<span class="function">Value <span class="title">offsetGet</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _map[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Remove a member</span></span><br><span class="line"><span class="comment">     *  @param key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">offsetUnset</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _map.erase(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows</span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Map&gt; <span class="built_in">map</span>(<span class="string">"Map"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(<span class="built_in">map</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::ArrayAccess</code>有四个纯虚函数必须要实现。这些方法是用来检索和覆盖一个元素的方法，用来检查是否存在某个键的元素，以及用来删除一个元素的方法。在这个例子中，这些方法都已经实现了转发到一个常规的C++ <code>std::map</code>对象。</p>
<p>在<code>get_module()</code>函数里面，Map被注册并添加到扩展中。但与其他许多例子不同的是，没有一个类方法被导出到PHP中。它只实现了<code>Php::Countable</code>接口和<code>Php::ArrayAccess</code>接口，所以它完全可以用来存储和检索属性，但是从一个PHP脚本来看，它没有任何可调用的方法。下面的脚本展示了如何使用它。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a map</span></span><br><span class="line">$map = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="comment">// store some values</span></span><br><span class="line">$map[<span class="string">"a"</span>] = <span class="number">1234</span>;</span><br><span class="line">$map[<span class="string">"b"</span>] = <span class="string">"xyz"</span>;</span><br><span class="line">$map[<span class="string">"c"</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// show the values</span></span><br><span class="line"><span class="keyword">echo</span>($map[<span class="string">"a"</span>].<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>($map[<span class="string">"b"</span>].<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>($map[<span class="string">"c"</span>].<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// access a value that does not exist</span></span><br><span class="line"><span class="keyword">echo</span>($map[<span class="string">"d"</span>].<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will result in a fatal error,</span></span><br><span class="line"><span class="comment">// the ArrayAccess methods are not exported to user space</span></span><br><span class="line"><span class="keyword">echo</span>($map-&gt;offsetGet(<span class="string">"a"</span>).<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>输出不言而喻。该Map有三个成员，”1234”（字符串变量）、”xyz “和 “0”。</p>
<h3 id="Traversable接口"><a href="#Traversable接口" class="headerlink" title="Traversable接口"></a>Traversable接口</h3><p>类也可以像普通数组一样，在foreach循环中使用。如果你想启用这个功能，你的类应该从<code>Php::Traverable</code>基类中扩展出来并实现<code>getIterator()</code>方法。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fill a map</span></span><br><span class="line">$map = <span class="keyword">new</span> Map();</span><br><span class="line">$map[<span class="string">"a"</span>] = <span class="number">1234</span>;</span><br><span class="line">$map[<span class="string">"b"</span>] = <span class="number">5678</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate over it</span></span><br><span class="line"><span class="keyword">foreach</span> ($map <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// output the key and value</span></span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$key: $value\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PHP-CPP 库实现迭代器的方式与 SPL 略有不同，如果你一直在使用 PHP，你就会习惯这种方式。在PHP中，为了使一个类可以遍历（在foreach循环中使用），你必须实现<code>Iterator</code>接口或<code>IteratorAggregate</code>接口。这是一个奇特的架构。仔细想想，迭代器不是容器对象本身，那个容器对象才是可迭代的!。在我们上面的例子中，$map变量不是实际的迭代器，而是被迭代的容器。真正的迭代器是一个隐藏的对象，不会暴露在你的PHP脚本中，它控制着foreach循环。然而，SPL也会将该map称为迭代器。</p>
<p>因此，在 PHP-CPP 中，我们决定不遵循 SPL API，而是创建了一种全新的方式来实现可遍历类。要使一个类可遍历，必须从<code>Php::Traversable</code>基类中扩展出来，这就迫使你实现<code>getIterator()</code>方法。这个方法应该返回一个<code>Php::Iterator</code>实例。</p>
<p><code>Php::Iterator</code>对象有五个方法是运行foreach循环所需要的。请注意，你的 <code>Iterator</code> 类不需要是一个可以从 PHP 中访问的类，也不需要从 <code>Php::Base</code> 派生。它是一个内部类，被foreach循环使用，但它并不（必须）存在于PHP用户空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample iterator class that can be used to iterate</span></span><br><span class="line"><span class="comment"> *  over a map of strings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapIterator</span> :</span> <span class="keyword">public</span> Php::Iterator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The map that is being iterated over</span></span><br><span class="line"><span class="comment">     *  This is a reference to the actual map</span></span><br><span class="line"><span class="comment">     *  @var    std::map&lt;std::string,std::string&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The actual C++ iterator</span></span><br><span class="line"><span class="comment">     *  @var    std::map&lt;std::string,std::string&gt;l;::const_iterator;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::const_iterator _iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Constructor</span></span><br><span class="line"><span class="comment">     *  @param  object      The object that is being iterated over</span></span><br><span class="line"><span class="comment">     *  @param  map         The internal C++ map that is being iterated over</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MapIterator(Map *object, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;<span class="built_in">map</span>) :</span><br><span class="line">        Php::Iterator(object), _map(<span class="built_in">map</span>), _iter(<span class="built_in">map</span>.begin()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MapIterator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Is the iterator on a valid position</span></span><br><span class="line"><span class="comment">     *  @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _iter != _map.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The value at the current position</span></span><br><span class="line"><span class="comment">     *  @return Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> Php::<span class="function">Value <span class="title">current</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The key at the current position</span></span><br><span class="line"><span class="comment">     *  @return Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> Php::<span class="function">Value <span class="title">key</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _iter-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Move to the next position</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _iter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Rewind the iterator to the front position</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">rewind</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _iter = _map.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample Map class, that can be used to map string-to-strings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span> :</span></span><br><span class="line">    <span class="keyword">public</span> Php::Base,</span><br><span class="line">    <span class="keyword">public</span> Php::Countable,</span><br><span class="line">    <span class="keyword">public</span> Php::ArrayAccess,</span><br><span class="line">    <span class="keyword">public</span> Php::Traversable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Internally, a C++ map is used</span></span><br><span class="line"><span class="comment">     *  @var    std::map&lt;std::string,std::string&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; _map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructpr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Map() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method from the Php::Countable interface that</span></span><br><span class="line"><span class="comment">     *  returns the number of elements in the map</span></span><br><span class="line"><span class="comment">     *  @return long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method from the Php::ArrayAccess interface that is</span></span><br><span class="line"><span class="comment">     *  called to check if a certain key exists in the map</span></span><br><span class="line"><span class="comment">     *  @param  key</span></span><br><span class="line"><span class="comment">     *  @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">offsetExists</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _map.find(key) != _map.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Set a member</span></span><br><span class="line"><span class="comment">     *  @param  key</span></span><br><span class="line"><span class="comment">     *  @param  value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">offsetSet</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key, <span class="keyword">const</span> Php::Value &amp;value)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _map[key] = value.stringValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Retrieve a member</span></span><br><span class="line"><span class="comment">     *  @param  key</span></span><br><span class="line"><span class="comment">     *  @return value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> Php::<span class="function">Value <span class="title">offsetGet</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _map[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Remove a member</span></span><br><span class="line"><span class="comment">     *  @param key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">offsetUnset</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;key)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _map.erase(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Get the iterator</span></span><br><span class="line"><span class="comment">     *  @return Php::Iterator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> Php::<span class="function">Iterator *<span class="title">getIterator</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// construct a new map iterator on the heap</span></span><br><span class="line">        <span class="comment">// the (PHP-CPP library will delete it when ready)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapIterator(<span class="keyword">this</span>, _map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows</span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Map&gt; <span class="built_in">map</span>(<span class="string">"Map"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(<span class="built_in">map</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子进一步扩展了Map类。现在它实现了<code>Php::Countable</code>、<code>Php::ArrayAccess</code>和<code>Php::Traversable</code>。这意味着现在也可以在foreach循环中使用Map对象来迭代属性。</p>
<p>为了达到这个目的，我们必须将<code>Php::Traversable</code>类作为基类添加到Map类中，并实现<code>getIterator()</code>方法。这个方法返回一个新的<code>MapIterator</code>类，它是在堆上分配的。不用担心内存管理：PHP-CPP 库会在 foreach 循环结束的那一刻销毁迭代器。</p>
<p><code>MapIterator</code>类是由<code>Php::Iterator</code>类派生出来的，实现了运行foreach循环所需的五个方法（current()、key()、next()、rewind()和valid()）。请注意，基本的<code>Php::Iterator</code>类期望将迭代过的对象传递给构造函数。这一点是必须的，这样迭代器对象才能确保只要迭代器存在，这个迭代对象就会一直在范围内。</p>
<p>我们内部的<code>MapIterator</code>实现只是一个C++迭代器类的小包装。当然，在需要的时候，你可以创建更复杂的迭代器。</p>
<h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>通过实现 <code>Php::Serializable</code> 接口，你可以为一个类安装自定义的序列化和非序列化处理程序。PHP内置的<code>serialize()</code>函数是一个可以将数组或对象（甚至是充满数组和对象的嵌套数据结构变成简单字符串的函数。<code>unserialize()</code>方法正好相反，它将这样的字符串变回原始数据结构。</p>
<p>一个类的默认序列化实现将一个对象的所有公开可见的属性，并将它们连接成一个字符串。但由于你的类有一个本地实现，而且可能没有公共属性，你可能想安装一个自定义的序列化处理程序。在这个处理程序中，你就可以存储本地对象成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Counter class that can be used for counting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> Php::Base, <span class="keyword">public</span> Php::Serializable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The initial value</span></span><br><span class="line"><span class="comment">     *  @var    int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Counter() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Update methods to increment or decrement the counter</span></span><br><span class="line"><span class="comment">     *  Both methods return the NEW value of the counter</span></span><br><span class="line"><span class="comment">     *  @return int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++_value; &#125;</span><br><span class="line">    Php::<span class="function">Value <span class="title">decrement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> --_value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method to retrieve the current counter value</span></span><br><span class="line"><span class="comment">     *  @return int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Serialize the object into a string</span></span><br><span class="line"><span class="comment">     *  @return std::string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::to_string(_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Unserialize the object from a string</span></span><br><span class="line"><span class="comment">     *  @param  buffer</span></span><br><span class="line"><span class="comment">     *  @param  size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">unserialize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> size)</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _value = <span class="built_in">std</span>::atoi(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::increment&gt;(<span class="string">"increment"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::decrement&gt;(<span class="string">"decrement"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子将之前看到的Counter例子，变成了一个可序列化的对象。<code>Php::Serializable</code>有两个纯虚函数，应该添加到你的类中。调用<code>serialize()</code>方法将对象变成一个字符串，对一个未初始化的对象调用<code>unserialize()</code>方法将其从一个序列化的字符串中恢复出来。请注意，如果一个对象正在使用<code>unserialize()</code>恢复，那么 <code>__construct()</code>方法将不会被调用!</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an empty counter and increment it a few times</span></span><br><span class="line">$counter = <span class="keyword">new</span> Counter();</span><br><span class="line">$counter-&gt;increment();</span><br><span class="line">$counter-&gt;increment();</span><br><span class="line"></span><br><span class="line"><span class="comment">// turn the counter into a storable string</span></span><br><span class="line">$serializedCounter = serialize($counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// revive the counter back into an object</span></span><br><span class="line">$revivedCounter = unserialize($serializedCounter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// show the counter value</span></span><br><span class="line"><span class="keyword">echo</span>($revivedCounter-&gt;value().<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果是2</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>当我们开发 PHP-CPP 库时，我们不得不问自己一个问题，那就是我们应该遵循 PHP 惯例还是遵循 C++ 惯例来实现库中的许多功能。</p>
<p>在 PHP 脚本中，你可以使用<code>魔术方法</code>和<code>魔术接口</code>来为类添加特殊的行为。在C++类中，你也可以实现同样的功能，不过是通过使用<code>操作符重载</code>、<code>隐式构造函数</code>和<code>转换操作符</code>等技术。例如PHP的<code>__invoke()</code>方法，与C++中的<code>operator()</code>多少有些相同。我们问自己的问题是，我们是否应该自动将 PHP 的 <code>__invoke</code> 方法传递给 C++ 的 <code>operator()</code> 调用，还是在 C++ 中也使用同样的 <code>__invoke()</code> 方法名？</p>
<p>我们决定遵循PHP的惯例，在C++中也使用<code>魔术方法</code>和<code>魔术接口</code>（尽管我们必须承认，以两个下划线开头的方法并不能使代码看起来非常漂亮），但是通过使用魔术方法，对于初学C++的程序员来说，从PHP到C++的转换保持了更简单的状态。而且最重要的是，并不是所有的魔术方法和接口都能用C++的核心特性来实现（比如运算符重载），所以我们不得不使用一些魔术方法或接口。这就是为什么我们决定，既然我们必须在C++中使用一些魔术方法，那么我们也可以完全遵循PHP，在C++中也支持所有的PHP魔术方法。</p>
<p>除了PHP用户空间中的魔术方法和接口外，Zend引擎还有一些额外的功能是PHP用户空间脚本无法接触到的。这些功能只有扩展程序员才能使用。PHP-CPP库也支持这些特殊功能。这意味着，如果使用PHP-CPP来编写函数和类，可以实现编写纯PHP代码无法实现的事情。</p>
<h3 id="额外的转换函数"><a href="#额外的转换函数" class="headerlink" title="额外的转换函数"></a>额外的转换函数</h3><p>在内部，Zend引擎有特殊的转换例程来将对象转换为整数、布尔值和浮点值。由于这样或那样的原因，一个PHP脚本只能实现<code>__toString()</code>方法，而其他所有的转换操作都远离它。PHP-CPP 库解决了这一限制，并允许实现其他的转换函数。</p>
<p>PHP-CPP 库的设计目标之一是尽可能地接近 PHP。出于这个原因，转换函数被赋予了与 <code>__toString()</code> 方法相匹配的名称：<code>__toInteger()</code>, <code>__toFloat()</code> 和 <code>__toBool()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample class, with methods to cast objects to scalars</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructpr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~MyClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a string</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  Note that now we use const char* as return value, and not Php::Value.</span></span><br><span class="line"><span class="comment">     *  The __toString function is detected at compile time, and it does</span></span><br><span class="line"><span class="comment">     *  not have a fixed signature. You can return any value that can be picked</span></span><br><span class="line"><span class="comment">     *  up by a Php::Value object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @return const char *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *__toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abcd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a integer</span></span><br><span class="line"><span class="comment">     *  @return long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> __toInteger()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a floating point number</span></span><br><span class="line"><span class="comment">     *  @return double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">double</span> __toFloat()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">88.88</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a boolean</span></span><br><span class="line"><span class="comment">     *  @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> __toBool()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows</span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;MyClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(myClass));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个对象被转换为标量类型时，或者在标量上下文中使用时，会自动调用转换方法。下面的例子说明了这一点。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize an object</span></span><br><span class="line">$object = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cast it</span></span><br><span class="line"><span class="keyword">echo</span>((string)$object.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>((int)$object.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>((bool)$object.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>((float)$object.<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><p>如果你在PHP中用<code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>等比较运算符比较两个对象，Zend引擎会运行一个对象比较函数。PHP-CPP库会拦截这个方法，并将比较方法传递给你的类的<code>__compare</code>方法。换句话说，如果你想安装一个自定义的比较操作符，你可以通过实现<code>__compare()</code>来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample class, that shows how objects can be compared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Internal value of the class</span></span><br><span class="line"><span class="comment">     *  @var    int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> _value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// start with random value</span></span><br><span class="line">        _value = rand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MyClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast the object to a string</span></span><br><span class="line"><span class="comment">     *  @return std::string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::to_string(_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Compare with a different object</span></span><br><span class="line"><span class="comment">     *  @param  that</span></span><br><span class="line"><span class="comment">     *  @return int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> __compare(<span class="keyword">const</span> MyClass &amp;that) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _value - that._value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你在PHP脚本中尝试比较对象时，比较函数会被自动调用。当两个对象相同时，它应该返回0，当’this’对象较小时，返回小于0的值，当’this’对象较大时，返回大于0的值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize a couple of objects</span></span><br><span class="line">$object1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">$object2 = <span class="keyword">new</span> MyClass();</span><br><span class="line">$object3 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare the objects</span></span><br><span class="line"><span class="keyword">if</span> ($object1 &lt; $object2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is smaller than $object2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is bigger than $object2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($object1 == $object3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is equal to $object3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is not equal to $object3\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类成员属性"><a href="#类成员属性" class="headerlink" title="类成员属性"></a>类成员属性</h2><p>当你在PHP中定义一个类时，你可以为它添加属性（成员变量）。然而，当你在一个本地C++类中添加成员变量时，你最好使用常规的本地成员变量，而不是PHP变量。原生变量的性能比PHP变量好得多，如果你也能用<code>int&#39;s</code>和<code>std::string</code>对象来存储整数或字符串，那么在<code>Php::Value</code>对象中存储这些变量就太疯狂了。</p>
<h3 id="普通成员变量"><a href="#普通成员变量" class="headerlink" title="普通成员变量"></a>普通成员变量</h3><p>很难想象，世界上有人愿意创建一个原生类，上面有常规的弱类型的PHP公共属性。然而，如果你坚持，你可以使用PHP-CPP库来实现。让我们以PHP中的一个类为例，看看它在C++中会是什么样子。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Define a public property</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> $property1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// initialize the property</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;property1 = <span class="string">"xyz"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Example method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something with the public property (like changing it)</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;property = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create an instance</span></span><br><span class="line">$example = <span class="keyword">new</span> Example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// overwrite the public property</span></span><br><span class="line">$example-&gt;property1 = <span class="string">"new value"</span>;</span><br></pre></td></tr></table></figure>
<p>上面的例子创建了一个具有一个公共属性的类。这个属性可以被Example类访问，并且因为它是公共的，也可以被其他所有人访问，如示例中所示。如果你喜欢这样的类，你可以用PHP-CPP写一些类似的东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  C++ Example class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Example() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Example() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  php "constructor"</span></span><br><span class="line"><span class="comment">     *  @param  params</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get self reference as Php::Value object</span></span><br><span class="line">        Php::<span class="function">Value <span class="title">self</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize a public property</span></span><br><span class="line">        self[<span class="string">"property1"</span>] = <span class="string">"xyz"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Example method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// get self reference as Php::Value object</span></span><br><span class="line">        Php::<span class="function">Value <span class="title">self</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overwrite the property</span></span><br><span class="line">        self[<span class="string">"property1"</span>] = <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function for the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Example&gt; example(<span class="string">"Example"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register the methods</span></span><br><span class="line">        example.method&lt;&amp;Example::__construct&gt;(<span class="string">"__construct"</span>);</span><br><span class="line">        example.method&lt;&amp;Example::method&gt;(<span class="string">"method"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the Example class has one public property</span></span><br><span class="line">        example.property(<span class="string">"property1"</span>, <span class="string">"xyz"</span>, Php::Public);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(example));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例代码显示了如何在<code>get_module()</code>函数中初始化属性。</p>
<p>你也可以定义私有或受保护的属性，而不是公共属性，但即使是这样也可能不是你想要的，因为在原生C++变量中存储数据要快得多。</p>
<h3 id="静态属性和类常量"><a href="#静态属性和类常量" class="headerlink" title="静态属性和类常量"></a>静态属性和类常量</h3><p>静态属性和类常量可以用类似于属性的方式来定义。唯一不同的是，你必须传递<code>Php::Static</code>或<code>Php::Const</code>标志，而不是<code>Php::Public</code>、<code>Php::Private</code>或<code>Php::Protected</code>访问修饰符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @todo your class definition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Switch to C context so that the get_module() function can be</span></span><br><span class="line"><span class="comment">    *  called by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  Startup function for the extension</span></span><br><span class="line"><span class="comment">        *  @return void*</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Example&gt; example(<span class="string">"Example"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the Example class has a class constant</span></span><br><span class="line">        example.property(<span class="string">"MY_CONSTANT"</span>, <span class="string">"some value"</span>, Php::Const);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// and a public static propertie</span></span><br><span class="line">        example.property(<span class="string">"my_property"</span>, <span class="string">"initial value"</span>, Php::Public | Php::Static);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(example));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类常量可以通过使用<code>Example::MY_CONSTANT</code>从PHP脚本中访问，静态属性可以使用<code>Example::$my_property</code>访问。</p>
<p>除了使用<code>property()</code>方法，你还可以使用<code>constant()</code>方法，或者使用<code>Php::Constant</code>类创建类常量。</p>
<h3 id="Smart-properties"><a href="#Smart-properties" class="headerlink" title="Smart properties"></a>Smart properties</h3><p>通过<code>get()</code>和<code>set()</code>魔术方法，你可以制作更高级的属性，这些属性可以直接映射到C++变量上，并且当一个属性被覆盖时，你可以执行额外的检查，从而使一个对象始终处于有效状态。</p>
<p>除此之外，通过 PHP-CPP 库，你还可以为属性分配 <code>getter</code> 和 <code>setter</code> 方法。每当一个属性被访问时，你的getter或setter方法就会被自动调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  C++ Example class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Example property</span></span><br><span class="line"><span class="comment">     *  @var    int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Example() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Example() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method to get access to the property</span></span><br><span class="line"><span class="comment">     *  @return Php::Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method to overwrite the property</span></span><br><span class="line"><span class="comment">     *  @param  value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// overwrite property</span></span><br><span class="line">        _value = value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sanity check: the value should never exceed 100</span></span><br><span class="line">        <span class="keyword">if</span> (_value &gt; <span class="number">100</span>) _value = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method to retrieve the double property value</span></span><br><span class="line"><span class="comment">     *  @return Php::Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">getDouble</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _value * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function for the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Example&gt; example(<span class="string">"Example"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register the "value" property, with the methods to get and set it</span></span><br><span class="line">        example.property(<span class="string">"value"</span>, &amp;Example::getValue, &amp;Example::setValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register a read-only "double" property, with a method to get it</span></span><br><span class="line">        example.property(<span class="string">"double"</span>, &amp;Example::getDouble);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(example));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的PHP脚本使用了这一点。它创建了一个示例对象，将值属性设置为500（这是不允许的，高于100的值会被四舍五入到100），然后它读出双倍值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create object</span></span><br><span class="line">$object = <span class="keyword">new</span> Example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the value</span></span><br><span class="line">$object-&gt;value = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// show the double value</span></span><br><span class="line"><span class="keyword">echo</span>($object-&gt;double.<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the double value</span></span><br><span class="line"><span class="comment">// (this will trigger an error, this is a read-only property)</span></span><br><span class="line">$object-&gt;double = <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>PHP和C++都支持异常，通过PHP-CPP库，这两种语言之间的异常处理是完全透明的。在 C++ 中抛出的异常会自动传递给 PHP 脚本，而 PHP 脚本抛出的异常可以被 C++ 代码捕获，就像一个普通的 C++ 异常一样。</p>
<p>让我们从一个简单的抛出异常的C++函数开始。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple function that takes two numeric parameters,</span></span><br><span class="line"><span class="comment"> *  and that divides them. Division by zero is of course</span></span><br><span class="line"><span class="comment"> *  not permitted - it will throw an exception then</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">myDiv</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// division by zero is not permitted, throw an exception when this happens</span></span><br><span class="line">    <span class="keyword">if</span> (params[<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">throw</span> Php::Exception(<span class="string">"Division by zero"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// divide the two parameters</span></span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>] / params[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line">        extension.add&lt;myDiv&gt;(<span class="string">"myDiv"</span>, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"a"</span>, Php::Type::Numeric, <span class="literal">true</span>),</span><br><span class="line">            Php::ByVal(<span class="string">"b"</span>, Php::Type::Numeric, <span class="literal">true</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你又一次看到了一个非常简单的扩展。在这个扩展中，我们创建了一个 “myDiv “函数，用来除以两个数字。但是除以零当然是不允许的，所以当试图除以零时，会产生一个异常。下面的 PHP 脚本就使用了这个功能。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">10</span>,<span class="number">2</span>).<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">8</span>,<span class="number">4</span>).<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">5</span>,<span class="number">0</span>).<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">100</span>,<span class="number">10</span>).<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">Exception</span> $exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"exception caught\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子显示了从C++代码中抛出异常并在PHP脚本中捕获异常是多么的简单。PHP-CPP 库会在内部捕获你的 C++ 异常并将其转换为 PHP 异常，但这一切都发生在引擎盖下。对于你这个扩展程序员来说，就好像你根本没有在两种不同的语言中工作，你可以简单地抛出一个Php::Exception对象，就好像它是一个普通的PHP异常一样。</p>
<h3 id="在C-中捕获异常"><a href="#在C-中捕获异常" class="headerlink" title="在C++中捕获异常"></a>在C++中捕获异常</h3><p>反过来，如果你的扩展调用了一个PHP函数，而这个PHP函数恰好抛出了一个异常，你可以像捕获一个普通的C++异常一样捕获它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Php::<span class="function">Value <span class="title">callMe</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// prevent that exceptions bubble up</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// call the function that was supplied by the user</span></span><br><span class="line">        <span class="keyword">return</span> params[<span class="number">0</span>]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Php::Exception &amp;exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Exception caught!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line">        extension.add&lt;callMe&gt;(<span class="string">"callMe"</span>, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"callback"</span>, Php::Type::Callable, <span class="literal">true</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码需要解释一下。正如我们之前提到的，<code>Php::Value</code> 对象可以像使用普通的 PHP <code>$variable</code> 一样使用，因此你可以在其中存储整数、字符串、对象、数组等等。但这也意味着你可以用它来存储函数（因为 PHP 变量也可以用来存储函数）！而这正是我们要做的。</p>
<p>本例扩展中的 <code>callMe()</code> 函数只接收一个参数：一个它将立即调用的回调函数，回调函数的返回值也由 <code>callMe()</code> 函数返回。如果这个回调函数以某种方式抛出一个异常，它将被<code>callMe()</code>函数捕获，并返回一个替代的字符串(“Exception caught!”)。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call "callMe" for the first time, and supply a function that returns "first call"</span></span><br><span class="line">$output = callMe(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"First call"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// show output (this will be "First call")</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="string">"$output\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call "callMe" for the second time, but throw an exception this time</span></span><br><span class="line">$output = callMe(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"Sorry...\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Second call\n"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// show output (this will be "Exception caught")</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="string">"$output\n"</span>);</span><br></pre></td></tr></table></figure>
<p>这个 PHP 脚本使用了我们的扩展，并连续两次调用 callMe() 函数。首先用一个普通函数返回一个字符串，然后用一个抛出异常的函数（扩展会捕捉到这个异常）。输出结果正如你所期望的那样。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>PHP中的变量是弱类型的。因此，一个变量可以容纳任何可能的类型：整数、字符串、浮点数，甚至一个对象或数组。而C++则是一种强类型语言。在C++中，一个整数变量总是有一个数值，而一个字符串变量总是持有一个字符串值。</p>
<p>当你把本地代码和PHP代码混合在一起时，你需要把弱类型的PHP变量转换成本地变量，反之则是：把本地变量转换成弱类型的PHP变量。PHP-CPP库提供了<code>Php::Value</code>类，使这个任务变得非常简单。</p>
<h3 id="Zval’s"><a href="#Zval’s" class="headerlink" title="Zval’s"></a>Zval’s</h3><p>如果你曾经花时间用纯C语言编写过PHP扩展，或者你曾经读过一些关于PHP内部的东西，你一定听说过<code>zval</code>的。zval是一个存储PHP变量的C结构。在内核中，这个zval保留了一个<code>refcount</code>、一个多种类型的联合体和一些其他成员。每次访问这样的zval，对它进行复制，或者对它进行写入，你都必须打破头正确更新<code>refcount</code>，或将zval分割成不同的zval，显式调用复制构造函数，分配或释放内存（使用特殊的内存分配例程），或者选择不这样做，让zval单独存在。</p>
<p>更糟糕的是，在Zend引擎中，有数百个不同的未被记录的宏和函数可以操作这些zval变量。有专门的宏针对zval，有通过<code>指针</code>指向zval的宏，有通过<code>指针的指针</code>指向zval的宏，甚至有通过<code>指针的指针的指针</code>指向zval的宏。</p>
<p>每一个PHP模块、每一个PHP扩展和每一个内置的PHP函数都在忙于处理这些zval结构。没有人花时间把这样的zval包在一个简单的C++类中，为你完成所有这些管理，这是一个很大的惊喜。C++就是这样一门不错的语言，它的构造函数、析构函数、转换运算符和运算符重载，可以封装这些复杂的zval处理。</p>
<p>PHP-CPP引入了<code>Php::Value</code>对象，它的接口非常简单，可以消除所有zval处理的问题。在内部，<code>Php::Value</code>对象是zval变量的一个包装器，但它完全隐藏了zval处理的复杂性。</p>
<h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p><code>Php::Value</code>对象可以用来存储标量类型。可以是整数、浮点数、字符串、布尔值和空值等变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Php::Value value1 = <span class="number">1234</span>;</span><br><span class="line">Php::Value value2 = <span class="string">"this is a string"</span>;</span><br><span class="line">Php::Value value3 = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"another string"</span>);</span><br><span class="line">Php::Value value4 = <span class="literal">nullptr</span>;</span><br><span class="line">Php::Value value5 = <span class="number">123.45</span>;</span><br><span class="line">Php::Value value6 = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p><code>Php::Value</code>类有转换操作符，可以将对象转换成几乎所有可以想到的本地类型。当你可以访问一个<code>Php::Value</code>对象，但想把它存储在一个（访问速度快得多的）本地变量中时，你可以简单地赋值它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value1 = value;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> value2 = value;</span><br><span class="line">    <span class="keyword">double</span> value3 = value;</span><br><span class="line">    <span class="keyword">bool</span> value4 = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>Php::Value</code> 对象持有一个对象，并且你把它用成一个字符串，那么对象的 <code>__toString()</code> 方法就会被调用，这和你在 PHP 脚本中把变量用成字符串的情况完全一样。</p>
<p>许多不同的操作符也被重载，因此你可以在算术操作中直接使用<code>Php::Value</code>对象，将其与其他变量进行比较，或者将其发送到一个输出流。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(Php::Value &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value += <span class="number">10</span>;</span><br><span class="line">    Php::out &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">"some string"</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::Value</code>对象对大多数类型都有隐式构造函数。这意味着每一个接受<code>Php::Value</code>作为参数的函数也可以用原生类型来调用，在应该返回<code>Php::Value</code>的函数中，你可以简单地指定一个标量返回值（它将被编译器自动转换为<code>Php::Value</code>对象）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Php::<span class="function">Value <span class="title">myFunction</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">12</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> myFunction(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你在例子中看到的，你几乎可以用<code>Php::Value</code>对象做任何事情。在内部，它完成了所有的zval操作，有时会变得很复杂，但对于你这个扩展程序员来说，没什么好担心的。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以轻松地存储在<code>Php::Value</code>对象中。将一个字符串赋给<code>Php::Value</code>，或者将一个<code>Php::Value</code>转换为一个字符串是如此的简单，以至于几乎没有任何解释的必要。通常情况下，赋值运算符和转换运算符即可。然而，当性能是一个问题时，你可以考虑直接访问<code>Php::Value</code>对象的内部缓冲区。</p>
<p>当一个<code>Php::Value</code>被转换为<code>std::string</code>时，整个字符串的内容会从<code>Php::Value</code>对象复制到<code>std::string</code>对象中。如果你不想做这样一个完整的拷贝，你可以把值投给一个<code>const char *</code>来代替。这使你可以直接访问<code>Php::Value</code>对象内部的缓冲区。字符串的大小可以用<code>size()</code>方法来检索。但你必须意识到，一旦<code>Php::Value</code>脱离了作用域，缓冲区的指针就不再保证有效了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function</span></span><br><span class="line"><span class="comment"> *  @param  params</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// store the first parameter in a std::string (the entire string</span></span><br><span class="line">    <span class="comment">// buffer is copied from the Php::Value object to the std::string)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> var1 = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it also is possible to cast the object into a const char *. This works</span></span><br><span class="line">    <span class="comment">// too, but the buffer is only valid for as long as the Php::Value object</span></span><br><span class="line">    <span class="comment">// stays in scope</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *var2 = params[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">size_t</span> var2size = params[<span class="number">0</span>].size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以直接写到内核的<code>Php::Value</code>缓冲区。当你把一个字符串分配给<code>Php::Value</code>对象时，整个字符串缓冲区也会被复制。不管你赋值的字符串是<code>std::string</code>还是<code>char*</code>都会有一个拷贝。对于少量字节来说，这几乎不是问题，如果你换一种方式，会让你的代码可读性大大降低。但如果你要复制很多字节，你最好能直接访问缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function to read bytes from a filedescriptor, and</span></span><br><span class="line"><span class="comment"> *  return it as a Php::Value object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  fd          Filedescriptor</span></span><br><span class="line"><span class="comment"> *  @return Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">readExample1</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// buffer to read the bytes in</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the buffer</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes = read(fd, buffer, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes &lt; <span class="number">0</span>) bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert the buffer to a Php::Value object and return it</span></span><br><span class="line">    <span class="keyword">return</span> Php::Value(buffer, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Another example function, that does the same as the previous</span></span><br><span class="line"><span class="comment"> *  function, but now it reads the bytes directly into a Php::Value</span></span><br><span class="line"><span class="comment"> *  buffer, and does not use an intermediate buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  fd          Filedescriptor</span></span><br><span class="line"><span class="comment"> *  @param  Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">readExample2</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// result variable</span></span><br><span class="line">    Php::Value result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize the buffer to 4096 bytes, the reserve() method resizes</span></span><br><span class="line">    <span class="comment">// the internal buffer to the appropriate size, and returns a pointer</span></span><br><span class="line">    <span class="comment">// to the buffer</span></span><br><span class="line">    <span class="keyword">char</span> *buffer = result.reserve(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read in the bytes directly into the just allocated buffer</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes = read(fd, buffer, <span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes &lt; <span class="number">0</span>) bytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resize the buffer to the actual number of bytes in it (this</span></span><br><span class="line">    <span class="comment">// is necessary, otherwise the PHP strlen() returns 4096 even</span></span><br><span class="line">    <span class="comment">// when less bytes were available</span></span><br><span class="line">    result.reserve(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the result</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个例子函数比较容易读懂。<code>read()</code>系统调用用于向本地缓冲区填充字节。然后将这个本地缓冲区转换为<code>Php::Value</code>对象并返回。</p>
<p>第二个示例函数更有效率，因为现在系统调用<code>read()</code>会立即将字节读到<code>Php::Value</code>对象的缓冲区中，而不是读到一个临时缓冲区中。作为一个程序员，你必须根据你的需求在这些算法中选择一种：<strong>简单的代码或更高效的代码</strong>。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>PHP支持两种数组类型：常规数组（以数字为索引）和关联数组（以字符串为索引）。<code>Php::Value</code>对象也支持数组。通过使用数组访问操作符(方括号)给<code>Php::Value</code>对象赋值，你会自动把它变成一个数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a regular array</span></span><br><span class="line">Php::Value <span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = <span class="string">"apple"</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>] = <span class="string">"banana"</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">2</span>] = <span class="string">"tomato"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// an initializer list can be used to create a filled array</span></span><br><span class="line">Php::<span class="function">Value <span class="title">filled</span><span class="params">(&#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can cast an array to a vector, template parameter can be</span></span><br><span class="line"><span class="comment">// any type that a Value object is compatible with (string, int, etc)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fruit = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create an associative array</span></span><br><span class="line">Php::Value assoc;</span><br><span class="line">assoc[<span class="string">"apple"</span>] = <span class="string">"green"</span>;</span><br><span class="line">assoc[<span class="string">"banana"</span>] = <span class="string">"yellow"</span>;</span><br><span class="line">assoc[<span class="string">"tomato"</span>] = <span class="string">"green"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the variables in an array do not all have to be of the same type</span></span><br><span class="line">Php::Value assoc2;</span><br><span class="line">assoc2[<span class="string">"x"</span>] = <span class="string">"info@example.com"</span>;</span><br><span class="line">assoc2[<span class="string">"y"</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">assoc2[<span class="string">"z"</span>] = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested arrays are possible too</span></span><br><span class="line">Php::Value assoc2;</span><br><span class="line">assoc2[<span class="string">"x"</span>] = <span class="string">"info@example.com"</span>;</span><br><span class="line">assoc2[<span class="string">"y"</span>] = <span class="literal">nullptr</span>;</span><br><span class="line">assoc2[<span class="string">"z"</span>][<span class="number">0</span>] = <span class="string">"a"</span>;</span><br><span class="line">assoc2[<span class="string">"z"</span>][<span class="number">1</span>] = <span class="string">"b"</span>;</span><br><span class="line">assoc2[<span class="string">"z"</span>][<span class="number">2</span>] = <span class="string">"c"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assoc arrays can be cast to a map, indexed by string</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="built_in">map</span> = assoc2;</span><br></pre></td></tr></table></figure>
<p>从数组中读取数据也同样简单。你也可以使用数组访问运算符（方括号）来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Php::Value <span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="string">"x"</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="string">"y"</span>] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">Php::out &lt;&lt; <span class="built_in">array</span>[<span class="string">"x"</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">Php::out &lt;&lt; <span class="built_in">array</span>[<span class="string">"y"</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>还有一个特殊的<code>Php::Array</code>类。这是一个扩展的<code>Php::Value</code>类，在构造时，立即以空数组开始（不像<code>Php::Value</code>对象默认构造为<code>NULL</code>值）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create empty array</span></span><br><span class="line">Php::Array array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Php::Value is the base class, so you can assign Php::Array objects</span></span><br><span class="line">Php::Value array2 = array1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impossible, a Php::Array must always be an array</span></span><br><span class="line">array1 = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>就像<code>Php::Array</code>类是一个扩展的<code>Php::Value</code>，初始化为一个空数组一样，也有一个<code>Php::Object</code>类在构造时成为一个对象。默认情况下，这是一个<code>stdClass</code>的实例（PHP最简单的类）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create empty object of type stdClass</span></span><br><span class="line">Php::Object object;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Php::Value is the base class, so you can assign Php::Object objects</span></span><br><span class="line">Php::Value value = object;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impossible, a Php::Object must always be an object</span></span><br><span class="line">object = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object properties can be accessed with square brackets</span></span><br><span class="line">object[<span class="string">"property1"</span>] = <span class="string">"value1"</span>;</span><br><span class="line">object[<span class="string">"property2"</span>] = <span class="string">"value2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to create an object of a different type, pass in the class name</span></span><br><span class="line"><span class="comment">// to the constructor with optional constructor parameters</span></span><br><span class="line">object = Php::Object(<span class="string">"DateTime"</span>, <span class="string">"now"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// methods can be called with the call() method</span></span><br><span class="line">Php::out &lt;&lt; object.call(<span class="string">"format"</span>, <span class="string">"Y-m-d H:i:s"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// all these methods can be called on a Php::Value object too</span></span><br><span class="line">Php::Value value = Php::Object(<span class="string">"DateTime"</span>, <span class="string">"now"</span>);</span><br><span class="line">Php::out &lt;&lt; value.call(<span class="string">"format"</span>, <span class="string">"Y-m-d H:i:s"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>当你用PHP-CPP库创建了自己的类，你可以使用相同的<code>Php::Object</code>类来制作它的实例。因为PHP和C++是不同的语言，所以从函数中返回的对象实例（<code>Php::Value</code>或<code>Php::Object</code>实例）和在C++代码中内核使用的变量（普通的C++指针）是有区别的。PHP-CPP允许你轻松转换这两种类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  First factory method</span></span><br><span class="line"><span class="comment">     *  @return Php::Value      object holding a new MyClass instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Php::<span class="function">Value <span class="title">factory1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// use the Php::Object class to create an instance (this will</span></span><br><span class="line">        <span class="comment">// result in __construct() being called)</span></span><br><span class="line">        <span class="keyword">return</span> Php::Object(<span class="string">"MyClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Alternative factory method</span></span><br><span class="line"><span class="comment">     *  @return Php::Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Php::<span class="function">Value <span class="title">factory2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// create an instance ourselves</span></span><br><span class="line">        MyClass *object = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the object now only exists as C++ object, to ensure that it is also</span></span><br><span class="line">        <span class="comment">// registered as an object in PHP user space, we wrap it in a</span></span><br><span class="line">        <span class="comment">// Php::Object class (which is an extended Php::Value class). Because</span></span><br><span class="line">        <span class="comment">// PHP supports reflection it is necessary to also pass in the class</span></span><br><span class="line">        <span class="comment">// name. The __construct() method will _not_ be called - because the</span></span><br><span class="line">        <span class="comment">// C++ object is already instantiated.</span></span><br><span class="line">        <span class="keyword">return</span> Php::Object(<span class="string">"MyClass"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method that returns 'this' to allow chaining ($x-&gt;chain()-&gt;chain()).</span></span><br><span class="line"><span class="comment">     *  @return Php::Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">chain</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the Php::Value has an implicit constructor for Php::Base pointers.</span></span><br><span class="line">        <span class="comment">// This means that you can safely return 'this' from a method, which</span></span><br><span class="line">        <span class="comment">// will automatically be converted into a valid Php::Value object. This</span></span><br><span class="line">        <span class="comment">// works only for pointers to objects that already exist in PHP user</span></span><br><span class="line">        <span class="comment">// space.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Method that gets a MyClass instance as parameter</span></span><br><span class="line"><span class="comment">     *  @param  params      vector holding all parameters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// store the first parameter in a Php::Value object</span></span><br><span class="line">        Php::Value value = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if you know for sure that the 'value' variable holds a (wrapped)</span></span><br><span class="line">        <span class="comment">// instance of a MyClass object, you can convert the value back into</span></span><br><span class="line">        <span class="comment">// a pointer to the original C++ object by calling the 'implementation'</span></span><br><span class="line">        <span class="comment">// method.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this only works for value objects that hold instances of</span></span><br><span class="line">        <span class="comment">// C++ classes defined by your extension! Calling the 'implementation()'</span></span><br><span class="line">        <span class="comment">// method on a non-object, on an object of a user space class, or of</span></span><br><span class="line">        <span class="comment">// a core PHP class or a class from a different extension will probably</span></span><br><span class="line">        <span class="comment">// result in a crash!</span></span><br><span class="line">        MyClass *object = (MyClass *)value.implementation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><code>Php::Value</code>类实现了<code>begin()</code>和<code>end()</code>方法，就像许多C++ STL容器一样。因此，你可以像遍历一个<code>std::map</code>类一样遍历一个<code>Php::Value</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Function that accepts an array as parameter</span></span><br><span class="line"><span class="comment"> *  @param  array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">const</span> Php::Value &amp;value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// assum the value variable holds an array or object, it then</span></span><br><span class="line">    <span class="comment">// is possible to iterate over the values or properties</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;iter : value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// output key and value</span></span><br><span class="line">        Php::out &lt;&lt; iter.first &lt;&lt; <span class="string">": "</span> &lt;&lt; iter.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代值是一个<code>std::pair&lt;Php::Value::Php::Value&gt;</code>。你可以访问它的属性’first’来获取当前的键，而属性’second’来获取当前的值。这和你在<code>std::map</code>上迭代的方式是一样的。</p>
<p>你可以遍历所有持有对象或数组的<code>Php::Value</code>对象。当你在一个数组上迭代时，迭代器只是简单地迭代数组中的所有记录。</p>
<p>对于对象来说，有一些东西需要考虑。如果你迭代的对象实现了<code>Iterator</code>或<code>IteratorAggregate</code>接口，C++迭代器就会使用这些内置的接口并调用它的方法来遍历对象。对于常规对象（那些没有实现<code>Iterator</code>或<code>IteratorAggregate</code>的对象），迭代器只是简单地迭代对象的所有公共属性。</p>
<p>一个迭代器可以在两个方向上使用：操作符<code>++</code>以及操作符<code>--</code>都可以使用。但要注意使用<code>--</code>操作符。如果<code>Php::Value</code>对象持有一个实现了<code>Iterator</code>或<code>IteratorAggregate</code>的对象，反向迭代就无法进行，因为内部迭代器只有一个<code>next()</code>方法，PHP-CPP库没有办法指示内部迭代器向后移动。</p>
<p>同时要注意<code>++</code>后缀操作符的返回值。通常情况下，后缀增量操作会返回操作前的原始值。当你在实现了 <code>Iterator</code> 或 <code>IteratorAggregate</code> 的对象上进行迭代时，情况就不同了，因为 PHP-CPP 库不可能复制一个 PHP 迭代器。因此，<code>++</code>后缀操作符（只有在<code>Iterator</code>或<code>IteratorAggregate</code>对象上使用时）会返回一个全新的迭代器，该迭代器回到对象的前部位置。但请记住，在C++和PHP（以及许多其他编程语言）中，使用<code>++</code>前缀操作符要明智得多，因为这不需要对原始对象进行复制，所以无论如何你都不应该使用<code>++</code>后缀操作符。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>当一个<code>Php::Value</code>对象持有一个可调用的对象时，你可以使用<code>（）</code>操作符来调用这个函数或方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a string with a function name</span></span><br><span class="line">Php::Value date = <span class="string">"date"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "date" is a built-in PHP function and thus can it be called</span></span><br><span class="line">Php::out &lt;&lt; date(<span class="string">"Y-m-d H:i:s"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a date-time object</span></span><br><span class="line">Php::Object now = Php::Object(<span class="string">"DateTime"</span>,<span class="string">"now"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create an array with two members, the datetime object</span></span><br><span class="line"><span class="comment">// and the name of a method</span></span><br><span class="line">Php::<span class="function">Array <span class="title">array</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = now;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>] = <span class="string">"format"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// an array with two members can be called too, the first</span></span><br><span class="line"><span class="comment">// member is seen as the object, and the second as the</span></span><br><span class="line"><span class="comment">// name of the method</span></span><br><span class="line">Php::out &lt;&lt; <span class="built_in">array</span>(<span class="string">"Y-m-d H:i:s"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>要读取或更新全局PHP变量，你可以使用<code>Php::GLOBALS</code>变量。这个变量的工作原理和PHP脚本中的<code>$GLOBALS</code>变量差不多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set a global PHP variable</span></span><br><span class="line">Php::GLOBALS[<span class="string">"a"</span>] = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global variables can be of any type</span></span><br><span class="line">Php::GLOBALS[<span class="string">"b"</span>] = Php::Array(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// nested calls are (of course) supported</span></span><br><span class="line">Php::GLOBALS[<span class="string">"b"</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and global variables can also be read</span></span><br><span class="line">Php::out &lt;&lt; Php::GLOBALS[<span class="string">"b"</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>除了<code>$GLOBALS</code>变量之外，PHP还允许你使用<code>$_GET</code>、<code>$_POST</code>、<code>$_COOKIE</code>、<code>$_FILES</code>、<code>$_SERVER</code>、<code>$_REQUEST</code>和<code>$_ENV</code>变量来访问变量。在你的C++扩展中，你可以用全局变量<code>Php::GET</code>, <code>Php::POST</code>, <code>Php::COOKIE</code>, <code>Php::FILES</code>, <code>Php::SERVER</code>, <code>Php::REQUEST</code>和<code>Php::ENV</code>做类似的事情。这些都是全局的、只读的、具有重载操作符<code>[]</code>方法的对象。因此，你可以像访问关联数组一样访问它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retrieve the value of a request variable</span></span><br><span class="line"><span class="keyword">int</span> age = Php::REQUEST[<span class="string">"name"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// or retrieve the value of a server variable</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> referer = Php::SERVER[<span class="string">"HTTP_REFERER"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="小心C-全局变量"><a href="#小心C-全局变量" class="headerlink" title="小心C++全局变量"></a>小心C++全局变量</h3><p>与PHP脚本不同的是，PHP脚本只能处理单个请求会话，而扩展则是用来处理多个请求会话。这意味着当你在扩展中使用全局C++(!)变量时，这些变量不会在会话之间被设置回初始值。然而，<code>Php::GLOBALS</code>变量总是在每个新的会话开始时重新初始化。</p>
<h2 id="全局常量和类级常量"><a href="#全局常量和类级常量" class="headerlink" title="全局常量和类级常量"></a>全局常量和类级常量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在 PHP 脚本中可以定义常量（包括全局常量和类级常量）。这也可以通过 PHP-CPP 来实现。如果你想把常量暴露在用户空间的PHP代码中，你可以通过在<code>get_module()</code>调用中添加常量到<code>Php::Extension</code>对象中来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add integer constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_1"</span>, <span class="number">1</span>));</span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_2"</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// floating point constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_3"</span>, <span class="number">3.1415927</span>));</span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_4"</span>, <span class="number">4.932843</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// string constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_5"</span>, <span class="string">"This is a constant value"</span>));</span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_6"</span>, <span class="string">"Another constant value"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// null constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_7"</span>, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>
<p>在php中使用常量</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_1.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_2.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_3.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_4.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_5.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_6.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_7.<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>PHP也支持类级常量的概念。在内部，在Zend引擎中，类级常量被实现为常规的类成员，但是常量属性没有 “public “或 “private “标志，而是用 “constant “标志来标记。PHP-CPP也暴露了这一点。你可以用<code>Php::Const</code>标志来注册类属性。</p>
<p>除此之外，一个<code>Php::Class</code>实例也有一个 “constant”方法，你可以将<code>Php::Constant</code>的实例添加到类中。从语义上看，这三种创建类级常量的方法都是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The C++ class that we're going to expose</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (For this example we use a completely empty class, as only examples</span></span><br><span class="line"><span class="comment"> *  are given on how to use constants)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dummy</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function for the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a class objects</span></span><br><span class="line">        Php::Class&lt;Dummy&gt; dummy(<span class="string">"Dummy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// there are many different ways to add constants, but semantically,</span></span><br><span class="line">        <span class="comment">// they're all the same</span></span><br><span class="line">        dummy.property(<span class="string">"MY_CONSTANT_1"</span>, <span class="number">1</span>, Php::Const);</span><br><span class="line">        dummy.property(<span class="string">"MY_CONSTANT_2"</span>, <span class="string">"abcd"</span>, Php::Const);</span><br><span class="line">        dummy.constant(<span class="string">"MY_CONSTANT_3"</span>, <span class="string">"xyz"</span>);</span><br><span class="line">        dummy.constant(<span class="string">"MY_CONSTANT_4"</span>, <span class="number">3.1415</span>);</span><br><span class="line">        dummy.add(Php::Constant(<span class="string">"MY_CONSTANT_5"</span>, <span class="string">"constant string"</span>));</span><br><span class="line">        dummy.add(Php::Constant(<span class="string">"MY_CONSTANT_5"</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(dummy));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时常量"><a href="#运行时常量" class="headerlink" title="运行时常量"></a>运行时常量</h3><p>如果你想在运行时从你的C++代码中找出一个用户空间常量的值，或者当你想找出一个常量是否被定义时，你可以简单地使用<code>Php::constant()</code>或<code>Php::defined()</code>函数。要在运行时定义常量，请使用<code>Php::define()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Function that can be called from a PHP script</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check if a certain user space constant is defined</span></span><br><span class="line">    <span class="keyword">if</span> (Php::defined(<span class="string">"USER_SPACE_CONSTANT"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// retrieve the value of a constant</span></span><br><span class="line">        Php::Value constant = Php::constant(<span class="string">"ANOTHER_CONSTANT"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// define other constants at runtime</span></span><br><span class="line">        Php::define(<span class="string">"DYNAMIC_CONSTANT"</span>, <span class="number">12345</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从php-ini读取配置"><a href="#从php-ini读取配置" class="headerlink" title="从php.ini读取配置"></a>从php.ini读取配置</h2><p>从php.ini文件中读取设置就像从普通PHP脚本中获取设置一样简单。在PHP脚本中，你可以使用内置的<code>ini_get()</code>函数从php.ini文件中读取设置，而在你的C++扩展中，你可以使用<code>Php::ini_get()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple function that is used to demonstrate how settings from the</span></span><br><span class="line"><span class="comment"> *  php.ini file can be read</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read in the "output_buffering" variable from the php.ini file</span></span><br><span class="line">    <span class="keyword">int</span> output_buffering = Php::ini_get(<span class="string">"output_buffering"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read in the "variables_order" variable</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> variables_order = Php::ini_get(<span class="string">"variables_order"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::ini_get()</code>函数返回一个可以分配给字符串、整数和浮点数的对象。在上面的例子中，我们使用这个函数将设置直接分配给一个整数和一个<code>std::string</code>。</p>
<p>你只能从php.ini中获取预定义的变量。因此不可能用随机字符串调用<code>Php::ini_get()</code>. 如果你想使用你自己的变量，你必须先在get_module()函数中注册它们，然后才能调用<code>Php::ini_get()</code>来获取当前值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple function that is used to demonstrate how settings from the</span></span><br><span class="line"><span class="comment"> *  php.ini file can be read</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read in a variable defined for this extension</span></span><br><span class="line">    <span class="keyword">int</span> var1 = Php::ini_get(<span class="string">"my_extension.var1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read in a string variable</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> var2 = Php::ini_get(<span class="string">"my_extension.var2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C contect so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by the Zend engine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The get_module() startup function</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// export one function</span></span><br><span class="line">        extension.add(<span class="string">"myFunction"</span>, myFunction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tell the PHP engine that the php.ini variables my_extension.var1</span></span><br><span class="line">        <span class="comment">// and my_extension.var2 are usable</span></span><br><span class="line">        extension.add(Php::Ini(<span class="string">"my_extension.var1"</span>, <span class="string">"default-value"</span>));</span><br><span class="line">        extension.add(Php::Ini(<span class="string">"my_extension.var2"</span>, <span class="number">12345</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return a pointer to the extension object</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展回调函数"><a href="#扩展回调函数" class="headerlink" title="扩展回调函数"></a>扩展回调函数</h2><p><code>get_module()</code>函数在你的扩展启动时被调用。它返回一个内存地址，在那里Zend引擎可以找到关于你的扩展的所有相关信息。</p>
<p>在这个<code>get_module()</code>的调用之后，你的扩展就会被加载，并将被用来处理多个请求会话。这是标准PHP脚本和本地扩展之间的一个重要区别，因为标准PHP脚本只处理单个请求。但扩展服务于多个请求后。</p>
<p>如果你使用全局的C++变量，这种区别就显得尤为重要。这样的全局变量会在扩展加载时被初始化（而不是在每个请求开始时）。你对全局变量所做的更改会保留它们的值，因此后续的请求会看到更新后的值。</p>
<p>顺便说一下，这只发生在本地变量上。存储在<code>Php::GLOBALS</code>对象中的全局PHP变量，会在每次请求开始时重新初始化。你不必担心你对全局PHP变量所做的修改：在下一个请求开始时，<code>Php::GLOBALS</code>对象是全新的，你在上一个请求中所做的修改不再可见。</p>
<p>回到全局的C++变量。如果你想在一个新的请求开始时重置一个全局变量，你可以注册一个特殊的回调函数，这个函数在每个请求前被调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Global variable that stores the number of times</span></span><br><span class="line"><span class="comment"> *  the function updateCounters() has been called in total</span></span><br><span class="line"><span class="comment"> *  @var    int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> invokeTotalCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Global variable that keeps track how many times the</span></span><br><span class="line"><span class="comment"> *  function updateCounters() was called during the</span></span><br><span class="line"><span class="comment"> *  current request</span></span><br><span class="line"><span class="comment"> *  @var    int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> invokeDuringRequestCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function updates a number of global variables that count</span></span><br><span class="line"><span class="comment"> *  the number of times a function was called</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCounters</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// increment global counters</span></span><br><span class="line">    invokeTotalCount++;</span><br><span class="line">    invokeDuringRequestCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context, because the Zend engine expects get get_module()</span></span><br><span class="line"><span class="comment"> *  to have a C style function signature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  when PHP starts, and that should return the extension details</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// install a callback that is called at the beginning</span></span><br><span class="line">        <span class="comment">// of each request</span></span><br><span class="line">        extension.onRequest([]() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// re-initialize the counter</span></span><br><span class="line">            invokeDuringRequestCount = <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the updateCounter method to the extension</span></span><br><span class="line">        extension.add(<span class="string">"updateCounters"</span>, updateCounters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension details</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::Extension</code>类有一个方法<code>onRequest()</code>，在上面的例子中用来注册一个回调函数。这个回调会在每个请求之前被调用。正如你所看到的，它是允许使用C++ lambda函数的。</p>
<p><code>onRequest()</code>并不是<code>Php::Extension</code>对象中唯一可以注册回调的方法。事实上，有四种不同的<code>on*()</code>方法可以使用。</p>
<ul>
<li>void onStartup(const std::function&lt;void()&gt; &amp;callback);</li>
<li>void onRequest(const std::function&lt;void()&gt; &amp;callback);</li>
<li>void onIdle(const std::function&lt;void()&gt; &amp;callback);</li>
<li>void onShutdown(const std::function&lt;void()&gt; &amp;callback);</li>
</ul>
<p>当Zend引擎已经加载了你的扩展，并且其中的所有函数和类都被注册时，启动回调被调用。如果你想在函数被调用之前初始化扩展中的其他变量，你可以使用onStartup()函数并注册一个回调来运行这个初始化代码。</p>
<p>Zend引擎初始化后，就可以处理请求了。在上面的例子中，我们使用了onRequest()方法来注册一个回调，这个回调会在每个请求前被调用。除此之外，你还可以安装一个回调，当Zend引擎进入空闲状态时，这个回调会在每次请求后被调用。</p>
<p>等待下一个请求。这可以通过Php::Extension对象中的onIdle()方法来实现。</p>
<p>第四个可以注册的回调是在PHP关闭前被调用的回调。如果有什么需要清理的地方，可以安装这样的回调，并从中运行清理代码。</p>
<h3 id="预先fork的Web引擎-如Apache"><a href="#预先fork的Web引擎-如Apache" class="headerlink" title="预先fork的Web引擎 (如Apache)"></a>预先fork的Web引擎 (如Apache)</h3><p>如果你在一个<code>pre-forked</code>的web服务器（比如Apache）上运行PHP，你的扩展会在各种工作进程被fork之前被加载和初始化。这样做的后果是，<code>get_module()</code>函数和你可选的<code>onStartup()</code>回调函数被父进程调用，而所有其他回调和实际的页面处理被子进程调用。因此，对<code>getpid()</code>的调用(或其他用于检索当前进程信息的函数)将在<code>onStartup</code>回调中返回其他东西，就像在其他扩展函数中一样。</p>
<p>你可能要因此而小心。最好不要在启动函数中做一些在进程fork成不同子进程时可能无法工作的事情（比如打开文件描述符）。还有一点需要注意的是，启动函数只在Apache启动（或重载，见后文）时被父进程调用，而关闭函数则被每个平滑退出的子进程调用。因此，<code>onShutdown</code>不仅在Apache进程停止时被调用，而且在其中一个工作进程因为不再需要而退出时，或者因为它被一个新的工作进程取代而被调用。</p>
<p><code>get_module()</code>函数在你的扩展被初始化时被调用。但不仅如此。当apache被重载时(例如通过给命令行指令 “apachectl reload”)，你的<code>get_module()</code>会被第二次调用，你在<code>Extension::onStartup()</code>中注册的回调也会被再次调用。这通常不是问题，因为在第一次调用<code>get_module()</code>后，静态扩展对象处于锁定状态，在第二次调用<code>get_module()</code>时，你试图添加到扩展对象中的函数和类会被直接忽略。</p>
<h3 id="注意多线程"><a href="#注意多线程" class="headerlink" title="注意多线程"></a>注意多线程</h3><p>如果你的扩展运行在多线程的PHP安装模式上，你需要格外小心。大多数PHP安装模式（Apache、CLI脚本等）一次只服务一个请求，按顺序进行。然而，有一些PHP安装模式使用了多线程，并且可以并行处理多个请求。如果你的扩展在这样的环境中运行，你应该知道你的全局（和静态）变量也可以被多个线程同时访问。使用<code>std::mutex</code>或<code>std::atomic</code>等技术来防止数据竞态条件和冲突是你自己的责任。</p>
<p>如果你的扩展是为多线程环境编译的，PHP-CPP头文件定义了宏<code>ZTS</code>。你可以使用这个宏来检查是否需要创建特殊的代码来处理线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Global variable that store the number of times</span></span><br><span class="line"><span class="comment"> *  the function updateCounters() has been called in total</span></span><br><span class="line"><span class="comment"> *  @var    int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> invokeTotalCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Mutex so that the 'invokeTotalCount' variable is only accessed</span></span><br><span class="line"><span class="comment"> *  by one process at a time</span></span><br><span class="line"><span class="comment"> *  @var    std::mutex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::mutex invokeTotalMutex;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function updates a number of global variables that count</span></span><br><span class="line"><span class="comment"> *  the number of times a function was called</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCounters</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock the mutex</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(invokeTotalMutex);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment counters</span></span><br><span class="line">    invokeTotalCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个重要的事情是，PHP内部也做了这种锁定。如果你从你的C++代码中调用一个PHP函数（比如<code>Php::Value(&quot;myFunction&quot;)()</code>），或者当你访问<code>Php::GLOBALS</code>数组中的一个PHP变量（或者其他超级全局变量之一）时，PHP必须锁定一些东西以确保没有其他线程同时访问相同的信息。这些操作可能很昂贵。</p>
<p>因此，用 PHP-CPP 编写本地扩展的良好经验：</p>
<ul>
<li>不要使用全局变量</li>
<li>只调用其他本地函数，不要回调到PHP中。</li>
</ul>
<p>这些规则并不像它们看起来那样具有局限性。全局变量的使用并不被认为是优秀的软件设计，所以你可能根本就没有使用它们，你之所以要写一个本地扩展，首先是因为你想摆脱PHP。从你的扩展代码中调用（慢的）PHP函数，无论如何都应该被阻止。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>尽管在 PHP 脚本中，命名空间有非常丰富的实现方式，有特殊的关键字，如 <code>use</code> 和 <code>namespace</code> 以及特殊的常量，如 <code>__NAMESPACE__</code>，但它们内部非常简单。</p>
<p>命名空间无非就是一个类或函数的前缀。如果你想让你的类或函数出现在一个特定的命名空间中，你只需要在类或函数名中添加一个前缀。下面的代码在 “myNamespace”命名空间中创建了一个函数 “myFunction”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add the myFunction function to the extension, </span></span><br><span class="line"><span class="comment">// and put it in namespace "myNamespace"</span></span><br><span class="line">extension.add(<span class="string">"myNamespace\\myFunction"</span>, myFunction);</span><br></pre></td></tr></table></figure>
<p>如果你愿意，你可以使用<code>Php::Namespace</code>实用类来实现。这个类的签名和<code>Php::Extension</code>类完全一样，你也可以用它来注册类和函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a namespace</span></span><br><span class="line">Php::<span class="function">Namespace <span class="title">myNamespace</span><span class="params">(<span class="string">"myNamespace"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the myFunction function to the namespace</span></span><br><span class="line">myNamespace.add(<span class="string">"myFunction"</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @todo add more functions and classes to the namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a nested namespace</span></span><br><span class="line">Php::<span class="function">Namespace <span class="title">nestedNamespace</span><span class="params">(<span class="string">"nestedNamespace"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @todo add functions and classes to the nested namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add the nested namespace to the first namespace</span></span><br><span class="line">myNamespace.add(<span class="built_in">std</span>::move(nestedNamespace));</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the namespace to the extension</span></span><br><span class="line">extension.add(<span class="built_in">std</span>::move(myNamespace));</span><br></pre></td></tr></table></figure>
<p><code>Php::Namespace</code>类只是一个容器，它会自动为你添加的所有类和函数添加一个前缀。正如你在例子中看到的那样，嵌套命名空间也是可能的。</p>
<p>在这个例子中，我们使用std::move()函数将嵌套的命名空间移动到父命名空间中，并将第一个命名空间移动到扩展中。移动比添加更有效率，尽管常规的<code>extension.add(myNamespace)</code>也是有效的。</p>
<h2 id="动态加载扩展"><a href="#动态加载扩展" class="headerlink" title="动态加载扩展"></a>动态加载扩展</h2><p>从PHP转到C++的用户经常会问，如果用C++代码代替PHP代码，是否会增加系统管理的难度。我们必须在这里说实话：使用PHP比使用C++更容易。例如，要激活一个PHP脚本，你不需要root权限，你可以简单地复制脚本到Web服务器。部署原生C++扩展需要更多的工作：你需要先停止Web服务器，编译扩展，安装，然后重新启动Web服务器。</p>
<p>除此之外，当一个扩展被部署后，它将立即对所有托管在Web服务器上的网站进行激活。一个已部署的PHP脚本只改变了单个网站的行为，但一个已部署的C++扩展会影响所有网站。其实不可能只为特定的网站激活一个扩展，也不可能只为一个网站测试一个新版本的扩展，因为扩展是由所有PHP进程共享的。如果你真的想在不同的网站上使用不同的扩展，你需要多个服务器，都有自己的配置。</p>
<p>或者你可以使用动态加载。</p>
<p>PHP有一个内置的<code>dl()</code>函数，你可以用它来加载扩展。这允许你从PHP脚本中调用<code>dl(&quot;myextension.so&quot;)</code>函数来加载一个扩展，这样一个扩展只适用于一个特定的站点。出于安全考虑，这个内置的<code>dl()</code>函数有一些限制(否则会允许用户运行任意的本地代码)，但如果只有你一个人负责一个系统，或者当一个服务器不是由多个组织共享时，你可以使用PHP-CPP创建一个类似于<code>dl()</code>的函数，但没有这个限制。</p>
<h3 id="为什么dl-会受到限制？"><a href="#为什么dl-会受到限制？" class="headerlink" title="为什么dl()会受到限制？"></a>为什么dl()会受到限制？</h3><p>由于安全问题，<code>dl()</code>函数受到限制。当你使用<code>dl()</code>时，只能加载存储在系统范围扩展目录中的扩展，而不能用于加载用户放在其他位置的扩展。因此，调用 dl(“/home/user/myextension.so”)会失败，因为”/home/user “不是官方的扩展目录。为什么会有这种限制？</p>
<p>要理解这一点，首先必须认识到，在正常的PHP安装中，PHP脚本是由没有root权限的用户编辑的。在共享主机环境下，不同的用户都在同一个系统上运行自己的网站。在这样的设置中，如果一个用户可以编写一个可以访问他人数据的脚本或程序，那是绝对不行的。然而，如果使用一个不受限制的<code>dl()</code>函数，恰恰可以做到这一点。一个不受限制的 <code>dl()</code> 调用将允许 PHP 程序员编写一个本地扩展，将其存储在他们的主目录或 /tmp 目录中，并由 webserver 进程加载。然后，他们可以执行任意代码，并可能在其他人的网站内安装记录器或其他恶意代码。<strong>通过只允许从系统范围内的扩展目录中加载扩展，PHP 保证了每一个动态加载的扩展必须至少由系统管理员安装</strong>。</p>
<p>然而，当你写你自己的扩展时（无论是直接在Zend API之上，还是通过使用PHP-CPP库）你已经可以写和执行任意代码了。这里不需要安检。从你的C/C++代码中，你可以做任何你想做的事情。如果你能根据网站的要求动态加载一个扩展，那不是很酷吗？一个网站需要稳定，并加载你的扩展测试良好的1.0版本，而第二个网站更多的是实验性的，并加载2.0版本。你可能在同一台机器上运行两个版本的扩展。</p>
<h3 id="Thin-loader-extension"><a href="#Thin-loader-extension" class="headerlink" title="Thin loader extension"></a>Thin loader extension</h3><p>想象一下，你正在编写你自己的扩展 “MyExtension”，它有许多不同的类和功能，而且你计划一直为它推出新的版本。你不希望以 “大爆炸 “的方式部署新版本，而是希望慢慢地推出新版本，一次一个客户或一个网站。你会怎么做？</p>
<p>你首先要开发一个瘦加载器扩展：ExtensionLoader扩展。这个扩展只有一个函数：<code>enable_my_extension()</code>，它接收你的实际扩展的版本号，并动态地加载你的扩展的那个版本。这是一个简单的扩展（它只有一个功能），你可以在全球范围内安装，而且你可能永远不会有更新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Function to load an extension by its version number</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  It takes one argument: the version number of your extension,</span></span><br><span class="line"><span class="comment">    *  and returns a boolean to indicate whether the extension was </span></span><br><span class="line"><span class="comment">    *  correctly loaded.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  @param  params      Vector of parameters</span></span><br><span class="line"><span class="comment">    *  @return boolean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">enable_my_extension</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get version number</span></span><br><span class="line">    <span class="keyword">int</span> version = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct pathname to your extension (this is for example</span></span><br><span class="line">    <span class="comment">// /path/to/MyExtension.so.1 or /path/to/MyExtension.so.2)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> path = <span class="string">"/path/to/MyExtension.so."</span> + <span class="built_in">std</span>::to_string(version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load the extension</span></span><br><span class="line">    <span class="keyword">return</span> Php::dl(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment">    *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">        *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">        *  @return void*</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"ExtensionLoader"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the extension has one method</span></span><br><span class="line">        myExtension.add(<span class="string">"enable_my_extension"</span>, enable_my_extension, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"version"</span>, Php::Type::Numeric)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码保存了ExtensionLoader扩展的全部源代码。你可以在你的系统上安装这个扩展，把它复制到全局php扩展目录下并更新<code>php.ini</code>文件。</p>
<p>当你安装了这个thin loader扩展之后，你就可以用类和函数写满你的实际大扩展，并将这个扩展编译成*.so文件：第一个版本你编译成MyExtension.so.1，以后的版本编译成MyExtension.so.2、MyExtension.so.3等。对于每一个新的版本，你都会引入一个新的版本号，并将这些共享对象复制到/path/to目录下（与上面显示的”ExtensionLoader”扩展中的路径相同）。虽然这不是官方的PHP扩展目录，但是这些扩展可以通过enable_my_extension()函数加载。</p>
<p>你不需要将扩展程序复制到PHP扩展目录中，也不需要更新php.ini配置。要激活一个扩展，你只需要调用引入的enable_my_extension()函数。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// enable version 2 of the extension (this will load MyExtension.so.2)</span></span><br><span class="line"><span class="keyword">if</span> (!enable_my_extension(<span class="number">2</span>)) <span class="keyword">die</span>(<span class="string">"Version 2 of extension is missing"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// from now on we can use classes and functions from version 2 of the extension</span></span><br><span class="line">$object = <span class="keyword">new</span> ClassFromMyExtension();</span><br><span class="line">$object-&gt;methodFromMyExtension();</span><br><span class="line"></span><br><span class="line"><span class="comment">// you get the idea...</span></span><br></pre></td></tr></table></figure>
<p>上面我们展示的ExtensionLoader还是很安全的。不能运行任意代码，也不能打开任意*.so文件。最糟糕的事情是有人用错误的版本号打开了一个扩展。</p>
<p>但如果你真的信任你系统上的用户，你可以很容易地调整thin loader扩展来允许其他类型的参数。在最开放的情况下，你甚至可以写一个函数，让用户从字面上打开所有可能的共享对象文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Function to load every possible extension by pathname</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  It takes one argument: the filename of the PHP extension, and returns a </span></span><br><span class="line"><span class="comment">    *  boolean to indicate whether the extension was correctly loaded.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  This function goes further than the original PHP dl() fuction, because</span></span><br><span class="line"><span class="comment">    *  it does not check whether the passed in extension object is stored in the</span></span><br><span class="line"><span class="comment">    *  right directory. Literally every possible extension, also local ones </span></span><br><span class="line"><span class="comment">    *  created by end users, can be loaded.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  @param  params      Vector of parameters</span></span><br><span class="line"><span class="comment">    *  @return boolean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">dl_unrestricted</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get extension name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> pathname = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load the extension</span></span><br><span class="line">    <span class="keyword">return</span> Php::dl(pathname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment">    *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">        *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">        *  @return void*</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"load_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the extension has one method</span></span><br><span class="line">        myExtension.add(<span class="string">"dl_unrestricted"</span>, dl_unrestricted, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"pathname"</span>, Php::Type::String)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将允许PHP脚本动态加载PHP扩展，无论它们存储在系统的哪个位置。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load the C++ extension stored in the same directory as this file</span></span><br><span class="line"><span class="keyword">if</span> (!dl_unrestricted(<span class="keyword">__DIR__</span>.<span class="string">'/MyExtension.so'</span>)) <span class="keyword">die</span>(<span class="string">"Extension could not be loaded"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// from now on we can use classes and functions from the extension</span></span><br><span class="line">$object = <span class="keyword">new</span> ClassFromMyExtension();</span><br><span class="line">$object-&gt;methodFromMyExtension();</span><br></pre></td></tr></table></figure>
<p><code>dl_unrestricted()</code>函数是一个很厉害的函数，但这里要注意：如果你是共享主机平台的管理员，你绝对不要安装它!</p>
<h3 id="Persistent-extensions"><a href="#Persistent-extensions" class="headerlink" title="Persistent extensions"></a>Persistent extensions</h3><p>动态加载的扩展会在请求结束时自动卸载。如果后续的请求也动态加载相同的扩展，那么它将以一个全新的环境开始。如果你想写一个使用静态数据或静态资源的扩展（比如一个持久的数据库连接，或者一个处理任务的工作线程），这不一定是你想要的行为。你要保持数据库连接的活跃性，或者线程的运行，也是在扩展被卸载之后。</p>
<p>为了克服这个问题，<code>Php::dl()</code>函数附带了第二个布尔参数，你可以用它来指定你是想持久地加载扩展，还是只为那个特定的请求加载。</p>
<p>请注意，如果你把这个参数设置为true，唯一持久化的就是扩展中的数据。在后续的请求中，你仍然需要加载扩展来激活其中的函数和类，即使你已经在之前的请求中持续加载了扩展。但由于之前已经加载了扩展，所以其中的静态数据（如数据库连接或线程）会被保存下来。</p>
<p>我们上面演示的<code>dl_unrestricted()</code>函数可以被修改为包含这个持久参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Function to load every possible extension by pathname</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  It takes two arguments: the filename of the PHP extension, and a boolean to</span></span><br><span class="line"><span class="comment">    *  specify whether the extension data should be kept in memory. It returns a </span></span><br><span class="line"><span class="comment">    *  boolean to indicate whether the extension was correctly loaded.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  This function goes further than the original PHP dl() fuction, because</span></span><br><span class="line"><span class="comment">    *  it does not check whether the passed in extension object is stored in the</span></span><br><span class="line"><span class="comment">    *  right directory, and because it allows persistent loading of extensions. </span></span><br><span class="line"><span class="comment">    *  Literally every possible extension, also local ones created by end users, </span></span><br><span class="line"><span class="comment">    *  can be loaded.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  @param  params      Vector of parameters</span></span><br><span class="line"><span class="comment">    *  @return boolean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">dl_unrestricted</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get extension name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> pathname = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// persistent setting</span></span><br><span class="line">    <span class="keyword">bool</span> persistent = params.size() &gt; <span class="number">1</span> ? params[<span class="number">1</span>].boolValue() : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load the extension</span></span><br><span class="line">    <span class="keyword">return</span> Php::dl(pathname, persistent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment">    *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">        *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">        *  @return void*</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"load_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the extension has one method</span></span><br><span class="line">        myExtension.add(<span class="string">"dl_unrestricted"</span>, dl_unrestricted, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"pathname"</span>, Php::Type::String),</span><br><span class="line">            Php::ByVal(<span class="string">"persistent"</span>, Php::Type::Bool, <span class="literal">false</span>)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个扩展允许我们动态加载扩展，同时保留扩展内部的持久化数据。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load the C++ extension stored in the same directory as this file, the</span></span><br><span class="line"><span class="comment">// extension is persistently loaded, so it may use persistent data like</span></span><br><span class="line"><span class="comment">// database connections and so on.</span></span><br><span class="line"><span class="keyword">if</span> (!dl_unrestricted(<span class="keyword">__DIR__</span>.<span class="string">'/MyExtension.so'</span>, <span class="keyword">true</span>)) <span class="keyword">die</span>(<span class="string">"Extension could not be loaded"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// from now on we can use classes and functions from the extension</span></span><br><span class="line">$object = <span class="keyword">new</span> ClassFromMyExtension();</span><br><span class="line">$object-&gt;methodFromMyExtension();</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="php-cpp.com">php-cpp</a></li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div>不为赚钱，只为交个朋友！干杯～</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/about/wechat.jpg" alt="水行 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/about/ali.jpg" alt="水行 Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/about/qrcode_wechat.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PHP/" rel="tag"># PHP</a>
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/22/可靠的PHP：契约式设计/" rel="prev" title="可靠的PHP：契约式设计">
      <i class="fa fa-chevron-left"></i> 可靠的PHP：契约式设计
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载源码"><span class="nav-number">2.1.</span> <span class="nav-text">下载源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始构建PHP-CPP库"><span class="nav-number">2.2.</span> <span class="nav-text">开始构建PHP-CPP库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见错误"><span class="nav-number">2.3.</span> <span class="nav-text">常见错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装PHP-CPP库到系统中"><span class="nav-number">2.4.</span> <span class="nav-text">安装PHP-CPP库到系统中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP如何载入扩展"><span class="nav-number">3.</span> <span class="nav-text">PHP如何载入扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get-module启动函数"><span class="nav-number">3.1.</span> <span class="nav-text">get_module启动函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写第一个扩展"><span class="nav-number">4.</span> <span class="nav-text">编写第一个扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：Extension"><span class="nav-number">4.1.</span> <span class="nav-text">查看例子：Extension</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出和错误"><span class="nav-number">5.</span> <span class="nav-text">输出和错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册原生函数"><span class="nav-number">6.</span> <span class="nav-text">注册原生函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无返回值：FunctionVoid"><span class="nav-number">6.1.</span> <span class="nav-text">无返回值：FunctionVoid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有返回值：FunctionReturnValue"><span class="nav-number">6.2.</span> <span class="nav-text">有返回值：FunctionReturnValue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数参数"><span class="nav-number">7.</span> <span class="nav-text">函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：functionwithparameters"><span class="nav-number">7.1.</span> <span class="nav-text">查看例子：functionwithparameters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何获取未定义参数"><span class="nav-number">7.1.1.</span> <span class="nav-text">如何获取未定义参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何写一个加法运算函数"><span class="nav-number">7.1.2.</span> <span class="nav-text">如何写一个加法运算函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何传递引用"><span class="nav-number">7.1.3.</span> <span class="nav-text">如何传递引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何接收数组"><span class="nav-number">7.1.4.</span> <span class="nav-text">如何接收数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何接收对象"><span class="nav-number">7.1.5.</span> <span class="nav-text">如何接收对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Php-Type支持情况"><span class="nav-number">7.2.</span> <span class="nav-text">Php::Type支持情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">7.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用函数"><span class="nav-number">8.</span> <span class="nav-text">调用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：callphpfunction"><span class="nav-number">8.1.</span> <span class="nav-text">查看例子：callphpfunction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda（匿名）函数"><span class="nav-number">9.</span> <span class="nav-text">Lambda（匿名）函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-函数签名"><span class="nav-number">9.1.</span> <span class="nav-text">C++ 函数签名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类和对象"><span class="nav-number">10.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：cppclassinphp"><span class="nav-number">10.1.</span> <span class="nav-text">查看例子：cppclassinphp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问修饰符"><span class="nav-number">10.2.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstract-and-final"><span class="nav-number">10.3.</span> <span class="nav-text">Abstract and final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造与析构"><span class="nav-number">11.</span> <span class="nav-text">构造与析构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#私有构造函数"><span class="nav-number">11.1.</span> <span class="nav-text">私有构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#克隆对象"><span class="nav-number">11.2.</span> <span class="nav-text">克隆对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造对象"><span class="nav-number">11.3.</span> <span class="nav-text">构造对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">12.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义接口"><span class="nav-number">12.1.</span> <span class="nav-text">定义接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生和实现"><span class="nav-number">12.2.</span> <span class="nav-text">派生和实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#魔术方法"><span class="nav-number">13.</span> <span class="nav-text">魔术方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译时检测"><span class="nav-number">13.1.</span> <span class="nav-text">编译时检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">13.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#克隆和析构"><span class="nav-number">13.3.</span> <span class="nav-text">克隆和析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪属性"><span class="nav-number">13.4.</span> <span class="nav-text">伪属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#魔术方法-call-callStatic-and-invoke"><span class="nav-number">13.5.</span> <span class="nav-text">魔术方法 call(), callStatic() and __invoke()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换为字符串"><span class="nav-number">13.6.</span> <span class="nav-text">转换为字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#魔术接口"><span class="nav-number">14.</span> <span class="nav-text">魔术接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SPL的支持"><span class="nav-number">14.1.</span> <span class="nav-text">SPL的支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Countable接口"><span class="nav-number">14.2.</span> <span class="nav-text">Countable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayAccess接口"><span class="nav-number">14.3.</span> <span class="nav-text">ArrayAccess接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Traversable接口"><span class="nav-number">14.4.</span> <span class="nav-text">Traversable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable接口"><span class="nav-number">14.5.</span> <span class="nav-text">Serializable接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-number">15.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#额外的转换函数"><span class="nav-number">15.1.</span> <span class="nav-text">额外的转换函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象比较"><span class="nav-number">15.2.</span> <span class="nav-text">对象比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类成员属性"><span class="nav-number">16.</span> <span class="nav-text">类成员属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#普通成员变量"><span class="nav-number">16.1.</span> <span class="nav-text">普通成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态属性和类常量"><span class="nav-number">16.2.</span> <span class="nav-text">静态属性和类常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Smart-properties"><span class="nav-number">16.3.</span> <span class="nav-text">Smart properties</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">17.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在C-中捕获异常"><span class="nav-number">17.1.</span> <span class="nav-text">在C++中捕获异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">18.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zval’s"><span class="nav-number">18.1.</span> <span class="nav-text">Zval’s</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标量类型"><span class="nav-number">18.2.</span> <span class="nav-text">标量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">18.3.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">18.4.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">18.5.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代"><span class="nav-number">18.6.</span> <span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">18.7.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局变量"><span class="nav-number">18.8.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小心C-全局变量"><span class="nav-number">18.9.</span> <span class="nav-text">小心C++全局变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局常量和类级常量"><span class="nav-number">19.</span> <span class="nav-text">全局常量和类级常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常量"><span class="nav-number">19.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量"><span class="nav-number">19.2.</span> <span class="nav-text">运行时常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从php-ini读取配置"><span class="nav-number">20.</span> <span class="nav-text">从php.ini读取配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展回调函数"><span class="nav-number">21.</span> <span class="nav-text">扩展回调函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预先fork的Web引擎-如Apache"><span class="nav-number">21.1.</span> <span class="nav-text">预先fork的Web引擎 (如Apache)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意多线程"><span class="nav-number">21.2.</span> <span class="nav-text">注意多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间"><span class="nav-number">22.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态加载扩展"><span class="nav-number">23.</span> <span class="nav-text">动态加载扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么dl-会受到限制？"><span class="nav-number">23.1.</span> <span class="nav-text">为什么dl()会受到限制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thin-loader-extension"><span class="nav-number">23.2.</span> <span class="nav-text">Thin loader extension</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Persistent-extensions"><span class="nav-number">23.3.</span> <span class="nav-text">Persistent extensions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">24.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="水行"
      src="/images/about/avatar.jpg">
  <p class="site-author-name" itemprop="name">水行</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://shuixn.gitbook.io" title="Notebook → https://shuixn.gitbook.io" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>Notebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/shuixn" title="GitHub → https://github.com/shuixn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://cyanming2016@gmail.com" title="E-Mail → https://cyanming2016@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/cpainter" title="Csdn → https://blog.csdn.net/cpainter" rel="noopener" target="_blank"><i class="fa fa-tags fa-fw"></i>Csdn</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">水行</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
