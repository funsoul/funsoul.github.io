<!DOCTYPE html>
<html lang="chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"funsoul.org","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">
<meta name="keywords" content="PHP,C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="使用C++扩展PHP">
<meta property="og:url" content="http://funsoul.org/2020/06/15/使用cplusplus扩展PHP/index.html">
<meta property="og:site_name" content="Funsoul&#39;s Blog">
<meta property="og:description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">
<meta property="og:locale" content="chinese">
<meta property="og:updated_time" content="2020-06-16T10:09:52.454Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用C++扩展PHP">
<meta name="twitter:description" content="概述PHP-CPP是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的文档。">

<link rel="canonical" href="http://funsoul.org/2020/06/15/使用cplusplus扩展PHP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'chinese'
  };
</script>

  <title>使用C++扩展PHP | Funsoul's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-118289850-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-118289850-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Funsoul's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">开发散记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="chinese">
    <link itemprop="mainEntityOfPage" href="http://funsoul.org/2020/06/15/使用cplusplus扩展PHP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/about/avatar.jpg">
      <meta itemprop="name" content="funsoul">
      <meta itemprop="description" content="以终为始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Funsoul's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          使用C++扩展PHP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-15T00:00:00+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-16 18:09:52" itemprop="dateModified" datetime="2020-06-16T18:09:52+08:00">2020-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP" target="_blank" rel="noopener">PHP-CPP</a>是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的<a href="http://www.php-cpp.com/documentation/introduction" target="_blank" rel="noopener">文档</a>。</p>
<a id="more"></a>
<p>注意：仅适用于PHP7。这个库已经更新为适用于 PHP 7.0 及以上版本。如果你想为旧版本的 PHP 创建扩展，请使用 <a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP-LEGACY" target="_blank" rel="noopener">PHP-CPP-LEGACY</a> 库。PHP-CPP 和 PHP-CPP-LEGACY 库有（几乎）相同的 API，所以你可以很容易地将 PHP 5.*的扩展移植到 PHP 7，反之亦然。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>注意：目前，PHP-CPP仅适用于Linux或OSX系统</li>
<li>本文实验环境为OSX</li>
</ol>
<h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v2.1.0 https://github.com/CopernicaMarketingSoftware/PHP-CPP.git</span><br></pre></td></tr></table></figure>
<p>打开<code>Makefile</code>文件（Makefile是一个保存编译器设置和指令的文件），大多数情况下，该文件中的默认配置已经足够好，但是你或许需要针对自己的环境做一些轻微的改动，比如改变安装目录或者选择自己的编译器。</p>
<h3 id="开始构建PHP-CPP库"><a href="#开始构建PHP-CPP库" class="headerlink" title="开始构建PHP-CPP库"></a>开始构建PHP-CPP库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ol>
<li>如果你使用OSX来编译构建，可能会遇到<code>链接</code>和<code>unresolved symbol</code>错误，如果你正面临此问题，那么需要对<code>Makefile</code>文件做一些改动，在这个 Makefile的某个地方有一个选项<code>LINKER_FLAGS</code>。修改为<code>-shared -undefined dynamic_lookup</code>。</li>
<li><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP/issues/368" target="_blank" rel="noopener">ld: unknown option: -soname clang: error: linker command failed with exit code 1</a></li>
</ol>
<h3 id="安装PHP-CPP库到系统中"><a href="#安装PHP-CPP库到系统中" class="headerlink" title="安装PHP-CPP库到系统中"></a>安装PHP-CPP库到系统中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="PHP如何载入扩展"><a href="#PHP如何载入扩展" class="headerlink" title="PHP如何载入扩展"></a>PHP如何载入扩展</h2><p>你可能知道在类unix的系统中，本地的PHP扩展名被编译成<code>.so</code>文件，在Windows环境中，编译成<code>.dll</code>文件，而全局的<code>php.ini</code>文件保存了系统中所有可用的扩展的列表，这意味着如果你正在创建自己的扩展，你也要创建这样的<code>.so</code>或<code>.dll</code>文件，并且你必须更新PHP配置文件，以便你自己的扩展被PHP加载。</p>
<h3 id="get-module启动函数"><a href="#get-module启动函数" class="headerlink" title="get_module启动函数"></a>get_module启动函数</h3><p>在解释如何创建自己的扩展之前，我们先解释一下 PHP 如何加载一个扩展。当 PHP 启动时，它从配置目录中加载 <code>*.ini</code> 配置文件，对于这些配置文件中的每一行 <code>extension=name.so</code>，它都会打开相应的库，并调用其中的<code>get_module()</code>函数。因此，每个扩展库（你的扩展也是）都必须定义并实现这个<code>get_module()</code>函数。这个函数在库加载后就被 PHP 调用（因此在处理 pageviews 之前就被调用了），它应该返回一个指向一个结构的内存地址，这个结构保存了所有扩展库提供的函数、类、变量和常量的信息。</p>
<p><code>get_module()</code>返回的结构是在Zend引擎的头文件中定义的，但它是一个相当复杂的结构，而且没有很好的文档。幸运的是，PHP-CPP库让你的生活变得更简单，并提供了一个扩展类，可以用来代替。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  tell the compiler that the get_module is a pure C function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Function that is called by PHP right after the PHP process</span></span><br><span class="line"><span class="comment">     *  has started, and that returns an address of an internal PHP</span></span><br><span class="line"><span class="comment">     *  strucure with all the details and features of your extension</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @return void*   a pointer to an address that is understood by PHP</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// static(!) Php::Extension object that should stay in memory</span></span><br><span class="line">        <span class="comment">// for the entire duration of the process (that's why it's static)</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @todo    add your own functions, classes, namespaces to the extension</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你看到了<code>get_module()</code>函数的一个非常直接的实现。每个使用 PHP-CPP 库的 PHP 扩展都或多或少地实现了这个函数，它是每个扩展的起点。有一些元素需要特别注意，首先，你看到的唯一的头文件是 phpcpp.h 头文件。如果你使用PHP-CPP库来构建你自己的扩展，你不需要包含Zend引擎的那些复杂的、非结构化的、大部分没有文档的头文件——你需要的只是PHP-CPP库的这个单一的phpcpp.h头文件。如果你坚持的话，你当然也可以包含核心 PHP 引擎的头文件——但你不必这样做。PHP-CPP 负责处理 PHP 引擎的内部，并提供给你一个简单易用的 API。</p>
<p>接下来你会注意到，我们将<code>get_module()</code>函数放在了一个 <code>extern &quot;C&quot;</code>的代码块中。正如库的名字所透露的那样，PHP-CPP 是一个 C++ 库。然而，PHP 希望你的库，尤其是 <code>get_module()</code> 函数是用 C 而不是 C++ 实现的。这就是为什么我们把 <code>get_module()</code> 函数包装在一个 <code>extern &quot;C&quot;</code> 块中。这将指示 C++ 编译器 <code>get_module()</code> 是一个常规的 C 函数，并且它不应该对它进行任何 C++ 名称的篡改。</p>
<p>PHP-CPP 库定义了一个 <code>PHPCPP_EXPORT</code> 宏，它应该放在 <code>get_module()</code> 函数的前面。这个宏确保<code>get_module()</code>函数是公开导出的，因此可以被PHP调用。这个宏根据编译器和操作系统的不同有不同的实现。</p>
<p>顺便说一下，这也是 PHP-CPP 提供的唯一一个宏。PHP-CPP打算成为一个普通的C++库，不使用魔术或预处理器的技巧。你所看到的就是你所得到的。如果某些东西看起来像函数，你可以肯定它实际上就是一个函数，而当某些东西看起来像一个变量，你可以肯定它也是一个变量。</p>
<p>我们继续往下看。在<code>get_module()</code>函数里面，<code>Php::Extension</code>对象被实例化，并被返回。至关重要的是，你必须为这个<code>Php::Extension</code>类创建一个静态实例，因为这个对象必须在PHP进程的整个生命周期内存在，而不仅仅是在调用<code>get_module()</code>的期间。构造函数有两个参数：扩展名和版本号。</p>
<p><code>get_module()</code> 函数的最后一步是返回扩展对象。这看起来很奇怪，因为get_module()函数应该返回一个指向void的指针，而不是一个完整的Php::Extension对象。为什么编译器没有报告这个问题呢？那是因为<code>Php::Extension</code>类有一个<code>cast-to-void-pointer-operator</code>。因此，虽然看起来你返回的是完整的扩展对象，但实际上你只是返回了一个指向一个数据结构的内存地址，这个数据结构被 PHP 核心引擎所理解，并且保存了你的扩展的所有细节。</p>
<p>请注意，上面的例子还没有导出任何<code>本地函数</code>或<code>本地类</code>到PHP中——它只是创建了扩展。</p>
<h2 id="编写第一个扩展"><a href="#编写第一个扩展" class="headerlink" title="编写第一个扩展"></a>编写第一个扩展</h2><p>当你创建你自己的 PHP-CPP 扩展时，你也必须编译和部署它。一个普通的PHP脚本只需要复制到web服务器上就可以部署，但是部署一个扩展需要花费更多的精力：你需要一个<code>Makefile</code>，一个扩展专用的<code>php.ini</code>文件，当然还有实现扩展的<code>*.cpp</code>文件。</p>
<p>为了帮助你完成这些步骤，我们创建了一个几乎是空的扩展，包含了所有需要的文件。它包含了一个示例<code>Makefile</code>，一个示例配置文件，以及第一个<code>main.cpp</code>文件，其中的<code>get_module()</code>调用已经被实现。这为你开发扩展提供了一个良好的开端。</p>
<p>该扩展代码在PHP-CPP源码的<code>Example</code>目录下，本文后面的所有扩展源码都在这里可以找到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">├── CallPhpFunctions</span><br><span class="line">│   ├── 30-callphpfunction.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── callphpfunction.cpp</span><br><span class="line">│   └── callphpfunction.php</span><br><span class="line">├── ConstStaticProp</span><br><span class="line">│   ├── cpp</span><br><span class="line">│   ├── readme</span><br><span class="line">│   └── test.php</span><br><span class="line">├── CppClassesInPhp</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── check_map.php</span><br><span class="line">│   ├── cppclassinphp.cpp</span><br><span class="line">│   ├── cppclassinphp.ini</span><br><span class="line">│   ├── cppclassinphp.php</span><br><span class="line">│   └── includeMyCustomClass.h</span><br><span class="line">├── DlUnrestricted</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── dlunrestricted.cpp</span><br><span class="line">│   ├── dlunrestricted.ini</span><br><span class="line">│   └── dlunrestricted.php</span><br><span class="line">├── EmptyExtension</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   └── yourextension.ini</span><br><span class="line">├── Exceptions</span><br><span class="line">│   ├── ExceptionCatch</span><br><span class="line">│   └── ExceptionThrow</span><br><span class="line">├── Extension</span><br><span class="line">│   ├── 30-phpcpp.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── extension.cpp</span><br><span class="line">│   ├── extension.o</span><br><span class="line">│   ├── extension.php</span><br><span class="line">│   └── extension.so</span><br><span class="line">├── FunctionNoParameters</span><br><span class="line">│   ├── 30-functionnoparameters.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionnoparameters.cpp</span><br><span class="line">│   └── functionnoparameters.php</span><br><span class="line">├── FunctionReturnValue</span><br><span class="line">│   ├── 30-functionreturnvalue.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionreturnvalue.cpp</span><br><span class="line">│   └── functionreturnvalue.php</span><br><span class="line">├── FunctionVoid</span><br><span class="line">│   ├── 30-functionvoid.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionvoid.cpp</span><br><span class="line">│   ├── functionvoid.o</span><br><span class="line">│   ├── functionvoid.php</span><br><span class="line">│   └── functionvoid.so</span><br><span class="line">├── FunctionWithParameters</span><br><span class="line">│   ├── 30-functionwithparameters.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── functionwithparameters.cpp</span><br><span class="line">│   └── functionwithparameters.php</span><br><span class="line">├── Globals</span><br><span class="line">│   ├── 30-globals.ini</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── globals.cpp</span><br><span class="line">│   └── globals.php</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── ReturnObject</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── child.h</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   ├── master.h</span><br><span class="line">│   ├── returnobject.ini</span><br><span class="line">│   └── test.php</span><br><span class="line">└── simple</span><br><span class="line">    ├── 30-phpcpp.ini</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── simple.cpp</span><br><span class="line">    └── simple.php</span><br></pre></td></tr></table></figure>
<h3 id="查看例子：Extension"><a href="#查看例子：Extension" class="headerlink" title="查看例子：Extension"></a>查看例子：Extension</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── 30-phpcpp.ini   <span class="comment"># 扩展声明文件</span></span><br><span class="line">├── Makefile        <span class="comment"># 构建文件</span></span><br><span class="line">├── extension.cpp   <span class="comment"># 扩展源码文件</span></span><br><span class="line">└── extension.php   <span class="comment"># 测试文件</span></span><br></pre></td></tr></table></figure>
<p>修改<code>Makefile</code>文件中下面两行内容。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY_DIR		= <span class="variable">$(<span class="built_in">shell</span> php-config --extension-<span class="built_in">dir</span>)</span></span><br><span class="line">PHP_CONFIG_DIR	= /usr/local/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行用于获取扩展的目录</li>
<li>第二行为你的PHP配置目录，用于存放你的扩展声明<code>extension=name.so</code></li>
</ul>
<p>通过以下步骤安装扩展</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;make</span><br><span class="line">g++ -Wall -c -I. -O2 -std=c++11 -fpic -o extension.o extension.cpp</span><br><span class="line">g++ -Wall -shared -O2  -o extension.so extension.o -lphpcpp</span><br><span class="line">&gt;&gt;sudo make install</span><br><span class="line">cp -f extension.so /usr/<span class="built_in">local</span>/Cellar/php@7.1/7.1.30/pecl/20160303</span><br><span class="line">cp -f 30-phpcpp.ini     /usr/<span class="built_in">local</span>/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>
<p>测试扩展</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;php -m | grep extension</span><br><span class="line">my_simple_extension</span><br><span class="line">&gt;&gt;php extension.php</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [67] =&gt; my_simple_extension</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="输出和错误"><a href="#输出和错误" class="headerlink" title="输出和错误"></a>输出和错误</h2><p>你可以使用常规的C++流来进行IO，使用常规的<code>&lt;&lt;</code>操作符和特殊的函数，如<code>std::endl</code>。但是使用<code>std::cout</code>和<code>std::cerr</code>流并不是一个好主意。</p>
<p>当 PHP 作为 webserver 模块运行时，stdout 被重定向到 webserver 进程最初启动的终端。在生产服务器上，这样的终端是不活动的，所以任何发送到stdout的输出都会丢失。因此，在webserver模块中运行的扩展中使用<code>std::cout</code>是不行的。但是即使 PHP 以 <code>CLI</code> 脚本的形式运行（并且 <code>std::cout</code> 也能工作），也不应该直接向 <code>stdout</code> 写入。写入<code>stdout</code>会绕过所有PHP用户空间脚本可能设置的输出处理程序。</p>
<p>PHP-CPP 库提供了一个 <code>Php::out</code> 流用来替代标准输出。这个<code>Php::out</code>变量是众所周知的<code>std::ostream</code>类的一个实例，并且尊重PHP中所有的输出缓冲设置。它的作用与PHP脚本中的echo()函数基本相同。</p>
<p><code>Php::out</code>是一个普通的 <code>std::ostream</code> 对象。其结果是它使用了一个需要刷新的内部缓冲区。当你在输出中添加<code>std::endl</code>或明确添加<code>std::flush</code>时，刷新会自动发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function that shows how to generate output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等同于php中的echo()</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带换行符，刷新输出缓冲</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接调用flush</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"example output"</span>;</span><br><span class="line">    Php::out.flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以直接使用echo</span></span><br><span class="line">    Php::echo(<span class="string">"Example output\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你想触发一个PHP错误（相当于PHP trigger_error()的C++函数），你可以使用<code>Php::error</code>、<code>Php::notice</code>、<code>Php::warning</code>和<code>Php::deprecated</code>流中的一个。这些也是<code>std::ostream</code>类的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Example function that shows how to generate output</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出一个 PHP notice</span></span><br><span class="line">    Php::notice &lt;&lt; <span class="string">"this is a notice"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出一个 PHP warning</span></span><br><span class="line">    Php::warning &lt;&lt; <span class="string">"this is a warning"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知用户，该函数已经不推荐使用</span></span><br><span class="line">    Php::deprecated &lt;&lt; <span class="string">"this method is deprecated"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出一个 PHP fatal error</span></span><br><span class="line">    Php::error &lt;&lt; <span class="string">"fatal error"</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当输出 fatal error 后，这一行不会执行</span></span><br><span class="line">    Php::out &lt;&lt; <span class="string">"regular output"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，你可以看到我们使用了 <code>std::flush</code> 而不是 <code>std::endl</code>。原因是<code>std::endl</code>内部做了两件事：它附加了一个换行符，以及它刷新了缓冲区。对于错误、通知和警告，我们不需要换行，但我们仍然需要刷新缓冲区来实际生成输出。</p>
<p><code>Php::error</code>流有一个非常奇特的地方：当你刷新它时，PHP脚本以一个致命的错误结束，而你的C++代码立即退出！！在引擎下面，PHP引擎做了一个<code>longjump</code>，到了Zend引擎深处的一个地方。在这个例子中，<code>Php::out &lt;&lt; &quot;regular output&quot;;</code> 语句从未被执行。</p>
<p>这一切都很不寻常，而且（根据我们的说法）与软件工程的一般规则相冲突。一个输出生成函数的行为不应该像抛出一个异常。看起来像正常代码的代码，也应该表现得像正常代码一样，而不应该做意想不到的事情，比如跳出当前的调用栈。因此，我们建议不要使用<code>Php::error</code>，或者在使用它时要格外小心。</p>
<h2 id="注册原生函数"><a href="#注册原生函数" class="headerlink" title="注册原生函数"></a>注册原生函数</h2><h3 id="无返回值：FunctionVoid"><a href="#无返回值：FunctionVoid" class="headerlink" title="无返回值：FunctionVoid"></a>无返回值：FunctionVoid</h3><p>在<code>get_module</code>中声明扩展信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create extension</span></span><br><span class="line"><span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_function_void"</span>,<span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;my_function_void&gt;(<span class="string">"my_void_function"</span>);</span><br></pre></td></tr></table></figure>
<p>编写一个直接打印字符串的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_function_void</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"In my_function_void()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有返回值：FunctionReturnValue"><a href="#有返回值：FunctionReturnValue" class="headerlink" title="有返回值：FunctionReturnValue"></a>有返回值：FunctionReturnValue</h3><p>在<code>get_module</code>中声明扩展信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create extension</span></span><br><span class="line"><span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_function_return_value"</span>,<span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;my_return_value_function&gt;(<span class="string">"my_return_value_function"</span>);</span><br></pre></td></tr></table></figure>
<p>通过<code>Php::Value</code>来标示返回值类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  my_return_value_function()</span></span><br><span class="line"><span class="comment"> *  @return Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">my_return_value_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::Value</code>是存储在Zend引擎中的值的基类。value类的一个实例代表了在PHP环境用户空间中存在的一个变量，例如作为全局变量、函数中的局部变量、对象或数组的成员。可以是标量类型也可以是更复杂的数组或对象类型。</p>
<p>在内核中，Zend引擎使用<code>zval</code>对象来实现。这些<code>zval</code>对象持有引用计数和引用配置。PHP-CPP的<code>Value</code>类负责处理这些工作，所以你需要做的就是使用这个类的对象。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="查看例子：functionwithparameters"><a href="#查看例子：functionwithparameters" class="headerlink" title="查看例子：functionwithparameters"></a>查看例子：functionwithparameters</h3><h4 id="如何获取未定义参数"><a href="#如何获取未定义参数" class="headerlink" title="如何获取未定义参数"></a>如何获取未定义参数</h4><p>添加一个获取未定义参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with undefined parameters, to extension</span></span><br><span class="line">extension.add&lt;my_with_undefined_parameters_function&gt;(<span class="string">"my_with_undefined_parameters_function"</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过<code>Php::Parameters</code>来获取函数参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_with_undefined_parameters_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; params[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子，尽管在定义函数时没有定义参数，但是也可以通过<code>Php::Parameters</code>来获取，非常神奇。</p>
<h4 id="如何写一个加法运算函数"><a href="#如何写一个加法运算函数" class="headerlink" title="如何写一个加法运算函数"></a>如何写一个加法运算函数</h4><p>添加一个有参数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined numeric parameters, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_parameters_function&gt;(<span class="string">"my_with_defined_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"x"</span>, Php::Type::Numeric),</span><br><span class="line">    Php::ByVal(<span class="string">"y"</span>, Php::Type::Numeric)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>编写函数定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  my_with_defined_parameters_function()</span></span><br><span class="line"><span class="comment"> *  @param  Php::Parameters     the given parameters</span></span><br><span class="line"><span class="comment"> *  @return Php::Value          Param[0] and Param[1] added</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">my_with_defined_parameters_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parameter "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; params[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>] + params[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的含义是，接收两个整型数字，并返回求和结果。</p>
<h4 id="如何传递引用"><a href="#如何传递引用" class="headerlink" title="如何传递引用"></a>如何传递引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined parameter by reference, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_parameters_reference_function&gt;(<span class="string">"my_with_defined_parameters_reference_function"</span>, &#123;</span><br><span class="line">    Php::ByRef(<span class="string">"string"</span>, Php::Type::String)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>修改传递进来的参数值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  This functions receives a reference to a variable. When the variable is altered,</span></span><br><span class="line"><span class="comment"> *  so is the value in the php script.</span></span><br><span class="line"><span class="comment"> *  my_with_defined_parameters_reference_function()</span></span><br><span class="line"><span class="comment"> *  @param  Php::Parameters     the given parameters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_with_defined_parameters_reference_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    params[<span class="number">0</span>] = <span class="string">"I changed!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何接收数组"><a href="#如何接收数组" class="headerlink" title="如何接收数组"></a>如何接收数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined array parameter, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_array_parameters_function&gt;(<span class="string">"my_with_defined_array_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"array"</span>, Php::Type::Array)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="如何接收对象"><a href="#如何接收对象" class="headerlink" title="如何接收对象"></a>如何接收对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function, with defined object parameter, to extension</span></span><br><span class="line">extension.add&lt;my_with_defined_object_parameters_function&gt;(<span class="string">"my_with_defined_object_parameters_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"myClassObjVar"</span>, <span class="string">"MyPhpClass"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Php-Type支持情况"><a href="#Php-Type支持情况" class="headerlink" title="Php::Type支持情况"></a>Php::Type支持情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Supported types for variables</span></span><br><span class="line"><span class="comment"> *  The values are the same as the ones used internally in Zend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> &#123;</span><br><span class="line">    Undefined       =   <span class="number">0</span>,  <span class="comment">// Variable is not set</span></span><br><span class="line">    Null            =   <span class="number">1</span>,  <span class="comment">// Null will allow any type</span></span><br><span class="line">    False           =   <span class="number">2</span>,  <span class="comment">// Boolean false</span></span><br><span class="line">    True            =   <span class="number">3</span>,  <span class="comment">// Boolean true</span></span><br><span class="line">    Numeric         =   <span class="number">4</span>,  <span class="comment">// Integer type</span></span><br><span class="line">    Float           =   <span class="number">5</span>,  <span class="comment">// Floating point type</span></span><br><span class="line">    String          =   <span class="number">6</span>,  <span class="comment">// A string obviously</span></span><br><span class="line">    Array           =   <span class="number">7</span>,  <span class="comment">// An array of things</span></span><br><span class="line">    Object          =   <span class="number">8</span>,  <span class="comment">// An object</span></span><br><span class="line">    Resource        =   <span class="number">9</span>,  <span class="comment">// A resource</span></span><br><span class="line">    Reference       =  <span class="number">10</span>,  <span class="comment">// Reference to another value (can be any type!)</span></span><br><span class="line">    Constant        =  <span class="number">11</span>,  <span class="comment">// A constant value</span></span><br><span class="line">    ConstantAST     =  <span class="number">12</span>,  <span class="comment">// I think an Abstract Syntax tree, not quite sure</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// "fake types", not quite sure what that means</span></span><br><span class="line">    Bool            = <span class="number">13</span>,   <span class="comment">// You will never get this back as a type</span></span><br><span class="line">    Callable        = <span class="number">14</span>,   <span class="comment">// I don't know why this is a "fake" type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>使用<code>Php::ByVal</code>定义接收参数（值传递）</li>
<li>使用<code>Php::ByRef</code>定义接收引用</li>
<li><code>Php::Parameters</code>是一个数组，用来获取参数</li>
</ol>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>首先让我们弄清楚一件事。 运行编译后的机器码比运行PHP代码快得多。 因此，一旦最终调用了C++函数或C++方法，通常就将参数转换为本地变量，然后开始运行自己的快速算法。从那时起，您就不想调用其他PHP函数。</p>
<p>但是，如果您要调用PHP函数（无论是Zend内置的函数，在扩展中定义的函数，还是来自PHP用户空间的函数），也是可以做到的。</p>
<h3 id="查看例子：callphpfunction"><a href="#查看例子：callphpfunction" class="headerlink" title="查看例子：callphpfunction"></a>查看例子：callphpfunction</h3><p>添加一个含有两个参数的函数，第一个参数是回调函数，第二个参数是数字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add function to extension</span></span><br><span class="line">extension.add&lt;call_php_function&gt;(<span class="string">"call_php_function"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"addFunc"</span>, Php::Type::Callable),</span><br><span class="line">    Php::ByVal(<span class="string">"x"</span>, Php::Type::Numeric)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>函数实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  call_php_function()</span></span><br><span class="line"><span class="comment"> *  Calls a function in PHP space.</span></span><br><span class="line"><span class="comment"> *  @param      &amp;params</span></span><br><span class="line"><span class="comment"> *  @return     Php::Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">call_php_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the parameter is callable</span></span><br><span class="line">    <span class="keyword">if</span> (!params[<span class="number">0</span>].isCallable()) <span class="keyword">throw</span> Php::Exception(<span class="string">"Not a callable type."</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// perform the callback</span></span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>](params[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda（匿名）函数"><a href="#Lambda（匿名）函数" class="headerlink" title="Lambda（匿名）函数"></a>Lambda（匿名）函数</h2><p>C++和PHP都支持lambda函数或匿名函数（在C++世界里，”lambda “这个词用得最多，PHPer讲的是 “匿名函数”）。使用 PHP-CPP 可以将这些函数从一种语言传递到另一种语言。可以从C++代码中调用一个匿名的PHP函数，也可以从PHP脚本中调用一个C++ lambda函数。</p>
<p>让我们从一个非常简单的PHP例子开始。在PHP中，你可以创建匿名函数，并将它们赋值给一个变量（或者直接将它们传递给一个函数）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 使用变量$f保存匿名函数</span></span><br><span class="line">$f = <span class="function"><span class="keyword">function</span><span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the sum of the parameters</span></span><br><span class="line">    <span class="keyword">return</span> $a + $b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个变量传递给另一个函数</span></span><br><span class="line">other_function($f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接传递匿名函数</span></span><br><span class="line">other_function(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the product of the parameters</span></span><br><span class="line">    <span class="keyword">return</span> $a * $b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码对于大多数PHP程序员来说应该是很熟悉的，当然’other_function’也可以在PHP用户空间中实现，但是我们要用C++来演示如何用PHP-CPP来实现。’other_function’当然可以在PHP用户空间中实现，但是为了演示如何用PHP-CPP来实现，我们将用C++来构建它。就像你在前面的例子中看到的所有其他函数一样，这样的C++函数函数接收一个<code>Php::Parameters</code>对象作为参数，它是一个由<code>Php::Value</code>对象组成的<code>std::vector</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function gets one parameter that holds a callable anonymous</span></span><br><span class="line"><span class="comment"> *  PHP function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  params      The parameters passed to the function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_function</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the function was really called with at least one parameter</span></span><br><span class="line">    <span class="keyword">if</span> (params.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function is called from PHP user space, and it is called</span></span><br><span class="line">    <span class="comment">// with a anonymous function as its first parameter</span></span><br><span class="line">    Php::Value func = params[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the Php::Value class has implemented the operator (), which allows</span></span><br><span class="line">    <span class="comment">// us to use the object just as if it is a real function</span></span><br><span class="line">    Php::Value result = func(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @todo do something with the result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class="line"><span class="comment"> *  to have a C style function signature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  when PHP starts, and that should return the extension details</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the example function so that it can be called from PHP scripts</span></span><br><span class="line">        extension.add&lt;other_function&gt;(<span class="string">"other_function"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension details</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这么简单。但是反过来说也是可以的。想象一下，我们在PHP用户空间代码中有一个接受回调函数的函数，下面的函数是PHP array_map()函数的简单版本。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// function that iterates over an array, and calls a function on every</span></span><br><span class="line"><span class="comment">// element in that array, it returns a new array with every item</span></span><br><span class="line"><span class="comment">// replaced by the result of the callback</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_array_map</span><span class="params">($array, $callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initial result variable</span></span><br><span class="line">    $result = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop through the array</span></span><br><span class="line">    <span class="keyword">foreach</span> ($array <span class="keyword">as</span> $index =&gt; $item) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the callback on the item</span></span><br><span class="line">        $result[$index] = $callback($item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// done</span></span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>想象一下，我们想从你的C++代码中调用这个PHP函数，使用一个C++ lambda函数作为回调。这是有可能的，而且很简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Native function that is callable from PHP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the anonymous function</span></span><br><span class="line">    Php::<span class="function">Function <span class="title">multiply_by_two</span><span class="params">([](Php::Parameters &amp;params) -&gt; Php::Value &#123;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// make sure the function was really called with at least one parameter</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">if</span> (params.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// one parameter is passed to the function</span></span></span></span><br><span class="line"><span class="function"><span class="params">        Php::Value param = params[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// multiple the parameter by two</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> param * <span class="number">2</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the function now is callable</span></span><br><span class="line">    Php::Value four = multiply_by_two(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a Php::Function object is a derived Php::Value, and its value can </span></span><br><span class="line">    <span class="comment">// also be stored in a normal Php::Value object, it will then still </span></span><br><span class="line">    <span class="comment">// be a callback function then</span></span><br><span class="line">    Php::Value value = multiply_by_two;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the value object now also holds the function</span></span><br><span class="line">    Php::Value six = value(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an array</span></span><br><span class="line">    Php::Value <span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the user-space function</span></span><br><span class="line">    Php::Value result = Php::call(<span class="string">"my_array_map"</span>, <span class="built_in">array</span>, multiply_by_two);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @todo do something with the result variable (which now holds</span></span><br><span class="line">    <span class="comment">// an array with values 2, 4, 6 and 8).</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class="line"><span class="comment"> *  to have a C style function signature</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  when PHP starts, and that should return the extension details</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the example function so that it can be called from PHP scripts</span></span><br><span class="line">        extension.add&lt;run_test&gt;(<span class="string">"run_test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension details</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们将一个C++ lambda函数分配给一个<code>Php::Function</code>对象。<code>Php::Function</code>类是由<code>Php::Value</code>类派生出来的。<code>Php::Value</code>和<code>Php::Function</code>的唯一区别是<code>Php::Function</code>的构造函数接受一个函数。尽管有这个区别，这两个类是完全相同的。事实上，我们更希望能够让C++函数直接赋值给<code>Php::Value</code>对象，而跳过<code>Php::Function</code>构造函数，但这是不可能的，因为存在调用歧义。</p>
<p><code>Php::Function</code>类可以像普通的<code>Php::Value</code>对象一样使用：你可以把它赋值给其他<code>Php::Value</code>对象，也可以在调用用户空间PHP函数时把它作为参数使用。在上面的例子中，我们正是这样做的：我们用我们自己的 “乘以二 “C++函数调用用户空间的my_iterate()函数。</p>
<h3 id="C-函数签名"><a href="#C-函数签名" class="headerlink" title="C++ 函数签名"></a>C++ 函数签名</h3><p>你可以向<code>Php::Function</code>构造函数传递不同类型的C++函数，只要它们与以下两个函数签名兼容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Php::<span class="function">Value <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">Php::<span class="function">Value <span class="title">function</span><span class="params">(Php::Parameters &amp;params)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在内核，<code>Php::Function</code>类使用一个C++的<code>std::function</code>对象来存储函数，所以凡是可以存储在这样一个<code>std::function</code>对象中的东西，都可以分配给<code>Php::Function</code>类。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++和PHP都是面向对象的编程语言，你可以在其中创建类和对象。PHP-CPP 库为你提供了将这两种语言结合起来的工具，并使本地 C++ 类可以从 PHP 中访问。</p>
<p>遗憾的是（但如果你考虑一下，也是符合逻辑的），并不是每一个可以想到的C++类都可以直接导出到PHP中。这需要更多的工作（虽然不是那么多）。首先，你必须确保你的类是从<code>Php::Base</code>派生出来的，其次，当你把你的类添加到扩展对象中时，你还必须指定所有你想从PHP中访问的方法。</p>
<ol>
<li>必须公开继承自<code>Php::Base</code></li>
<li>指定访问控制</li>
</ol>
<h3 id="查看例子：cppclassinphp"><a href="#查看例子：cppclassinphp" class="headerlink" title="查看例子：cppclassinphp"></a>查看例子：cppclassinphp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we are going to define a class</span></span><br><span class="line">Php::Class&lt;MyCustomClass&gt; customClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add methods to it</span></span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class="string">"myMethod"</span>, Php::Final, &#123;&#125;);</span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class="string">"myMethod2"</span>);</span><br><span class="line">customClass.property(<span class="string">"property1"</span>, <span class="string">"prop1"</span>);</span><br><span class="line">customClass.property(<span class="string">"property2"</span>, <span class="string">"prop2"</span>, Php::Protected);</span><br><span class="line"></span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class="string">"loopArray"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"arr"</span>, Php::Type::Array)</span><br><span class="line">&#125;);</span><br><span class="line">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class="string">"loopObject"</span>, &#123;</span><br><span class="line">    Php::ByVal(<span class="string">"obj"</span>, Php::Type::Object)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在扩展对象中，</p>
<ol>
<li>通过<code>Php::Class</code>定义类;</li>
<li>使用<code>method</code>方法来指定需要php代码访问的方法，和普通函数一样，也可以定义参数;</li>
<li>使用<code>property</code>来指定类成员，并设置访问权限</li>
</ol>
<p>静态方法也支持。静态方法是指一个不能访问<code>this</code>指针的方法。因此，在C++中，这种静态方法和普通函数是一样的，普通函数也不能访问<code>this</code>指针。静态C++方法与普通C++函数的唯一区别是在编译时：编译器允许静态方法访问私有数据。然而，静态方法的签名与普通函数的签名完全相同。</p>
<p><strong>PHP-CPP允许你注册静态方法。但是由于静态方法的签名与普通函数的签名完全相同，所以你注册的方法甚至不一定是同一个类的方法。普通函数和其他类的静态方法的签名完全一样，也可以注册! 从软件架构的角度来看，最好只使用同一类的静态方法，但C++允许你做的更多。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  普通函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  因为普通函数没有this指针,</span></span><br><span class="line"><span class="comment"> *  所以它和静态方法拥有相同的签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param  params      Parameters passed to the function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">regularFunction</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// @todo add implementation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  不会暴露给php调用的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PrivateClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~PrivateClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  静态方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  静态方法没有this指针</span></span><br><span class="line"><span class="comment">     *  因此它的签名和普通函数相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters passed to the method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// @todo add implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  暴露给php使用的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PublicClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PublicClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~PublicClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     *  另一个静态方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  这个静态方法的签名和前面提到的普通函数和静态方法完全一样。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @param  params      Parameters passed to the method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// @todo add implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;PublicClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将PublicClass::staticMethod注册为一个可在PHP中调用的静态方法</span></span><br><span class="line">        myClass.method&lt;&amp;PublicClass::staticMethod&gt;(<span class="string">"static1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通函数与静态方法具有相同的签名。所以，没有什么能禁止你把普通函数也注册为静态方法。</span></span><br><span class="line">        myClass.method&lt;regularFunction&gt;(<span class="string">"static2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甚至来自完全不同类的静态方法也有相同的函数签名，因此可以注册</span></span><br><span class="line">        myClass.method&lt;&amp;PrivateClass::staticMethod&gt;(<span class="string">"static3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(myClass));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事实上，由于静态方法的签名与普通函数相同，你也可以将静态C++方法注册为普通的全局PHP函数。</span></span><br><span class="line">        myExtension.add(<span class="string">"myFunction"</span>, &amp;PrivateClass::staticMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在PHP代码中使用扩展的功能</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// this will call PublicClass::staticMethod()</span></span><br><span class="line">MyClass::static1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will call PrivateClass::staticMethod()</span></span><br><span class="line">MyClass::static2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will call regularFunction()</span></span><br><span class="line">MyClass::static3();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will also call PrivateClass::staticMethod()</span></span><br><span class="line">myFunction();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>在PHP中（在C++中也是），你可以将方法标记为<code>public</code>、<code>private</code>或<code>protected</code>。为了使你的本地类也能实现这一点，你应该在向<code>Php::Class</code>对象添加方法时传递一个额外的flags参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the increment method, and specify its parameters</span></span><br><span class="line">counter.method&lt;&amp;Counter::increment&gt;(<span class="string">"increment"</span>, Php::Protected, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the decrement, and specify its parameters</span></span><br><span class="line">counter.method&lt;&amp;Counter::decrement&gt;(<span class="string">"decrement"</span>, Php::Protected, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the value method</span></span><br><span class="line">counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>, Php::Public | Php::Final);</span><br></pre></td></tr></table></figure>
<p>默认情况下，每一个方法 (还有每一个属性，但我们稍后会处理) 都是<code>公开</code>的。如果你想把一个方法标记为受保护的或私有的，你可以传递一个额外的 <code>Php::Protected</code> 或 <code>Php::Private</code> 标志。如果你也想把你的方法标记为抽象的或最终的，那么可以用<code>Php::Abstract</code>或<code>Php::Final</code>来对flag参数进行<code>位或</code>。PHP-CPP对value()方法做了这样的处理，这样在派生类中就不可能覆盖这个方法了。</p>
<p>请记住，C++ 类中的导出方法必须始终是公共的(即使在 PHP 中标记为私有或保护)。这是有道理的，因为毕竟你的方法会被 PHP-CPP 库调用，如果你把它们变成私有的，它们就会被库所忽略。</p>
<h3 id="Abstract-and-final"><a href="#Abstract-and-final" class="headerlink" title="Abstract and final"></a>Abstract and final</h3><p>在上一节中，我们展示了如何使用<code>Php::Final</code>和<code>Php::Abstract</code>标志来创建一个final或抽象方法。如果你想让你的整个类成为抽象的或最终的，你可以通过把这个标志传递给<code>Php::Class</code>构造函数来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>, Php::Final);</span><br></pre></td></tr></table></figure>
<p>就像我们之前解释的那样，当你想注册一个抽象方法时，你应该在调用Php::Class::method()时传递一个Php::Abstract标志。然而，可能看起来很奇怪，这个方法也需要你传入一个真正的C++方法的地址。抽象方法通常没有实现，那么你需要提供一个方法的指针干什么呢？幸运的是，也有一种不同的方法来注册抽象方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register the decrement, and specify its parameters</span></span><br><span class="line">counter.method(<span class="string">"decrement"</span>, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"change"</span>, Php::Type::Numeric, <span class="literal">false</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要注册抽象方法，你可以简单地使用Counter::method()方法的另一种形式，它不接受指向C++方法的指针。</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>在 C++ 中的构造函数和析构函数与 PHP 中的 <strong>construct() 和 </strong>destruct() 方法之间有一个很小但非常重要的区别。</p>
<p>C++ 中的构造函数是在一个正在初始化的对象上调用的，但这个对象还没有处于初始化状态。你可以通过调用构造函数中的一个虚拟方法来体验这种情况。即使这个虚拟方法在派生类中被重写，这也将始终执行类本身的方法，而不是重写的实现。原因是在调用C++构造函数的过程中，对象还没有完全初始化，对象还不知道自己在类层次结构中的位置。因此对虚拟方法的调用不能传递给派生对象。</p>
<p>然而在 PHP 中，__construct() 方法有不同的行为。当它被调用时，对象已经被初始化了，因此对派生类中实现的抽象方法的调用是完全合法的。下面的 PHP 脚本是完全有效的，但是在 C++ 中不可能做类似的事情。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base class in PHP, in which the an abstract method is called</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BASE</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// call abstract method</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// abstract method to be implemented by derived classes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the derived class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DERIVED</span> <span class="keyword">extends</span> <span class="title">BASE</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// implement the abstract method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">"doSomething()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create an instance of the derived class</span></span><br><span class="line">$d = <span class="keyword">new</span> DERIVED();</span><br></pre></td></tr></table></figure>
<p>这个脚本输出的是’doSomething()’。原因是<code>__construct()</code>根本就不是一个构造函数，而是一个很普通的方法，只是恰好是第一个被调用的方法，而且是在对象被构造后自动调用的。</p>
<p>这个区别对于作为一个C++程序员的你来说是很重要的，因为你千万不要把你的C++构造函数和PHP的<code>__construct()</code>方法混淆。在C++构造函数中，对象正在被构造，而且还不是所有的数据都可用。虚拟方法不能被调用，对象也还不存在于 PHP 用户空间中。</p>
<p>在构造函数完成后，PHP引擎接管控制并创建PHP对象，然后PHP-CPP库将该PHP对象链接到你的C++对象。只有在PHP对象和C++对象都完全构造完成之后，才会调用<strong>construct()方法（就像普通方法一样）。因此，在你的类中同时拥有 C++ 构造函数和 </strong>construct() 方法是很常见的。<strong>C++ 构造函数用来初始化成员变量，而 __construct() 方法用来激活对象。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple counter class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Internal value</span></span><br><span class="line"><span class="comment">     *  @var int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  c++ destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  php "constructor"</span></span><br><span class="line"><span class="comment">     *  @param  params</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> __construct(Php::Parameters &amp;params)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// copy first parameter (if available)</span></span><br><span class="line">        <span class="keyword">if</span> (!params.empty()) _value = params[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  functions to increment and decrement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">increment</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ++_value; &#125;</span><br><span class="line">    Php::<span class="function">Value <span class="title">decrement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> --_value; &#125;</span><br><span class="line">    Php::<span class="function">Value <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function for the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible</span></span><br><span class="line">        Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::__construct&gt;(<span class="string">"__construct"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::increment&gt;(<span class="string">"increment"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::decrement&gt;(<span class="string">"decrement"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码显示 <code>__construct()</code> 被注册为一个普通的方法。我们之前使用的例子（有Counter类的例子）现在被扩展了，这样就可以通过向 “构造函数”传递一个值来给它一个计数器的初始值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$counter = <span class="keyword">new</span> Counter(<span class="number">10</span>);</span><br><span class="line">$counter-&gt;increment();</span><br><span class="line"><span class="keyword">echo</span>($counter-&gt;value().<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>__construct()</code>方法被看作是一个普通的方法，所以你也可以指定它的参数，以及该方法是公共的、私有的还是保护的。<code>__construct()</code>也可以从PHP用户空间直接调用，所以派生方法可以显式调用<code>parent::__construct()</code>。</p>
<h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><p>就像其他方法一样，<strong>construct()方法也可以被标记为私有或保护。如果你这样做，你将使你的类无法从PHP脚本中创建实例。重要的是要意识到，在这种情况下，C++ 构造函数和 C++ 解构函数仍然会被调用，因为会失败的是<code></code></strong>construct()<code></code>调用，而不是实际的对象构造。</p>
<p>是的，如果你把<code>__construct()</code>方法设为私有，并且在 PHP 脚本中执行了<code>new Counter()</code>调用，PHP-CPP 库将首先实例化你的类的一个新实例，然后报告一个错误，因为<code>__construct()</code>方法是私有的，然后立即析构对象（并调用 C++ 析构函数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a private __construct method to the class, so that objects can </span></span><br><span class="line"><span class="comment">// not be constructed from PHP scripts. Be aware that the C++ constructer </span></span><br><span class="line"><span class="comment">// does get called - it will be the call to the first __construct() </span></span><br><span class="line"><span class="comment">// function that will fail, and not the actual object construction.</span></span><br><span class="line">counter.method&lt;&amp;Counter::__construct&gt;(<span class="string">"__construct"</span>, Php::Private);</span><br></pre></td></tr></table></figure>
<h3 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h3><p>如果你的类有一个复制构造函数，它就会自动成为可克隆的类。如果你不希望你的类可以被 PHP 脚本克隆，你可以做两件事：</p>
<ol>
<li>你可以从你的类中删除复制构造函数;</li>
<li>你可以注册一个私有的 <code>__clone()</code> 方法，就像我们之前注册一个私有的 <code>__construct()</code> 方法一样。</li>
</ol>
<p>删除复制构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  Remove the copy constructor</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">*  By removing the copy constructor, the PHP clone operator will</span></span><br><span class="line"><span class="comment">*  automatically be deactivated. PHP will trigger an error if </span></span><br><span class="line"><span class="comment">*  an object is attempted to be cloned.</span></span><br><span class="line"><span class="comment">*  </span></span><br><span class="line"><span class="comment">*  @param  counter</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Counter(<span class="keyword">const</span> Counter &amp;counter) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>把克隆方法注册为私有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alternative way to make an object unclonable</span></span><br><span class="line">counter.method(<span class="string">"__clone"</span>, Php::Private);</span><br></pre></td></tr></table></figure>
<h3 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h3><p><code>Php::Value</code>类可以作为一个常规的PHP <code>$variable</code>使用，因此你也可以用它来存储对象实例。但是如何创建全新的对象呢？为此，我们有 <code>Php::Object</code> 类，它是一个简单的重写的 <code>Php::Value</code> 类，带有可供选择的构造函数，还有一些额外的检查，以防止你使用 <code>Php::Object</code> 对象来存储对象以外的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new variable holding the string "Counter"</span></span><br><span class="line">Php::<span class="function">Value <span class="title">counter0</span><span class="params">(<span class="string">"Counter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new variable holding a newly created object of type "Counter",</span></span><br><span class="line"><span class="comment">// the __construct() gets called without parameters</span></span><br><span class="line">Php::<span class="function">Object <span class="title">counter1</span><span class="params">(<span class="string">"Counter"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new variable holding a newly created object, and </span></span><br><span class="line"><span class="comment">// the __construct() is being called with value 10</span></span><br><span class="line">Php::<span class="function">Object <span class="title">counter2</span><span class="params">(<span class="string">"Counter"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new built-in DateTime object, constructed with "now"</span></span><br><span class="line">Php::<span class="function">Object <span class="title">time</span><span class="params">(<span class="string">"DateTime"</span>, <span class="string">"now"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// valid, a Php::Object is an extended Php::Value, and </span></span><br><span class="line"><span class="comment">// can thus be assigned to a base Php::Value object</span></span><br><span class="line">Php::Value copy1 = counter1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invalid statement, a Php::Object can only be used for storing objects</span></span><br><span class="line">Php::Object copy2 = counter0;</span><br></pre></td></tr></table></figure>
<p><code>Php::Object</code> 的构造函数接收一个类的名称，以及一个可选的参数列表，这些参数将被传递给 <code>__construct()</code> 函数。你可以使用内置的 PHP 类和其他扩展的名称（如 DateTime），你的扩展的类（如 Counter），甚至是 PHP 用户空间的类。</p>
<p>如果你想在不调用 <code>__construct()</code> 函数的情况下构造一个你自己的 C++ 类的实例，也可以使用 <code>Php::Object</code> 类。例如，当 <code>__construct()</code> 方法是私有的，或者当你想绕过对你自己的 <code>__construct()</code> 方法的调用时，这就很有用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actual class implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// c++ constructor</span></span><br><span class="line">    Counter(<span class="keyword">int</span> value) : _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++ destructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Counter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// php "constructor"</span></span><br><span class="line">    <span class="keyword">void</span> __construct() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// functions to increment and decrement</span></span><br><span class="line">    Php::<span class="function">Value <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to create a new timer</span></span><br><span class="line">Php::<span class="function">Value <span class="title">createTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Php::Object(<span class="string">"Counter"</span>, <span class="keyword">new</span> Counter(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows which methods are accessible,</span></span><br><span class="line">        <span class="comment">// the __construct method is private because PHP scripts are not allowed</span></span><br><span class="line">        <span class="comment">// to create Counter instances</span></span><br><span class="line">        Php::Class&lt;Counter&gt; counter(<span class="string">"Counter"</span>);</span><br><span class="line">        counter.method&lt;&amp;Counter::__construct&gt;(<span class="string">"__construct"</span>, Php::Private);</span><br><span class="line">        counter.method&lt;&amp;Counter::value&gt;(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the factory function to create a timer to the extension</span></span><br><span class="line">        myExtension.add(<span class="string">"createTimer"</span>, createTimer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们将 Counter 类的 <code>__construct()</code> 函数设为私有。这使得不可能创建这个类的实例（无论是从 PHP 用户脚本中，还是通过调用 <code>Php::Object(&quot;Counter&quot;)</code>），因为用这些方法构造对象最终会导致一个被禁止的 <code>__construct()</code> 调用。</p>
<p><code>Php::Object</code> 确实有一种替代的语法，它可以接受一个指向 C++ 类的指针（在堆上分配，使用运算符 <code>new</code>！），并将这个指针变成一个 PHP 变量，而无需调用 <code>__construct()</code> 方法。请注意，你还必须指定类名，因为 C++ 类不保存任何关于它们自己的信息（比如它们的名字），而在 PHP 中，这样的信息是处理<code>反射</code>和 <code>get_class()</code> 等函数所需要的。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>PHP和C++都是支持类继承的面向对象编程语言。有一些区别。C++支持多继承，而PHP类只能有一个基类。为了弥补没有多重继承的不足，PHP支持接口和<code>traits</code>。</p>
<p>PHP-CPP库还允许你定义PHP接口，并创建PHP类和PHP接口的层次结构。</p>
<h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><p>如果你想让你的扩展定义一个接口，这样接口就可以从 PHP 用户空间脚本中实现，你可以用类似于定义类的方式来实现。唯一不同的是，你不使用<code>Php::Class&lt;YourClass&gt;</code>，而是使用<code>Php::Interface</code>实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// description of the interface so that PHP knows which methods </span></span><br><span class="line"><span class="comment">// are defined by it</span></span><br><span class="line">Php::<span class="function">Interface <span class="title">interface</span><span class="params">(<span class="string">"MyInterface"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define an interface method</span></span><br><span class="line">interface.method(<span class="string">"myMethod"</span>, &#123; </span><br><span class="line">    Php::ByVal(<span class="string">"value"</span>, Php::Type::String, <span class="literal">true</span>) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="派生和实现"><a href="#派生和实现" class="headerlink" title="派生和实现"></a>派生和实现</h3><p>PHP-CPP 库试图使 PHP 和 C++ 的工作尽可能的透明。C++函数可以从PHP用户空间脚本中调用，C++类可以从PHP中访问。然而，归根结底PHP和C++还是不同的语言，由于C++没有PHP那样的反射功能，所以你必须显式地告诉PHP引擎该类实现了哪些基类和接口。</p>
<p><code>Php::Class&lt;YourClass&gt;</code>对象有一个方法 <code>extends()</code>和一个方法 <code>implements()</code>，可以用来指定基类和实现的接口。你需要传入一个你之前配置的类或接口。我们来看一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine </span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create static instance of the extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the interface so that PHP knows which methods </span></span><br><span class="line">        <span class="comment">// are defined by it</span></span><br><span class="line">        Php::<span class="function">Interface <span class="title">myInterface</span><span class="params">(<span class="string">"MyInterface"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// define an interface method</span></span><br><span class="line">        myInterface.method(<span class="string">"myMethod"</span>, &#123; </span><br><span class="line">            Php::ByVal(<span class="string">"value"</span>, Php::Type::String, <span class="literal">true</span>) </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// register our own class</span></span><br><span class="line">        Php::Class&lt;MyClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// from PHP user space scripts, it must look like the myClass implements</span></span><br><span class="line">        <span class="comment">// the MyInterface interface</span></span><br><span class="line">        myClass.implements(myInterface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the interface requires that the myMethod method is implemented</span></span><br><span class="line">        myClass.method&lt;&amp;MyClass::myMethod&gt;(<span class="string">"myMethod"</span>, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"value"</span>, Php::Type::String, <span class="literal">true</span>) </span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a third class</span></span><br><span class="line">        Php::Class&lt;DerivedClass&gt; derivedClass(<span class="string">"DerivedClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// in PHP scripts, it should look like DerivedClass has "MyClass" </span></span><br><span class="line">        <span class="comment">// as its base</span></span><br><span class="line">        derivedClass.extends(myClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the interface and the classes to the extension</span></span><br><span class="line">        myExtension.add(myInterface);</span><br><span class="line">        myExtension.add(myClass);</span><br><span class="line">        myExtension.add(derivedClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在 <code>get_module()</code> 函数中定义的 PHP 类的层次结构不一定要和 C++ 类的层次结构一致。你的 C++ 类 <code>DerivedClass</code> 根本不需要以 “MyClass”为基础，尽管在 PHP 脚本中它看起来像这样。为了代码的可维护性，当然最好让 PHP 的签名与 C++ 的实现多少有些相似。</p>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><h2 id="魔术接口"><a href="#魔术接口" class="headerlink" title="魔术接口"></a>魔术接口</h2><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>当我们开发 PHP-CPP 库时，我们不得不问自己一个问题，那就是我们应该遵循 PHP 惯例还是遵循 C++ 惯例来实现库中的许多功能。</p>
<p>在 PHP 脚本中，你可以使用<code>魔术方法</code>和<code>魔术接口</code>来为类添加特殊的行为。在C++类中，你也可以实现同样的功能，不过是通过使用<code>操作符重载</code>、<code>隐式构造函数</code>和<code>转换操作符</code>等技术。例如PHP的<code>__invoke()</code>方法，与C++中的<code>operator()</code>多少有些相同。我们问自己的问题是，我们是否应该自动将 PHP 的 <code>__invoke</code> 方法传递给 C++ 的 <code>operator()</code> 调用，还是在 C++ 中也使用同样的 <code>__invoke()</code> 方法名？</p>
<p>我们决定遵循PHP的惯例，在C++中也使用<code>魔术方法</code>和<code>魔术接口</code>（尽管我们必须承认，以两个下划线开头的方法并不能使代码看起来非常漂亮），但是通过使用魔术方法，对于初学C++的程序员来说，从PHP到C++的转换保持了更简单的状态。而且最重要的是，并不是所有的魔术方法和接口都能用C++的核心特性来实现（比如运算符重载），所以我们不得不使用一些魔术方法或接口。这就是为什么我们决定，既然我们必须在C++中使用一些魔术方法，那么我们也可以完全遵循PHP，在C++中也支持所有的PHP魔术方法。</p>
<p>除了PHP用户空间中的魔术方法和接口外，Zend引擎还有一些额外的功能是PHP用户空间脚本无法接触到的。这些功能只有扩展程序员才能使用。PHP-CPP库也支持这些特殊功能。这意味着，如果使用PHP-CPP来编写函数和类，可以实现编写纯PHP代码无法实现的事情。</p>
<h3 id="额外的转换函数"><a href="#额外的转换函数" class="headerlink" title="额外的转换函数"></a>额外的转换函数</h3><p>在内部，Zend引擎有特殊的转换例程来将对象转换为整数、布尔值和浮点值。由于这样或那样的原因，一个PHP脚本只能实现<code>__toString()</code>方法，而其他所有的转换操作都远离它。PHP-CPP 库解决了这一限制，并允许实现其他的转换函数。</p>
<p>PHP-CPP 库的设计目标之一是尽可能地接近 PHP。出于这个原因，转换函数被赋予了与 <code>__toString()</code> 方法相匹配的名称：<code>__toInteger()</code>, <code>__toFloat()</code> 和 <code>__toBool()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample class, with methods to cast objects to scalars</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor and C++ destructpr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyClass() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~MyClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a string</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  Note that now we use const char* as return value, and not Php::Value.</span></span><br><span class="line"><span class="comment">     *  The __toString function is detected at compile time, and it does</span></span><br><span class="line"><span class="comment">     *  not have a fixed signature. You can return any value that can be picked</span></span><br><span class="line"><span class="comment">     *  up by a Php::Value object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  @return const char *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *__toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"abcd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a integer</span></span><br><span class="line"><span class="comment">     *  @return long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> __toInteger()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1234</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a floating point number</span></span><br><span class="line"><span class="comment">     *  @return double</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">double</span> __toFloat()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">88.88</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast to a boolean</span></span><br><span class="line"><span class="comment">     *  @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> __toBool()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class="line"><span class="comment"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function that is called by the Zend engine</span></span><br><span class="line"><span class="comment">     *  to retrieve all information about the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// description of the class so that PHP knows</span></span><br><span class="line">        <span class="comment">// which methods are accessible</span></span><br><span class="line">        Php::Class&lt;MyClass&gt; myClass(<span class="string">"MyClass"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(myClass));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个对象被转换为标量类型时，或者在标量上下文中使用时，会自动调用转换方法。下面的例子说明了这一点。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize an object</span></span><br><span class="line">$object = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// cast it</span></span><br><span class="line"><span class="keyword">echo</span>((string)$object.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>((int)$object.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>((bool)$object.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>((float)$object.<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><p>如果你在PHP中用<code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>等比较运算符比较两个对象，Zend引擎会运行一个对象比较函数。PHP-CPP库会拦截这个方法，并将比较方法传递给你的类的<code>__compare</code>方法。换句话说，如果你想安装一个自定义的比较操作符，你可以通过实现<code>__compare()</code>来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A sample class, that shows how objects can be compared</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Internal value of the class</span></span><br><span class="line"><span class="comment">     *  @var    int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> _value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ constructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// start with random value</span></span><br><span class="line">        _value = rand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  C++ destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~MyClass() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Cast the object to a string</span></span><br><span class="line"><span class="comment">     *  @return std::string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::to_string(_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Compare with a different object</span></span><br><span class="line"><span class="comment">     *  @param  that</span></span><br><span class="line"><span class="comment">     *  @return int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> __compare(<span class="keyword">const</span> MyClass &amp;that) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _value - that._value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你在PHP脚本中尝试比较对象时，比较函数会被自动调用。当两个对象相同时，它应该返回0，当’this’对象较小时，返回小于0的值，当’this’对象较大时，返回大于0的值。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize a couple of objects</span></span><br><span class="line">$object1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">$object2 = <span class="keyword">new</span> MyClass();</span><br><span class="line">$object3 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare the objects</span></span><br><span class="line"><span class="keyword">if</span> ($object1 &lt; $object2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is smaller than $object2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is bigger than $object2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($object1 == $object3)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is equal to $object3\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"$object1 is not equal to $object3\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>PHP和C++都支持异常，通过PHP-CPP库，这两种语言之间的异常处理是完全透明的。在 C++ 中抛出的异常会自动传递给 PHP 脚本，而 PHP 脚本抛出的异常可以被 C++ 代码捕获，就像一个普通的 C++ 异常一样。</p>
<p>让我们从一个简单的抛出异常的C++函数开始。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple function that takes two numeric parameters,</span></span><br><span class="line"><span class="comment"> *  and that divides them. Division by zero is of course</span></span><br><span class="line"><span class="comment"> *  not permitted - it will throw an exception then</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Php::<span class="function">Value <span class="title">myDiv</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// division by zero is not permitted, throw an exception when this happens</span></span><br><span class="line">    <span class="keyword">if</span> (params[<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">throw</span> Php::Exception(<span class="string">"Division by zero"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// divide the two parameters</span></span><br><span class="line">    <span class="keyword">return</span> params[<span class="number">0</span>] / params[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line">        extension.add&lt;myDiv&gt;(<span class="string">"myDiv"</span>, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"a"</span>, Php::Type::Numeric, <span class="literal">true</span>),</span><br><span class="line">            Php::ByVal(<span class="string">"b"</span>, Php::Type::Numeric, <span class="literal">true</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你又一次看到了一个非常简单的扩展。在这个扩展中，我们创建了一个 “myDiv “函数，用来除以两个数字。但是除以零当然是不允许的，所以当试图除以零时，会产生一个异常。下面的 PHP 脚本就使用了这个功能。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">10</span>,<span class="number">2</span>).<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">8</span>,<span class="number">4</span>).<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">5</span>,<span class="number">0</span>).<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">echo</span>(myDiv(<span class="number">100</span>,<span class="number">10</span>).<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">Exception</span> $exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"exception caught\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子显示了从C++代码中抛出异常并在PHP脚本中捕获异常是多么的简单。PHP-CPP 库会在内部捕获你的 C++ 异常并将其转换为 PHP 异常，但这一切都发生在引擎盖下。对于你这个扩展程序员来说，就好像你根本没有在两种不同的语言中工作，你可以简单地抛出一个Php::Exception对象，就好像它是一个普通的PHP异常一样。</p>
<h3 id="在C-中捕获异常"><a href="#在C-中捕获异常" class="headerlink" title="在C++中捕获异常"></a>在C++中捕获异常</h3><p>反过来，如果你的扩展调用了一个PHP函数，而这个PHP函数恰好抛出了一个异常，你可以像捕获一个普通的C++异常一样捕获它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Php::<span class="function">Value <span class="title">callMe</span><span class="params">(Php::Parameters &amp;params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// prevent that exceptions bubble up</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// call the function that was supplied by the user</span></span><br><span class="line">        <span class="keyword">return</span> params[<span class="number">0</span>]();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Php::Exception &amp;exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Exception caught!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line">        extension.add&lt;callMe&gt;(<span class="string">"callMe"</span>, &#123;</span><br><span class="line">            Php::ByVal(<span class="string">"callback"</span>, Php::Type::Callable, <span class="literal">true</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码需要解释一下。正如我们之前提到的，<code>Php::Value</code> 对象可以像使用普通的 PHP <code>$variable</code> 一样使用，因此你可以在其中存储整数、字符串、对象、数组等等。但这也意味着你可以用它来存储函数（因为 PHP 变量也可以用来存储函数）！而这正是我们要做的。</p>
<p>本例扩展中的 <code>callMe()</code> 函数只接收一个参数：一个它将立即调用的回调函数，回调函数的返回值也由 <code>callMe()</code> 函数返回。如果这个回调函数以某种方式抛出一个异常，它将被<code>callMe()</code>函数捕获，并返回一个替代的字符串(“Exception caught!”)。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call "callMe" for the first time, and supply a function that returns "first call"</span></span><br><span class="line">$output = callMe(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"First call"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// show output (this will be "First call")</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="string">"$output\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call "callMe" for the second time, but throw an exception this time</span></span><br><span class="line">$output = callMe(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"Sorry...\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Second call\n"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// show output (this will be "Exception caught")</span></span><br><span class="line"><span class="keyword">echo</span>(<span class="string">"$output\n"</span>);</span><br></pre></td></tr></table></figure>
<p>这个 PHP 脚本使用了我们的扩展，并连续两次调用 callMe() 函数。首先用一个普通函数返回一个字符串，然后用一个抛出异常的函数（扩展会捕捉到这个异常）。输出结果正如你所期望的那样。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="全局常量和类级常量"><a href="#全局常量和类级常量" class="headerlink" title="全局常量和类级常量"></a>全局常量和类级常量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在 PHP 脚本中可以定义常量（包括全局常量和类级常量）。这也可以通过 PHP-CPP 来实现。如果你想把常量暴露在用户空间的PHP代码中，你可以通过在<code>get_module()</code>调用中添加常量到<code>Php::Extension</code>对象中来实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add integer constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_1"</span>, <span class="number">1</span>));</span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_2"</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// floating point constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_3"</span>, <span class="number">3.1415927</span>));</span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_4"</span>, <span class="number">4.932843</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// string constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_5"</span>, <span class="string">"This is a constant value"</span>));</span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_6"</span>, <span class="string">"Another constant value"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// null constants</span></span><br><span class="line">myExtension.add(Php::Constant(<span class="string">"MY_CONSTANT_7"</span>, <span class="literal">nullptr</span>));</span><br></pre></td></tr></table></figure>
<p>在php中使用常量</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_1.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_2.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_3.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_4.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_5.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_6.<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">echo</span>(MY_CONSTANT_7.<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>PHP也支持类级常量的概念。在内部，在Zend引擎中，类级常量被实现为常规的类成员，但是常量属性没有 “public “或 “private “标志，而是用 “constant “标志来标记。PHP-CPP也暴露了这一点。你可以用<code>Php::Const</code>标志来注册类属性。</p>
<p>除此之外，一个<code>Php::Class</code>实例也有一个 “constant”方法，你可以将<code>Php::Constant</code>的实例添加到类中。从语义上看，这三种创建类级常量的方法都是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The C++ class that we're going to expose</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (For this example we use a completely empty class, as only examples</span></span><br><span class="line"><span class="comment"> *  are given on how to use constants)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dummy</span> :</span> <span class="keyword">public</span> Php::Base</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C context so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by C programs (which the Zend engine is)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Startup function for the extension</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">myExtension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a class objects</span></span><br><span class="line">        Php::Class&lt;Dummy&gt; dummy(<span class="string">"Dummy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// there are many different ways to add constants, but semantically,</span></span><br><span class="line">        <span class="comment">// they're all the same</span></span><br><span class="line">        dummy.property(<span class="string">"MY_CONSTANT_1"</span>, <span class="number">1</span>, Php::Const);</span><br><span class="line">        dummy.property(<span class="string">"MY_CONSTANT_2"</span>, <span class="string">"abcd"</span>, Php::Const);</span><br><span class="line">        dummy.constant(<span class="string">"MY_CONSTANT_3"</span>, <span class="string">"xyz"</span>);</span><br><span class="line">        dummy.constant(<span class="string">"MY_CONSTANT_4"</span>, <span class="number">3.1415</span>);</span><br><span class="line">        dummy.add(Php::Constant(<span class="string">"MY_CONSTANT_5"</span>, <span class="string">"constant string"</span>));</span><br><span class="line">        dummy.add(Php::Constant(<span class="string">"MY_CONSTANT_5"</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add the class to the extension</span></span><br><span class="line">        myExtension.add(<span class="built_in">std</span>::move(dummy));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the extension</span></span><br><span class="line">        <span class="keyword">return</span> myExtension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时常量"><a href="#运行时常量" class="headerlink" title="运行时常量"></a>运行时常量</h3><p>如果你想在运行时从你的C++代码中找出一个用户空间常量的值，或者当你想找出一个常量是否被定义时，你可以简单地使用<code>Php::constant()</code>或<code>Php::defined()</code>函数。要在运行时定义常量，请使用<code>Php::define()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Function that can be called from a PHP script</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check if a certain user space constant is defined</span></span><br><span class="line">    <span class="keyword">if</span> (Php::defined(<span class="string">"USER_SPACE_CONSTANT"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// retrieve the value of a constant</span></span><br><span class="line">        Php::Value constant = Php::constant(<span class="string">"ANOTHER_CONSTANT"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// define other constants at runtime</span></span><br><span class="line">        Php::define(<span class="string">"DYNAMIC_CONSTANT"</span>, <span class="number">12345</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从php-ini读取配置"><a href="#从php-ini读取配置" class="headerlink" title="从php.ini读取配置"></a>从php.ini读取配置</h2><p>从php.ini文件中读取设置就像从普通PHP脚本中获取设置一样简单。在PHP脚本中，你可以使用内置的<code>ini_get()</code>函数从php.ini文件中读取设置，而在你的C++扩展中，你可以使用<code>Php::ini_get()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple function that is used to demonstrate how settings from the</span></span><br><span class="line"><span class="comment"> *  php.ini file can be read</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read in the "output_buffering" variable from the php.ini file</span></span><br><span class="line">    <span class="keyword">int</span> output_buffering = Php::ini_get(<span class="string">"output_buffering"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read in the "variables_order" variable</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> variables_order = Php::ini_get(<span class="string">"variables_order"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Php::ini_get()</code>函数返回一个可以分配给字符串、整数和浮点数的对象。在上面的例子中，我们使用这个函数将设置直接分配给一个整数和一个<code>std::string</code>。</p>
<p>你只能从php.ini中获取预定义的变量。因此不可能用随机字符串调用<code>Php::ini_get()</code>. 如果你想使用你自己的变量，你必须先在get_module()函数中注册它们，然后才能调用<code>Php::ini_get()</code>来获取当前值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;phpcpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Simple function that is used to demonstrate how settings from the</span></span><br><span class="line"><span class="comment"> *  php.ini file can be read</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read in a variable defined for this extension</span></span><br><span class="line">    <span class="keyword">int</span> var1 = Php::ini_get(<span class="string">"my_extension.var1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read in a string variable</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> var2 = Php::ini_get(<span class="string">"my_extension.var2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Switch to C contect so that the get_module() function can be</span></span><br><span class="line"><span class="comment"> *  called by the Zend engine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  The get_module() startup function</span></span><br><span class="line"><span class="comment">     *  @return void*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PHPCPP_EXPORT <span class="keyword">void</span> *<span class="title">get_module</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create extension object</span></span><br><span class="line">        <span class="keyword">static</span> Php::<span class="function">Extension <span class="title">extension</span><span class="params">(<span class="string">"my_extension"</span>, <span class="string">"1.0"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// export one function</span></span><br><span class="line">        extension.add(<span class="string">"myFunction"</span>, myFunction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tell the PHP engine that the php.ini variables my_extension.var1</span></span><br><span class="line">        <span class="comment">// and my_extension.var2 are usable</span></span><br><span class="line">        extension.add(Php::Ini(<span class="string">"my_extension.var1"</span>, <span class="string">"default-value"</span>));</span><br><span class="line">        extension.add(Php::Ini(<span class="string">"my_extension.var2"</span>, <span class="number">12345</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return a pointer to the extension object</span></span><br><span class="line">        <span class="keyword">return</span> extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展回调"><a href="#扩展回调" class="headerlink" title="扩展回调"></a>扩展回调</h2><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>尽管在 PHP 脚本中，命名空间有非常丰富的实现方式，有特殊的关键字，如 <code>use</code> 和 <code>namespace</code> 以及特殊的常量，如 <code>__NAMESPACE__</code>，但它们内部非常简单。</p>
<p>命名空间无非就是一个类或函数的前缀。如果你想让你的类或函数出现在一个特定的命名空间中，你只需要在类或函数名中添加一个前缀。下面的代码在 “myNamespace”命名空间中创建了一个函数 “myFunction”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add the myFunction function to the extension, </span></span><br><span class="line"><span class="comment">// and put it in namespace "myNamespace"</span></span><br><span class="line">extension.add(<span class="string">"myNamespace\\myFunction"</span>, myFunction);</span><br></pre></td></tr></table></figure>
<p>如果你愿意，你可以使用<code>Php::Namespace</code>实用类来实现。这个类的签名和<code>Php::Extension</code>类完全一样，你也可以用它来注册类和函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a namespace</span></span><br><span class="line">Php::<span class="function">Namespace <span class="title">myNamespace</span><span class="params">(<span class="string">"myNamespace"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the myFunction function to the namespace</span></span><br><span class="line">myNamespace.add(<span class="string">"myFunction"</span>, myFunction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @todo add more functions and classes to the namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a nested namespace</span></span><br><span class="line">Php::<span class="function">Namespace <span class="title">nestedNamespace</span><span class="params">(<span class="string">"nestedNamespace"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @todo add functions and classes to the nested namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add the nested namespace to the first namespace</span></span><br><span class="line">myNamespace.add(<span class="built_in">std</span>::move(nestedNamespace));</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the namespace to the extension</span></span><br><span class="line">extension.add(<span class="built_in">std</span>::move(myNamespace));</span><br></pre></td></tr></table></figure>
<p><code>Php::Namespace</code>类只是一个容器，它会自动为你添加的所有类和函数添加一个前缀。正如你在例子中看到的那样，嵌套命名空间也是可能的。</p>
<p>在这个例子中，我们使用std::move()函数将嵌套的命名空间移动到父命名空间中，并将第一个命名空间移动到扩展中。移动比添加更有效率，尽管常规的<code>extension.add(myNamespace)</code>也是有效的。</p>
<h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="php-cpp.com">php-cpp</a></li>
</ol>

    </div>

    
    
    
        <div class="reward-container">
  <div>不为赚钱，只为交个朋友！干杯～</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/about/wechat.jpg" alt="funsoul WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/about/ali.jpg" alt="funsoul Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/about/qrcode_wechat.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/PHP/" rel="tag"># PHP</a>
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/22/可靠的PHP：契约式设计/" rel="prev" title="可靠的PHP：契约式设计">
      <i class="fa fa-chevron-left"></i> 可靠的PHP：契约式设计
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#下载源码"><span class="nav-number">2.1.</span> <span class="nav-text">下载源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始构建PHP-CPP库"><span class="nav-number">2.2.</span> <span class="nav-text">开始构建PHP-CPP库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见错误"><span class="nav-number">2.3.</span> <span class="nav-text">常见错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装PHP-CPP库到系统中"><span class="nav-number">2.4.</span> <span class="nav-text">安装PHP-CPP库到系统中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP如何载入扩展"><span class="nav-number">3.</span> <span class="nav-text">PHP如何载入扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get-module启动函数"><span class="nav-number">3.1.</span> <span class="nav-text">get_module启动函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写第一个扩展"><span class="nav-number">4.</span> <span class="nav-text">编写第一个扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：Extension"><span class="nav-number">4.1.</span> <span class="nav-text">查看例子：Extension</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出和错误"><span class="nav-number">5.</span> <span class="nav-text">输出和错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册原生函数"><span class="nav-number">6.</span> <span class="nav-text">注册原生函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无返回值：FunctionVoid"><span class="nav-number">6.1.</span> <span class="nav-text">无返回值：FunctionVoid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有返回值：FunctionReturnValue"><span class="nav-number">6.2.</span> <span class="nav-text">有返回值：FunctionReturnValue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数参数"><span class="nav-number">7.</span> <span class="nav-text">函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：functionwithparameters"><span class="nav-number">7.1.</span> <span class="nav-text">查看例子：functionwithparameters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何获取未定义参数"><span class="nav-number">7.1.1.</span> <span class="nav-text">如何获取未定义参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何写一个加法运算函数"><span class="nav-number">7.1.2.</span> <span class="nav-text">如何写一个加法运算函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何传递引用"><span class="nav-number">7.1.3.</span> <span class="nav-text">如何传递引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何接收数组"><span class="nav-number">7.1.4.</span> <span class="nav-text">如何接收数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何接收对象"><span class="nav-number">7.1.5.</span> <span class="nav-text">如何接收对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Php-Type支持情况"><span class="nav-number">7.2.</span> <span class="nav-text">Php::Type支持情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">7.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用函数"><span class="nav-number">8.</span> <span class="nav-text">调用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：callphpfunction"><span class="nav-number">8.1.</span> <span class="nav-text">查看例子：callphpfunction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda（匿名）函数"><span class="nav-number">9.</span> <span class="nav-text">Lambda（匿名）函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-函数签名"><span class="nav-number">9.1.</span> <span class="nav-text">C++ 函数签名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类和对象"><span class="nav-number">10.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看例子：cppclassinphp"><span class="nav-number">10.1.</span> <span class="nav-text">查看例子：cppclassinphp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问修饰符"><span class="nav-number">10.2.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstract-and-final"><span class="nav-number">10.3.</span> <span class="nav-text">Abstract and final</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造与析构"><span class="nav-number">11.</span> <span class="nav-text">构造与析构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#私有构造函数"><span class="nav-number">11.1.</span> <span class="nav-text">私有构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#克隆对象"><span class="nav-number">11.2.</span> <span class="nav-text">克隆对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造对象"><span class="nav-number">11.3.</span> <span class="nav-text">构造对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">12.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义接口"><span class="nav-number">12.1.</span> <span class="nav-text">定义接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生和实现"><span class="nav-number">12.2.</span> <span class="nav-text">派生和实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#魔术方法"><span class="nav-number">13.</span> <span class="nav-text">魔术方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#魔术接口"><span class="nav-number">14.</span> <span class="nav-text">魔术接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-number">15.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#额外的转换函数"><span class="nav-number">15.1.</span> <span class="nav-text">额外的转换函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象比较"><span class="nav-number">15.2.</span> <span class="nav-text">对象比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类成员"><span class="nav-number">16.</span> <span class="nav-text">类成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">17.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在C-中捕获异常"><span class="nav-number">17.1.</span> <span class="nav-text">在C++中捕获异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">18.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局常量和类级常量"><span class="nav-number">19.</span> <span class="nav-text">全局常量和类级常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常量"><span class="nav-number">19.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量"><span class="nav-number">19.2.</span> <span class="nav-text">运行时常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从php-ini读取配置"><span class="nav-number">20.</span> <span class="nav-text">从php.ini读取配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展回调"><span class="nav-number">21.</span> <span class="nav-text">扩展回调</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间"><span class="nav-number">22.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态加载"><span class="nav-number">23.</span> <span class="nav-text">动态加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">24.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="funsoul"
      src="/images/about/avatar.jpg">
  <p class="site-author-name" itemprop="name">funsoul</p>
  <div class="site-description" itemprop="description">以终为始</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://funsoul.gitbook.io" title="Notebook → https://funsoul.gitbook.io" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>Notebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/funsoul" title="GitHub → https://github.com/funsoul" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://cyanming2016@gmail.com" title="E-Mail → https://cyanming2016@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/cpainter" title="Csdn → https://blog.csdn.net/cpainter" rel="noopener" target="_blank"><i class="fa fa-tags fa-fw"></i>Csdn</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">funsoul</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
