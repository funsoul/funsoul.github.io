[{"title":"C Sharp连接Access数据库出现的问题","url":"/2014/03/29/C%20Sharp%20%E8%BF%9E%E6%8E%A5Access%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"<p>这两天在做数据库，发现一个很多网友都头疼的问题，就是C#连接Access数据库的时候显示“不可识别的数据库类型”。</p>\n<p>很多人在做Access数据库的时候总是默认保存它的后缀名“.accedb”，然后用Provider=Microsoft.Jet.OLEDB.4.0;Data Source=…去连接Access数据库。</p>\n<p>首先第一个问题就是C#是不识别后缀“.accedb”的，因此只能将该格式转换为C#识别的“.mdb”。</p>\n<p>然后很多人会发现还是提示“不可识别的数据库类型”！其实原因就在于“Provider=Microsoft.Jet.OLEDB.4.0;Data Source=…”。因为那个 Microsoft.Jet.OLEDB.4.0， 是针对低版本的 Access 使用的。</p>\n<a id=\"more\"></a>\n<p>只需要把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Microsoft.Jet.OLEDB.4.0</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Microsoft.ACE.OLEDB.12.0</span><br></pre></td></tr></table></figure>\n<p>数据源就可以正常的输出啦！</p>\n","categories":["技术"],"tags":["C Sharp","问题排查"]},{"title":"Oracle中的exists和in","url":"/2016/09/19/Oracle%E4%B8%AD%E7%9A%84exists%E5%92%8Cin/","content":"<h2 id=\"写在前\"><a href=\"#写在前\" class=\"headerlink\" title=\"写在前\"></a>写在前</h2><p>今天有一个业务，前台是一个供用户选择条件进行查询的功能。选择完毕后点击查询，前台使用get方式发送打包好的参数列表到后台（Controller），持久层拿到参数列表后拼装到SQL中，使用jdbc连接oracle拿数据。</p>\n<a id=\"more\"></a>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>当条件过大（据说有7000多个数据），出现第一个问题，413 FULL HEAD ERROR。很明显是数据量过大，而使用的又是get方式传输，get请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连。如：login.action?name=cym&amp;password=idontknow。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。GET方式提交的数据依据浏览器而定，IE环境下的URL长度限制为2083，理论上POST没有限制，可传较大量的数据。</p>\n<p>第二个问题出现在SQL，拼接字符串中使用的where…in..，JDBC会抛出“java.sql.SQLException: ORA-01795: 列表中的最大表达式数为 1000”这个异常。没想到oracle还有这种限制，据说11g后不存在这个限制。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"一、使用临时表\"><a href=\"#一、使用临时表\" class=\"headerlink\" title=\"一、使用临时表\"></a>一、使用临时表</h3><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> t <span class=\"keyword\">WHERE</span> <span class=\"keyword\">id</span> <span class=\"keyword\">IN</span> (<span class=\"keyword\">SELECT</span> <span class=\"keyword\">id</span> <span class=\"keyword\">FROM</span> temp)</span><br></pre></td></tr></table></figure>\n<p>建立一个表来存储传入参数，取数据的时候先从临时表中遍历取参数，然后再将取出的参数拿去作为in条件</p>\n<h3 id=\"二、使用exists\"><a href=\"#二、使用exists\" class=\"headerlink\" title=\"二、使用exists\"></a>二、使用exists</h3><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> a <span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span>( <span class=\"keyword\">SELECT</span> <span class=\"number\">1</span> <span class=\"keyword\">FROM</span> b <span class=\"keyword\">WHERE</span> a.employee_id=b.employee_id)</span><br></pre></td></tr></table></figure>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><ul>\n<li>IN比 EXISTS 的可读性更好</li>\n<li>EXISTS 比IN 的表达性更好（更适合复杂的语句）</li>\n</ul>\n<p>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）</p>\n","categories":["技术"],"tags":["Oracle"]},{"title":"PHP返回对象的公有属性和值","url":"/2018/05/03/PHP%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AC%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E5%80%BC/","content":"<p>获取对象的公有属性和值，很自然的会想到 <strong>get_object_vars</strong> 这个函数，可以这样写，</p>\n<a id=\"more\"></a>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $name = <span class=\"string\">'xxx'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">$item = get_object_vars($user);</span><br><span class=\"line\">print_r($item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array</span></span><br><span class=\"line\"><span class=\"comment\">// (</span></span><br><span class=\"line\"><span class=\"comment\">//     [name] =&gt; xxx</span></span><br><span class=\"line\"><span class=\"comment\">// )</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码是写在对象的外部的，可不可以提供一个 <strong>trait</strong> 使得每个对象都复用一个接口，供外部使用呢？这样一来，看上去更像是对象自己的方法，我们可以通过这个方法来取得对象的公有属性与其值。</p>\n<p>上面我们用 <strong>get_object_vars</strong> 函数在外部实现了这个想法，放到内部试试看，当然我们要结合<strong>trait</strong>来实现：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">trait</span> PrintPublic &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">publics</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get_object_vars(<span class=\"keyword\">$this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $name = <span class=\"string\">'xxx'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">PrintPublic</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">$item = $user-&gt;publics();</span><br><span class=\"line\">print_r($item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array</span></span><br><span class=\"line\"><span class=\"comment\">// (</span></span><br><span class=\"line\"><span class=\"comment\">//     [age] =&gt; 18</span></span><br><span class=\"line\"><span class=\"comment\">//     [name] =&gt; xxx</span></span><br><span class=\"line\"><span class=\"comment\">// )</span></span><br></pre></td></tr></table></figure>\n<p>我们发现，把所有的属性都取出来了，无论是公有的还是私有的，这不对。为什么会这样呢？不难想象，因为这个方法是放在类内部的，作用域在内部。而之前这个方法是放在类的外部，作用域是全局的。思路有了，我们只需要想办法让作用域在类的外部就可以了，我们想到了 <strong>call_user_func</strong> 这个方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">trait</span> PrintPublic &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">publics</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> call_user_func(<span class=\"string\">'get_object_vars'</span>, <span class=\"keyword\">$this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $name = <span class=\"string\">'xxx'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">PrintPublic</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">$item = $user-&gt;publics();</span><br><span class=\"line\">print_r($item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// version &lt; php 7</span></span><br><span class=\"line\"><span class=\"comment\">// Array</span></span><br><span class=\"line\"><span class=\"comment\">// (</span></span><br><span class=\"line\"><span class=\"comment\">//     [name] =&gt; xxx</span></span><br><span class=\"line\"><span class=\"comment\">// )</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// version &gt; php 7</span></span><br><span class=\"line\"><span class=\"comment\">// Array</span></span><br><span class=\"line\"><span class=\"comment\">// (</span></span><br><span class=\"line\"><span class=\"comment\">//     [name] =&gt; xxx</span></span><br><span class=\"line\"><span class=\"comment\">//     [age] =&gt; 18</span></span><br><span class=\"line\"><span class=\"comment\">// )</span></span><br></pre></td></tr></table></figure>\n<p>我们又发现了一个问题，这个方法在php7不能奏效，具体原因未知，有空探讨一下，既然这样也不是最好的办法，那就再换一个函数 <strong>create_function</strong>，试试看</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">trait</span> PrintPublic &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">publics</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        $publicVars = create_function(<span class=\"string\">'$obj'</span>, <span class=\"string\">'return get_object_vars($obj);'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $publicVars(<span class=\"keyword\">$this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $name = <span class=\"string\">\"xxx\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $_age = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">use</span> <span class=\"title\">PrintPublic</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$User = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">$data = $User-&gt;publics();</span><br><span class=\"line\">print_r($data);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array</span></span><br><span class=\"line\"><span class=\"comment\">// (</span></span><br><span class=\"line\"><span class=\"comment\">//     [name] =&gt; xxx</span></span><br><span class=\"line\"><span class=\"comment\">// )</span></span><br></pre></td></tr></table></figure>\n<p>没问题了，问题解决 :)</p>\n","categories":["技术"],"tags":["PHP"]},{"title":"PHP查询impala超时处理","url":"/2018/10/23/PHP%E6%9F%A5%E8%AF%A2impala%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>php-fpm的 <strong>request_terminate_timeout</strong> 参数，当设置为0时，worker进程在处理请求时就没有超时处理，0表示无限制，也就是说，用户在查询SQL时，如果该条SQL耗时非常久，worker也不会主动关闭该请求。这里就会出现一种常见的情况：用户看到一直不响应，那就刷新重来，重复查询操作。由于前一个worker还在等待impala服务返回数据，没执行完毕，不能恢复空闲状态，所以master只会把该请求分配给其他worker执行。长此以来，impala服务面对这么多耗时SQL，CPU和内存疯长，处理速度下降。fpm的“僵死”worker越来越多，web服务被拖慢。</p>\n<a id=\"more\"></a>\n<p>优化过程如下：</p>\n<ol>\n<li>request_terminate_timeout设置一个大于0的常数值</li>\n<li>odbc配置设置</li>\n<li>thrift查询impala</li>\n<li>使用impala API</li>\n</ol>\n<h2 id=\"request-terminate-timeout设置一个大于0的常数值\"><a href=\"#request-terminate-timeout设置一个大于0的常数值\" class=\"headerlink\" title=\"request_terminate_timeout设置一个大于0的常数值\"></a>request_terminate_timeout设置一个大于0的常数值</h2><p>既然worker不会主动结束与impala的连接，那就设置一个大于0的常数值，比如60s，那么当请求到了60s还没结束那就主动关闭掉。（<strong>这里的请求指的web请求</strong>）看起来是没问题的，既保证了impala服务稳定，又释放了worker的压力。但是，有两个小问题也很容易想到：</p>\n<ol>\n<li>worker主动关闭返回504 gateway timeout，这个异常是无法在php捕获的，所以没办法争对做处理。</li>\n<li>修改php-fpm的配置，可能会影响其他web程序的正常执行。</li>\n</ol>\n<h2 id=\"odbc配置设置\"><a href=\"#odbc配置设置\" class=\"headerlink\" title=\"odbc配置设置\"></a>odbc配置设置</h2><p>我们使用的连接方案是<strong>odbc</strong>，从php到impala，整个调用栈大约如此：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">php-&gt;phpodbc-&gt;unixodbc-&gt;impalaodbc</span><br></pre></td></tr></table></figure>\n<p>由于是cgi程序，所以对进程操作会产生各种奇怪的情况，这里就不做分析了，可能性不大。</p>\n<h3 id=\"1、-odbc-setoption\"><a href=\"#1、-odbc-setoption\" class=\"headerlink\" title=\"1、 odbc_setoption()\"></a>1、 odbc_setoption()</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2. Option 0 of SQLSetStmtOption() is SQL_QUERY_TIMEOUT.</span></span><br><span class=\"line\"><span class=\"comment\">//    This example sets the query to timeout after 30 seconds.</span></span><br><span class=\"line\">$result = odbc_prepare($conn, $sql);</span><br><span class=\"line\">odbc_setoption($result, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">odbc_execute($result);</span><br></pre></td></tr></table></figure>\n<p>看了下官网手册，发现了这个函数<a href=\"http://php.net/manual/zh/function.odbc-setoption.php\" target=\"_blank\" rel=\"noopener\">odbc_setoption</a>，但是并没有用，因为impalaodbc并没有实现这个接口。</p>\n<h3 id=\"2、odbc-ini中SocketTimeout参数\"><a href=\"#2、odbc-ini中SocketTimeout参数\" class=\"headerlink\" title=\"2、odbc.ini中SocketTimeout参数\"></a>2、odbc.ini中SocketTimeout参数</h3><blockquote>\n<p>The number of seconds that the TCP socket waits for a response from the server before timing out the request and returning an error message</p>\n</blockquote>\n<p>看了下<a href=\"https://www.cloudera.com/documentation/other/connectors/impala-odbc/latest/Cloudera-ODBC-Driver-for-Impala-Install-Guide.pdf\" target=\"_blank\" rel=\"noopener\">文档</a>，这里是指TCP socket的闲置连接超时，而不是查询超时。也没用，这个参数和我们的需求没什么关系。</p>\n<h2 id=\"thrift查询impala\"><a href=\"#thrift查询impala\" class=\"headerlink\" title=\"thrift查询impala\"></a>thrift查询impala</h2><p>前面都是用odbc来连接impala，换个思路，使用thrift来试试看。上github找了两个库，<a href=\"https://github.com/tranch/php-thrift-impala\" target=\"_blank\" rel=\"noopener\">tranch/php-thrift-impala</a>,<a href=\"https://github.com/Automattic/php-thrift-sql\" target=\"_blank\" rel=\"noopener\">Automattic/php-thrift-sql</a>。开源万岁:)</p>\n<p>由于我们的项目使用laravel来写，Automattic/php-thrift-sql就不太适合了（composer下载要账密是什么鬼= =），难道要我把仓库拉下来改一下？都8102年了，不支持composer，没有namespace的代码要你何用！于是，我用了这个tranch/php-thrift-impala。但是，这个仓库有bug！它自己封装的超时设置无效的！怪不得没有几个星星啊~没办法，然后，我结合Automattic/php-thrift-sql这个仓库的例子写了一个，完美执行。以后有空我封装一下开源吧~ :)</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$impalaHost = <span class=\"string\">'127.0.0.1'</span>;</span><br><span class=\"line\">$impalaThriftPort = <span class=\"number\">21000</span>;</span><br><span class=\"line\">$timeout = <span class=\"number\">60000</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">'select * from tb;'</span>;</span><br><span class=\"line\">$user = <span class=\"string\">'admin'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$socket = <span class=\"keyword\">new</span> \\Thrift\\Transport\\TSocket($impalaHost, $impalaThriftPort);</span><br><span class=\"line\">$socket-&gt;setRecvTimeout($timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">$transport = <span class=\"keyword\">new</span> \\Thrift\\Transport\\TBufferedTransport($socket, <span class=\"number\">1024</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">$protocol = <span class=\"keyword\">new</span> \\Thrift\\Protocol\\TBinaryProtocol($transport);</span><br><span class=\"line\"></span><br><span class=\"line\">$client = <span class=\"keyword\">new</span> \\ThriftSQL\\ImpalaServiceClient($protocol);</span><br><span class=\"line\">$transport-&gt;open();</span><br><span class=\"line\"></span><br><span class=\"line\">$query = <span class=\"keyword\">new</span> \\ThriftSQL\\Query(<span class=\"keyword\">array</span>(<span class=\"string\">'query'</span> =&gt; $sql, <span class=\"string\">'hadoop_user'</span> =&gt; $user));</span><br><span class=\"line\">$handle = $client-&gt;query($query);</span><br><span class=\"line\"></span><br><span class=\"line\">$metadata = $client-&gt;get_results_metadata($handle);</span><br><span class=\"line\">$fields = $metadata-&gt;schema-&gt;fieldSchemas;</span><br><span class=\"line\"></span><br><span class=\"line\">$data = <span class=\"keyword\">array</span>();</span><br><span class=\"line\">$dataPiece = $client-&gt;fetch($handle, <span class=\"keyword\">false</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">$data = array_merge($data, <span class=\"keyword\">static</span>::parseField($dataPiece, $fields));</span><br><span class=\"line\"><span class=\"keyword\">while</span> ($dataPiece-&gt;has_more)&#123;</span><br><span class=\"line\">    $dataPiece = $client-&gt;fetch($handle, <span class=\"keyword\">false</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">    $data = array_merge($data, <span class=\"keyword\">static</span>::parseField($dataPiece, $fields));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$transport-&gt;close();</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><p>thrift查询impala在php层就可以处理超时。但是，毕竟是php代码，查询会慢一些，我简单对比了一下，同一个查询，thrift和odbc相比有一倍多的差异。所以在这个系统中，并不是只用thrift或者odbc，而是看场景，混合着用。</p>\n<p>但是！想法还是太naive，本以为主动断开连接，impala就会取消耗时查询。impala还是没有终止查询任务，内存继续疯长。</p>\n<h2 id=\"使用impala-API\"><a href=\"#使用impala-API\" class=\"headerlink\" title=\"使用impala API\"></a>使用impala API</h2><p>官网看到有<a href=\"https://archive.cloudera.com/cm6/6.3.0/generic/jar/cm_api/apidocs/resource_ImpalaQueriesResource.html\" target=\"_blank\" rel=\"noopener\">终止查询任务的API</a></p>\n<ul>\n<li>获取查询任务列表API：GET /clusters/{clusterName}/services/{serviceName}/impalaQueries</li>\n<li>取消查询API：POST /clusters/{clusterName}/services/{serviceName}/impalaQueries/{queryId}/cancel </li>\n</ul>\n<p>步骤很简单，</p>\n<ol>\n<li>通过获取查询列表API，得到所有查询的详情</li>\n<li>通过查询者和查询SQL与列表对比，得到queryId</li>\n<li>有了queryId和取消查询API，就真正解决了超时查询的终止问题</li>\n</ol>\n<p>thanks :)</p>\n","categories":["技术"],"tags":["问题排查","PHP","ODBC","impala","thrift"]},{"title":"Redis：pubsub场景下的保活机制","url":"/2020/04/13/Redis%EF%BC%9Apubsub%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6/","content":"<p>上一篇[<a href=\"/2019/08/13/【Redis】brpop保活机制/\" title=\"Redis：排查 read error on connection 小记\">Redis：排查 read error on connection 小记</a>]，排查了redis pop list场景下断网引发<code>read error on connection</code>错误的情况，文末留下一个疑问，就是在pubsub场景下，该如何应对断网？（客户端和服务端不可达，触发保活机制）</p>\n<p><strong>在这篇文章，我们假设网络在某时会中断十几分钟</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"问题复现\"><a href=\"#问题复现\" class=\"headerlink\" title=\"问题复现\"></a>问题复现</h2><h3 id=\"我的环境\"><a href=\"#我的环境\" class=\"headerlink\" title=\"我的环境\"></a>我的环境</h3><ul>\n<li>php=7.1.22</li>\n<li>phpredis=5.0.2</li>\n<li>redis-server=4.0.14</li>\n</ul>\n<p>可以通过服务端 <code>client kill ip:port</code>，客户端报异常<code>read error on connection</code>。</p>\n<p>这里抛出疑问：服务端主动kill的？何时会kill？</p>\n<h3 id=\"因为系统的tcp保活机制被kill？\"><a href=\"#因为系统的tcp保活机制被kill？\" class=\"headerlink\" title=\"因为系统的tcp保活机制被kill？\"></a>因为系统的tcp保活机制被kill？</h3><p>先看系统的tcp_keepalive配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">net.ipv4.tcp_keepalive_time = 30</span><br><span class=\"line\">net.ipv4.tcp_keepalive_probes = 9</span><br><span class=\"line\">net.ipv4.tcp_keepalive_intvl = 75</span><br></pre></td></tr></table></figure>\n<p>即30+9*75=705s=11min45s，如果网络在<code>12分钟内</code>保持断开状态，服务端就会kill掉客户端。<strong>可以解释的通，但是实测过程中发现，并没有使用系统的设置定时发ack</strong></p>\n<h3 id=\"因为redis服务端的保活机制被kill\"><a href=\"#因为redis服务端的保活机制被kill\" class=\"headerlink\" title=\"因为redis服务端的保活机制被kill?\"></a>因为redis服务端的保活机制被kill?</h3><p>查看服务端redis.conf配置，tcp_keepalive被设置为<code>600</code></p>\n<p>注释：</p>\n<blockquote>\n<p>TCP keepalive.<br>If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence<br>of communication. This is useful for two reasons:<br>1) Detect dead peers.<br>2) Take the connection alive from the point of view of network<br>  equipment in the middle.<br>On Linux, the specified value (in seconds) is the period used to send ACKs.<br>Note that to close the connection the double of the time is needed.<br>On other kernels the period depends on the kernel configuration.<br>A reasonable value for this option is 300 seconds, which is the new<br>Redis default starting with Redis 3.2.1.</p>\n</blockquote>\n<p>含义（<a href=\"https://redis.io/topics/clients\" target=\"_blank\" rel=\"noopener\">官网</a>）</p>\n<blockquote>\n<p>Recent versions of Redis (3.2 or greater) have TCP keepalive (SO_KEEPALIVE socket option) enabled by default and set to about 300 seconds. This option is useful in order to detect dead peers (clients that cannot be reached even if they look connected). Moreover, if there is network equipment between clients and servers that need to see some traffic in order to take the connection open, the option will prevent unexpected connection closed events.</p>\n</blockquote>\n<p>由上面的含义，可以提出三种可能的解释：</p>\n<ol>\n<li>这个参数覆盖系统的tcp_keepalive_time，并结合系统的tcp_keepalive_probes和tcp_keepalive_intvl，即600+9*75=1275s=21min15s（时间长了点）</li>\n<li>每隔600s，进行一次系统的保活机制（600s+11min45s=21min45s，时间长了点）</li>\n<li><strong>服务端在600s后会给客户端发ack。也就是10min。（可以解释，实测中发现是这种）</strong></li>\n</ol>\n<h2 id=\"客户端选项的OPT-KEEP-ALIVE到底是怎么使用的？\"><a href=\"#客户端选项的OPT-KEEP-ALIVE到底是怎么使用的？\" class=\"headerlink\" title=\"客户端选项的OPT_KEEP_ALIVE到底是怎么使用的？\"></a>客户端选项的<code>OPT_KEEP_ALIVE</code>到底是怎么使用的？</h2><p>上篇文章我们已经发现了，它是一个开关，但是有两个疑问：</p>\n<ol>\n<li>它用来启动服务端对客户端的保活？</li>\n<li>它用来启动客户端对服务端的保活？(实测发现，是这个。<strong>使用系统的tcp_keepalive配置，与redis.conf无关</strong>)</li>\n</ol>\n<p>实测发现，如果在12分钟内网络保持断开状态（系统的tcp_keepalive配置为11min45s），客户端subscribe则会抛出<code>read error on connection</code>异常。这很好，我们可以捕获这个异常，重启客户端。</p>\n<p>但是，由于不清楚网络何时会恢复，如果断开时间较短，可以借助<code>supervisor</code>等管理工具，在程序异常退出后不断拉启即可。如果断开时间较长，或许需要像上一篇文章[<a href=\"/2019/08/13/【Redis】brpop保活机制/\" title=\"Redis：排查 read error on connection 小记\">Redis：排查 read error on connection 小记</a>]那样，做一个<code>忙连接</code>程序，不断去尝试重连服务端。</p>\n<h3 id=\"pubsub场景下的忙连接程序\"><a href=\"#pubsub场景下的忙连接程序\" class=\"headerlink\" title=\"pubsub场景下的忙连接程序\"></a>pubsub场景下的忙连接程序</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    $redis = <span class=\"keyword\">new</span> Redis();</span><br><span class=\"line\">    $redis-&gt;connect($host, $port);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            $redis-&gt;subscribe($chans, [<span class=\"keyword\">$this</span>, <span class=\"string\">'process'</span>]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">Exception</span> $exception) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 忙连接等待网络恢复</span></span><br><span class=\"line\">            $redis = <span class=\"keyword\">$this</span>-&gt;reconnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reconnect</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    $redis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    $isLostConnect = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ($isLostConnect) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            $redis = <span class=\"keyword\">new</span> Redis();</span><br><span class=\"line\">            $redis-&gt;connect($host, $port);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 重连成功</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ($redis-&gt;ping()) &#123;</span><br><span class=\"line\">                $isLostConnect = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 阻塞等待几秒钟，再次尝试重连</span></span><br><span class=\"line\">            sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> $redis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main();</span><br></pre></td></tr></table></figure>\n<h2 id=\"phpredis保活机制原理\"><a href=\"#phpredis保活机制原理\" class=\"headerlink\" title=\"phpredis保活机制原理\"></a>phpredis保活机制原理</h2><p>phpredis源码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Don't set TCP_KEEPALIVE if we're using a unix socket. */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (ZSTR_VAL(redis_sock-&gt;host)[<span class=\"number\">0</span>] == <span class=\"string\">'/'</span> &amp;&amp; redis_sock-&gt;port &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    RETURN_FALSE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tcp_keepalive = zval_get_long(val) &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis_sock-&gt;tcp_keepalive == tcp_keepalive) &#123;</span><br><span class=\"line\">    RETURN_TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis_sock-&gt;stream) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* set TCP_KEEPALIVE */</span></span><br><span class=\"line\">    sock = (<span class=\"keyword\">php_netstream_data_t</span>*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (<span class=\"keyword\">char</span>*)&amp;tcp_keepalive,</span><br><span class=\"line\">                <span class=\"keyword\">sizeof</span>(tcp_keepalive)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        RETURN_FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    redis_sock-&gt;tcp_keepalive = tcp_keepalive;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，phpredis并没有提供<code>SOL_TCP</code>字段选项的配置，即</p>\n<ol>\n<li>TCP_KEEPIDLE（等同于tcp_keepalive_time）</li>\n<li>TCP_KEEPINTVL（等同于tcp_keepalive_intvl）</li>\n<li>TCP_KEEPCNT（等同于tcp_keepalive_probes）</li>\n</ol>\n<p>所以，<strong>phpredis默认使用系统内核提供的tcp_keepalive配置</strong>，这意味着，如果需要修改保活时间，需要更改系统配置…</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ol>\n<li>服务端保活，通过设置redis.conf里面的tcp-keepalive配置，即可定时检测连接是否有效（新版本默认为300s），如果不可达，则移除客户端连接（kill client），移除连接的时候，客户端则保持”Established”(<code>半连接状态</code>)。对pubsub程序来说，客户端无法接收到服务端的消息。</li>\n<li>客户端保活，通过setOption配置<code>OPT_KEEP_ALIVE</code>开启，使用系统tcp_keepalive配置，定时发送ack包验证连接有效，如果不可达，则同样抛出<code>read error on connection</code>异常，程序需要捕获异常并重连服务端，连接成功后，打开subscribe。</li>\n<li>phpredis的客户端保活不支持自定义<code>SOL_TCP</code>，使用系统内核的网络配置。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://zzyongx.github.io/blogs/tcp-keepalive-howto.html\" target=\"_blank\" rel=\"noopener\">TCP Keepalive HOWTO</a></p>\n","categories":["技术"],"tags":["PHP","Redis","TCP/IP"]},{"title":"ngx_http_empty_gif_module在日志统计中的应用","url":"/2018/04/16/ngx_http_empty_gif_module%E5%9C%A8%E6%97%A5%E5%BF%97%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","content":"<h2 id=\"日志统计分析架构\"><a href=\"#日志统计分析架构\" class=\"headerlink\" title=\"日志统计分析架构\"></a>日志统计分析架构</h2><p>在日志统计分析中，通常包括以下的模块</p>\n<ul>\n<li>前端日志上报（js上报url、user_agent等等）</li>\n<li>打点服务器（nginx）</li>\n<li>统计日志（access_log）</li>\n<li>分析日志（后端程序）</li>\n<li>保存分析结果（db）</li>\n</ul>\n<a id=\"more\"></a>\n<p>我们通常把日志上报和日志分析解耦，利用nginx的大并发承载力，接收前端上报的日志。在这里，我们不做协议转发到后端程序（PHP或者其他cgi程序）处理日志统计，而是利用nginx的access_log，约定好日志保存格式（format），由nginx帮助我们做日志统计。</p>\n<p>日志上报的并发量有可能非常巨大，举个例子，如果由PHP来处理，那么每一次日志上报都需要经过nginx的转发、PHP生命周期的五个阶段（MINIT、RINIT、代码处理、RSHUTDOWN、MSHUTDOWN），即使做了opcache，将预编译的脚本存储在共享内存中，也是需要不菲的消耗。1毫秒的处理时间不算什么，但是 1 X 100000n 那就需要引起关注了。</p>\n<p>我们还需要一个分析日志的守护进程，这时候可以利用php的cli或者别的语言实现，将分析结果（pv、uv等等）保存到数据库，然后提供一个web界面来展示结果。</p>\n<h2 id=\"ngx-http-empty-gif-module\"><a href=\"#ngx-http-empty-gif-module\" class=\"headerlink\" title=\"ngx_http_empty_gif_module\"></a>ngx_http_empty_gif_module</h2><p>http程序是请求-响应模式，日志上报完成后，后端需要返回一个值，告诉前端结果。一般来说，我们会使用json，上报一个日志，返回一个json串，比如</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcode: 0,</span><br><span class=\"line\">\tmsg: 'sucess'</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如前文所说，这是有可能是一个大并发的程序，如果每次都返回一个json串，是不是有点太大了，为什么这里会说“大”，接着看，我尝试返回一个整型数字1,</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>在浏览器中查看返回数据的大小为 268B ，一个数字的占用就有268B，如果包含状态码，状态值，岂不是更大。</p>\n<p>所以我们看看nginx有没有更好的解决方式，那就是ngx_http_empty_gif_module。</p>\n<p>这是一个由nginx生成的 1x1 像素的图片，通过查看源码可以知道，这是nginx自己拼接而成的完全内存级别的图片</p>\n<p>/path-to-nginx/src/http/modules/ngx_http_empty_gif_module.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> u_char  ngx_empty_gif[] = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">'G'</span>, <span class=\"string\">'I'</span>, <span class=\"string\">'F'</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'9'</span>, <span class=\"string\">'a'</span>,  <span class=\"comment\">/* header                                 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                   <span class=\"comment\">/* logical screen descriptor              */</span></span><br><span class=\"line\">    <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>,                    <span class=\"comment\">/* logical screen width                   */</span></span><br><span class=\"line\">    <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>,                    <span class=\"comment\">/* logical screen height                  */</span></span><br><span class=\"line\">    <span class=\"number\">0x80</span>,                          <span class=\"comment\">/* global 1-bit color table               */</span></span><br><span class=\"line\">    <span class=\"number\">0x01</span>,                          <span class=\"comment\">/* background color #1                    */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>,                          <span class=\"comment\">/* no aspect ratio                        */</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                   <span class=\"comment\">/* global color table                     */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>,              <span class=\"comment\">/* #0: black                              */</span></span><br><span class=\"line\">    <span class=\"number\">0xff</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0xff</span>,              <span class=\"comment\">/* #1: white                              */</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                   <span class=\"comment\">/* graphic control extension              */</span></span><br><span class=\"line\">    <span class=\"number\">0x21</span>,                          <span class=\"comment\">/* extension introducer                   */</span></span><br><span class=\"line\">    <span class=\"number\">0xf9</span>,                          <span class=\"comment\">/* graphic control label                  */</span></span><br><span class=\"line\">    <span class=\"number\">0x04</span>,                          <span class=\"comment\">/* block size                             */</span></span><br><span class=\"line\">    <span class=\"number\">0x01</span>,                          <span class=\"comment\">/* transparent color is given,            */</span></span><br><span class=\"line\">                                   <span class=\"comment\">/*     no disposal specified,             */</span></span><br><span class=\"line\">                                   <span class=\"comment\">/*     user input is not expected         */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>,                    <span class=\"comment\">/* delay time                             */</span></span><br><span class=\"line\">    <span class=\"number\">0x01</span>,                          <span class=\"comment\">/* transparent color #1                   */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>,                          <span class=\"comment\">/* block terminator                       */</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                   <span class=\"comment\">/* image descriptor                       */</span></span><br><span class=\"line\">    <span class=\"number\">0x2c</span>,                          <span class=\"comment\">/* image separator                        */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>,                    <span class=\"comment\">/* image left position                    */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>,                    <span class=\"comment\">/* image top position                     */</span></span><br><span class=\"line\">    <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>,                    <span class=\"comment\">/* image width                            */</span></span><br><span class=\"line\">    <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>,                    <span class=\"comment\">/* image height                           */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>,                          <span class=\"comment\">/* no local color table, no interlaced    */</span></span><br><span class=\"line\"></span><br><span class=\"line\">                                   <span class=\"comment\">/* table based image data                 */</span></span><br><span class=\"line\">    <span class=\"number\">0x02</span>,                          <span class=\"comment\">/* LZW minimum code size,                 */</span></span><br><span class=\"line\">                                   <span class=\"comment\">/*     must be at least 2-bit             */</span></span><br><span class=\"line\">    <span class=\"number\">0x02</span>,                          <span class=\"comment\">/* block size                             */</span></span><br><span class=\"line\">    <span class=\"number\">0x4c</span>, <span class=\"number\">0x01</span>,                    <span class=\"comment\">/* compressed bytes 01_001_100, 0000000_1 */</span></span><br><span class=\"line\">                                   <span class=\"comment\">/* 100: clear code                        */</span></span><br><span class=\"line\">                                   <span class=\"comment\">/* 001: 1                                 */</span></span><br><span class=\"line\">                                   <span class=\"comment\">/* 101: end of information code           */</span></span><br><span class=\"line\">    <span class=\"number\">0x00</span>,                          <span class=\"comment\">/* block terminator                       */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">0x3B</span>                           <span class=\"comment\">/* trailer                                */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>继续刚刚的问题，前端上报日志后，后端怎么返回这个图片呢？返回这个图片有什么好处？</p>\n<p>只需要在nginx中配置</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name log.com;</span><br><span class=\"line\"></span><br><span class=\"line\">        location = /<span class=\"keyword\">dig</span> &#123;</span><br><span class=\"line\">           empty_gif;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样一来，前端只需要把url、ua等信息提交到 log.com/dig 即可，后端就会返回一个1pixel的图片。</p>\n<p>通过查看浏览器信息可以发现，返回大小为 229B，是不是比返回json更快，占用更小呢 :)</p>\n","categories":["技术"],"tags":["Nginx"]},{"title":"Swoole协程如何处理CPU密集型应用","url":"/2019/09/26/Swoole%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>存档，待完善..</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>想要做抢占式调度，对于PHP来说，有两个途径</p>\n<ol>\n<li>当前执行协程在一定条件下主动让出</li>\n<li>额外开线程，监控当前执行协程时间，超过设定值则让出当前执行协程</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"当前执行协程在一定条件下主动让出\"><a href=\"#当前执行协程在一定条件下主动让出\" class=\"headerlink\" title=\"当前执行协程在一定条件下主动让出\"></a>当前执行协程在一定条件下主动让出</h3><p>Swoole版本：4.3.x</p>\n<p>PHP是单线程运行的，可以参考这篇文章<a href=\"https://wiki.swoole.com/wiki/page/p-tick_scheduler.html\" target=\"_blank\" rel=\"noopener\">协程 CPU 密集场景调度实现</a>，在脚本开始处注入逻辑<code>declare(tick=N)</code>，配合Swoole协程。逻辑是每次触发<code>tick handler</code>的时候，判断当前协程相对最近一次调度时间是否大于<code>协程最大执行时间(max_exec_msec)</code>，这样就可以将当前超出执行时间后的协程主动让出。</p>\n<h3 id=\"额外开线程，负责检查当前执行协程的执行时间\"><a href=\"#额外开线程，负责检查当前执行协程的执行时间\" class=\"headerlink\" title=\"额外开线程，负责检查当前执行协程的执行时间\"></a>额外开线程，负责检查当前执行协程的执行时间</h3><p>Swoole版本：4.4.x</p>\n<p>参考这篇文章<a href=\"https://segmentfault.com/a/1190000019253487\" target=\"_blank\" rel=\"noopener\">Swoole 4.4 协程抢占式调度器详解</a>，利用<code>PHP-7.1.0</code>引入的<code>VM interrupt</code>机制，默认每隔<code>5ms</code>检查一下当前协程是否达到最大执行时间，默认为10ms，如果超过，则让出当前协程，达到被其他协程抢占的目的。</p>\n","categories":["技术"],"tags":["PHP","Swoole"]},{"title":"procedure在Mysql和Sql Server中使用的一些区别","url":"/2015/12/17/procedure%E5%9C%A8Mysql%E5%92%8CSql%20Server%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/","content":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>MySQL 5.6.20</li>\n</ul>\n<h2 id=\"写在前\"><a href=\"#写在前\" class=\"headerlink\" title=\"写在前\"></a>写在前</h2><p>近日，一个好友@随风飘散，问我一个关于procedure在MySQL中使用出现的一些问题。在解决后做一个简单的总结：</p>\n<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>下面这段代码来自SQL Server，意思是创建一个procedure， 查询表test_user所有的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> getUsers</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> test_user</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXECUTE</span>    getUsers</span><br></pre></td></tr></table></figure>\n<p>将这段代码原封不动的复制到MySQL中执行</p>\n<p><img src=\"/images/procedure区别/20151217113258531.jpg\" alt></p>\n<p>可以看出，很明显是语法不正确出现的问题。经查阅相关文档，得出以下代码段</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">PROCEDURE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> getUsers;</span><br><span class=\"line\">DELIMITER //</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> getUsers()</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> test_user;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br><span class=\"line\">//</span><br><span class=\"line\">DELIMITER ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CALL</span>  getUsers();</span><br></pre></td></tr></table></figure>\n<p>执行结果如下：</p>\n<p><img src=\"/images/procedure区别/20151217120502176.jpg\" alt></p>\n<p>可以看出，procedure 在 <strong>sql server</strong> 和 <strong>mysql</strong> 中使用的差别还是很大的， 有几个重要的区别：</p>\n<ol>\n<li>使用分隔符包含存储过程</li>\n<li>不再需要AS</li>\n<li>使用CALL代替EXECUTE</li>\n</ol>\n<p>解决了这个问题，甚是感觉到自己实践不足，遇到的问题太少，希望自己能遇到更多的问题，提高自己的同时，帮助更多的人解决问题。</p>\n","categories":["技术"],"tags":["数据库"]},{"title":"odbc connect return false","url":"/2019/09/26/odbc%20connect%20return%20false/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>odbc在connect的时候会返回<code>资源句柄</code>，但是如果返回<code>false</code>就蒙蔽了。如果有记录php错误日志，会得到下面的内容</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">odbc_connect(): SQL error: [unixODBC][Cloudera][ODBC] (<span class=\"number\">11560</span>) Unable <span class=\"keyword\">to</span> locate SQLGetPrivateProfileString <span class=\"function\"><span class=\"keyword\">function</span>., <span class=\"title\">SQL</span> <span class=\"title\">state</span> <span class=\"title\">S1000</span> <span class=\"title\">in</span> <span class=\"title\">SQLConnect</span></span></span><br></pre></td></tr></table></figure>\n<p>google一下发现和动态库有点关系，只好看下系统调用情况</p>\n<a id=\"more\"></a>\n<h2 id=\"strace-php-进程\"><a href=\"#strace-php-进程\" class=\"headerlink\" title=\"strace php 进程\"></a>strace php 进程</h2><p>找到下面的信息，看来是这个库<code>libiodbcinst.so</code>缺失了</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/home/.odbcinst.ini\"</span>, O_RDONLY)   = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/etc/ld.so.cache\"</span>, O_RDONLY)      = <span class=\"number\">7</span></span><br><span class=\"line\">fstat(<span class=\"number\">7</span>, &#123;st_mode=S_IFREG|<span class=\"number\">0644</span>, st_size=<span class=\"number\">31742</span>, ...&#125;) = <span class=\"number\">0</span></span><br><span class=\"line\">mmap(NULL, <span class=\"number\">31742</span>, PROT_READ, MAP_PRIVATE, <span class=\"number\">7</span>, <span class=\"number\">0</span>) = <span class=\"number\">0</span>x7f779b219000</span><br><span class=\"line\"><span class=\"keyword\">close</span>(<span class=\"number\">7</span>)                                = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/lib64/tls/libiodbcinst.so\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/lib64/libiodbcinst.so\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/usr/lib64/tls/libiodbcinst.so\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/usr/lib64/libiodbcinst.so\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\">munmap(<span class=\"number\">0</span>x7f779b219000, <span class=\"number\">31742</span>)           = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/data/logs/php/php_error.log\"</span>, O_WRONLY|O_CREAT|O_APPEND, <span class=\"number\">0644</span>) = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"keyword\">write</span>(<span class=\"number\">7</span>, <span class=\"string\">\"[26-Sep-2019 10:52:47 Asia/Shang\"</span>..., <span class=\"number\">304</span>) = <span class=\"number\">304</span></span><br><span class=\"line\"><span class=\"keyword\">close</span>(<span class=\"number\">7</span>)                                = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"安装库文件\"><a href=\"#安装库文件\" class=\"headerlink\" title=\"安装库文件\"></a>安装库文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -ivh https://rpmfind.net/linux/epel/6/x86_64/Packages/l/libiodbc-3.52.7-1.el6.x86_64.rpm</span><br><span class=\"line\"></span><br><span class=\"line\">ln -sv /usr/lib64/libiodbcinst.so.2 /usr/lib64/libiodbcinst.so</span><br></pre></td></tr></table></figure>","categories":["技术"],"tags":["PHP","ODBC"]},{"title":"Swoole加速结巴分词","url":"/2019/08/14/Swoole%E5%8A%A0%E9%80%9F%E7%BB%93%E5%B7%B4%E5%88%86%E8%AF%8D/","content":"<h2 id=\"中文分词\"><a href=\"#中文分词\" class=\"headerlink\" title=\"中文分词\"></a>中文分词</h2><p>对于英文句子来说，可以通过<code>空格</code>来切分单词，如</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 今天天气不错</span><br><span class=\"line\">the weather is nice today</span><br></pre></td></tr></table></figure>\n<p>可以很简单的把该句子中的单词区分出来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">the/weather/is/nice/today</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>在中文里面，就没有那么方便的区分方法了。当然，如果你习惯这样说话：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">今天 天气 不错</span><br></pre></td></tr></table></figure>\n<p>大家也不会打你，只会觉得你像个<code>“结巴”</code>（点题了！）</p>\n<h3 id=\"为什么需要分词？\"><a href=\"#为什么需要分词？\" class=\"headerlink\" title=\"为什么需要分词？\"></a>为什么需要分词？</h3><p>在中文里面的<code>字</code>和<code>英文单词</code>是两个不同的东西。在读书的时候，最痛苦的一件事就是学习文言文，我想了一下，有大于等于三个原因：</p>\n<ol>\n<li>不知道在哪里断句</li>\n<li>字或词的含义很多</li>\n<li>这个字是通假字（它不是这个它，它是那个它），或者说纯粹就是写错了，但是细想一下也能读的通。</li>\n</ol>\n<p>我们常说中文博大精深，历史原因就不细究了，简单来说就是，我们的祖先在中文上的造诣非常高，好几层楼那么高，研究非常透彻，一句话能说出几个意思。我们自小在中文环境下成长，经过千锤百炼，读写是没问题的，但是计算机要怎么理解一句话呢？先从分词开始。</p>\n<p>计算机学习分词的过程，和人类是很像的（或许这是局限性），目前有几种：</p>\n<ol>\n<li>基于字符串匹配。按一定的策略在一个已分好词的大词典中搜寻，若找到则视为一个词。</li>\n<li>统计。大量已经分词的文本，利用统计机器学习模型学习词语切分的规律（训练），从而实现对未知文本的切分。</li>\n<li>组合。结合1、2点，如<code>结巴分词</code>。</li>\n</ol>\n<p>我们学习中文的时候，也有这样的过程，</p>\n<ol>\n<li>积累词语（建立词典）</li>\n<li>训练不同词语在不同句子中的含义的概率（权重），选择具有最大概率（权重）的含义的词语（动态规划，寻找切分组合）</li>\n</ol>\n<h2 id=\"结巴分词是什么？\"><a href=\"#结巴分词是什么？\" class=\"headerlink\" title=\"结巴分词是什么？\"></a>结巴分词是什么？</h2><p><code>结巴分词</code>是国内程序员用<code>python</code>开发的一个<code>中文</code>分词模块, 源码被托管在<a href=\"https://github.com/fxsjy/jieba\" target=\"_blank\" rel=\"noopener\">Github</a></p>\n<p>为了方便说明，下面截取了部分文档和例子。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>精确模式，试图将句子最精确地切开，适合文本分析</li>\n<li>全模式，把句子中所有可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义</li>\n<li>搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词</li>\n<li>支持繁体分词</li>\n<li>支持自定义词典</li>\n<li>MIT 授权协议</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># encoding=utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"></span><br><span class=\"line\">seg_list = jieba.cut(<span class=\"string\">\"我来到北京清华大学\"</span>, cut_all=<span class=\"literal\">True</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"Full Mode: \"</span> + <span class=\"string\">\"/ \"</span>.join(seg_list))  <span class=\"comment\"># 全模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">seg_list = jieba.cut(<span class=\"string\">\"我来到北京清华大学\"</span>, cut_all=<span class=\"literal\">False</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"Default Mode: \"</span> + <span class=\"string\">\"/ \"</span>.join(seg_list))  <span class=\"comment\"># 精确模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">seg_list = jieba.cut(<span class=\"string\">\"他来到了网易杭研大厦\"</span>)  <span class=\"comment\"># 默认是精确模式</span></span><br><span class=\"line\">print(<span class=\"string\">\", \"</span>.join(seg_list))</span><br><span class=\"line\"></span><br><span class=\"line\">seg_list = jieba.cut_for_search(<span class=\"string\">\"小明硕士毕业于中国科学院计算所，后在日本京都大学深造\"</span>)  <span class=\"comment\"># 搜索引擎模式</span></span><br><span class=\"line\">print(<span class=\"string\">\", \"</span>.join(seg_list))</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">【全模式】: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学</span><br><span class=\"line\"></span><br><span class=\"line\">【精确模式】: 我/ 来到/ 北京/ 清华大学</span><br><span class=\"line\"></span><br><span class=\"line\">【新词识别】：他, 来到, 了, 网易, 杭研, 大厦    (此处，“杭研”并没有在词典中，但是也被Viterbi算法识别出来了)</span><br><span class=\"line\"></span><br><span class=\"line\">【搜索引擎模式】： 小明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, 后, 在, 日本, 京都, 大学, 日本京都大学, 深造</span><br></pre></td></tr></table></figure>\n<h3 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><ol>\n<li>基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG)</li>\n<li>采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合</li>\n<li>对于未登录词，采用了基于汉字成词能力的 <code>HMM</code> 模型，使用了 <code>Viterbi</code> 算法</li>\n</ol>\n<p>针对结巴分词的原理，网上的文章写的非常详细了，这里就不再赘述了。有兴趣的读者可以看看</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/John_xyz/article/details/54645527\" target=\"_blank\" rel=\"noopener\">中文分词的基本原理以及jieba分词的用法</a></li>\n<li><a href=\"https://blog.csdn.net/u014365862/article/details/54891582\" target=\"_blank\" rel=\"noopener\">一个隐马尔科夫模型的应用实例：中文分词</a></li>\n</ol>\n<h2 id=\"PHP结巴分词库（扩展）\"><a href=\"#PHP结巴分词库（扩展）\" class=\"headerlink\" title=\"PHP结巴分词库（扩展）\"></a>PHP结巴分词库（扩展）</h2><p>有国人实现了PHP版本：</p>\n<ol>\n<li>PHP扩展：<a href=\"https://github.com/jonnywang/phpjieba\" target=\"_blank\" rel=\"noopener\">jonnywang/phpjieba</a></li>\n<li>PHP类库：<a href=\"https://github.com/fukuball/jieba-php\" target=\"_blank\" rel=\"noopener\">fukuball/jieba-php</a></li>\n</ol>\n<p>尤其是这个扩展<code>jonnywang/phpjieba</code>实现，<strong>支持PHP7</strong>，果断安装了。</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><h3 id=\"PHP-FPM模式\"><a href=\"#PHP-FPM模式\" class=\"headerlink\" title=\"PHP-FPM模式\"></a>PHP-FPM模式</h3><p>PHP的LNMP架构在Web开发领域常年占据一定的市场，那么是否可以使用结巴分词呢？当然可以，不过，我们知道在FPM模式下，PHP的生命周期非常短，前面我们了解到，结巴分词使用<code>前缀字典树</code>建立词库，该操作需要一定的时间和耗费内存（默认词典dict.txt占用将近1G）。那么，在常规FPM模式下，假设开启8个worker，那就需要大约8G内存分配。而且，在应对大量请求时，频繁的申请/销毁操作并不合理。所以，在FPM模式下，使用结巴分词不合适。</p>\n<h3 id=\"CLI模式\"><a href=\"#CLI模式\" class=\"headerlink\" title=\"CLI模式\"></a>CLI模式</h3><p>我们想到，和应用强耦合在一起不是个好办法，把结巴分词独立出来作为一个公共服务，通过不同的接口（HTTP，unixsocket）给其他应用提供服务是个不错的方案。</p>\n<p>在考察该方案前，我们需要解决几个问题：</p>\n<ol>\n<li>进程拉起才初始化词典</li>\n<li>为其他应用提供分词服务，需要应对高并发</li>\n<li>更新用户自定义词库</li>\n</ol>\n<p>我们第一时间想到了<a href=\"https://www.swoole.com/\" target=\"_blank\" rel=\"noopener\">Swoole</a>，有下面的优势：</p>\n<ol>\n<li>假设提供HTTP服务，可以在Worker进程启动时（onWorkerStart）初始化词典，当服务启动后，字典树就完全载入到内存中了，由于常驻内存，后面我们只需要处理请求（onRequest）即可。</li>\n<li>使用HTTP服务，可以为其他应用提供服务，而不需要每一个需要分词服务的应用都写一个类似的分词库。</li>\n<li>用户自定义词库需要在初始化词典阶段载入，因此，如果需要添加/删除自定义词库，需要做下面几步：<ul>\n<li>Process模式<ol>\n<li>服务启动时，记录Master进程ID到本地文件</li>\n<li>提供给外部应用增加/删除词的接口，写入用户自定义词库（user_dict.txt）文件</li>\n<li>Worker进程给Master进程发<code>SIGUSR1</code>信号，进行<strong>柔性重启</strong>（重启Worker进程）</li>\n</ol>\n</li>\n<li>Base模式<ul>\n<li>只有一个Worker进程，默认不开启Manager进程，所以需要自己终止掉，由外部来重启，如Supervisor</li>\n<li>大于等于两个Worker进程<ol>\n<li>服务启动时，记录Manager进程ID到本地文件</li>\n<li>同Process模式第2点</li>\n<li>同Process模式第3点</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>Base模式比Process模式少了两次ipc的过程，性能会更好些。</p>\n<h2 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h2><ul>\n<li>4c</li>\n<li>2g</li>\n</ul>\n<h3 id=\"Base-模式、1-Worker\"><a href=\"#Base-模式、1-Worker\" class=\"headerlink\" title=\"Base 模式、1 Worker\"></a>Base 模式、1 Worker</h3><ul>\n<li>请求：10000</li>\n<li>并发：1000</li>\n<li>api：a=2&amp;s=我爱中华民族、广东、美食</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Benchmarking 127.0.0.1 (be patient)</span><br><span class=\"line\">Completed 1000 requests</span><br><span class=\"line\">Completed 2000 requests</span><br><span class=\"line\">Completed 3000 requests</span><br><span class=\"line\">Completed 4000 requests</span><br><span class=\"line\">Completed 5000 requests</span><br><span class=\"line\">Completed 6000 requests</span><br><span class=\"line\">Completed 7000 requests</span><br><span class=\"line\">Completed 8000 requests</span><br><span class=\"line\">Completed 9000 requests</span><br><span class=\"line\">Completed 10000 requests</span><br><span class=\"line\">Finished 10000 requests</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Server Software:        swoole-http-server</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            9501</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        204 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      1000</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   8.499 seconds</span><br><span class=\"line\">Complete requests:      10000</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Keep-Alive requests:    10000</span><br><span class=\"line\">Total transferred:      3580000 bytes</span><br><span class=\"line\">Total body sent:        2180000</span><br><span class=\"line\">HTML transferred:       2040000 bytes</span><br><span class=\"line\">Requests per second:    1176.63 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       849.883 [ms] (mean)</span><br><span class=\"line\">Time per request:       0.850 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          411.36 [Kbytes/sec] received</span><br><span class=\"line\">                        250.49 kb/s sent</span><br><span class=\"line\">                        661.86 kb/s total</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    5  14.1      0      69</span><br><span class=\"line\">Processing:    29  800 181.2    840    1260</span><br><span class=\"line\">Waiting:        4  800 181.2    840    1260</span><br><span class=\"line\">Total:         30  805 174.0    840    1275</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%    840</span><br><span class=\"line\">  66%    855</span><br><span class=\"line\">  75%    866</span><br><span class=\"line\">  80%    870</span><br><span class=\"line\">  90%    894</span><br><span class=\"line\">  95%    912</span><br><span class=\"line\">  98%   1139</span><br><span class=\"line\">  99%   1214</span><br><span class=\"line\"> 100%   1275 (longest request)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Base-模式、2-Worker\"><a href=\"#Base-模式、2-Worker\" class=\"headerlink\" title=\"Base 模式、2 Worker\"></a>Base 模式、2 Worker</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Benchmarking 127.0.0.1 (be patient)</span><br><span class=\"line\">Completed 1000 requests</span><br><span class=\"line\">Completed 2000 requests</span><br><span class=\"line\">Completed 3000 requests</span><br><span class=\"line\">Completed 4000 requests</span><br><span class=\"line\">Completed 5000 requests</span><br><span class=\"line\">Completed 6000 requests</span><br><span class=\"line\">Completed 7000 requests</span><br><span class=\"line\">Completed 8000 requests</span><br><span class=\"line\">Completed 9000 requests</span><br><span class=\"line\">Completed 10000 requests</span><br><span class=\"line\">Finished 10000 requests</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Server Software:        swoole-http-server</span><br><span class=\"line\">Server Hostname:        127.0.0.1</span><br><span class=\"line\">Server Port:            9501</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        204 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      1000</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   4.746 seconds</span><br><span class=\"line\">Complete requests:      10000</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Keep-Alive requests:    10000</span><br><span class=\"line\">Total transferred:      3580000 bytes</span><br><span class=\"line\">Total body sent:        2180000</span><br><span class=\"line\">HTML transferred:       2040000 bytes</span><br><span class=\"line\">Requests per second:    2106.85 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       474.643 [ms] (mean)</span><br><span class=\"line\">Time per request:       0.475 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          736.57 [Kbytes/sec] received</span><br><span class=\"line\">                        448.53 kb/s sent</span><br><span class=\"line\">                        1185.10 kb/s total</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">              min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:        0    9  28.0      0     148</span><br><span class=\"line\">Processing:     0  415 407.8    421    1270</span><br><span class=\"line\">Waiting:        0  415 407.8    421    1270</span><br><span class=\"line\">Total:          0  423 409.2    443    1282</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">  50%    443</span><br><span class=\"line\">  66%    822</span><br><span class=\"line\">  75%    827</span><br><span class=\"line\">  80%    830</span><br><span class=\"line\">  90%    838</span><br><span class=\"line\">  95%    850</span><br><span class=\"line\">  98%   1157</span><br><span class=\"line\">  99%   1225</span><br><span class=\"line\"> 100%   1282 (longest request)</span><br></pre></td></tr></table></figure>","categories":["技术"],"tags":["PHP","Swoole","结巴分词"]},{"title":"php5解决laravel队列中的超时重试问题(hack)","url":"/2019/01/19/php5%E8%A7%A3%E5%86%B3laravel%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E9%97%AE%E9%A2%98(hack)/","content":"<h2 id=\"写在前\"><a href=\"#写在前\" class=\"headerlink\" title=\"写在前\"></a>写在前</h2><p>上一篇文章<a href=\"/2018/12/29/【Laravel】laravel队列中的timeout参数需要使用php7.1/\" title=\"laravel队列中的timeout参数需要使用php7.1\">laravel队列中的timeout参数需要使用php7.1</a>，最后结论时，我说这个问题只能升级php7.1才能解决，在今天的思考和实验中发现，还可以“曲线救国”！！啪啪打脸。</p>\n<p>上一篇文章，在读了laravel源码知道，在异步队列中，laravel使用了一个php7.1才有的函数<a href=\"http://php.net/manual/en/function.pcntl-async-signals.php\" target=\"_blank\" rel=\"noopener\">pcntl_async_signals</a>，这让我瞬间失去了所有想法，虽然升级PHP7是大趋势，但是有些依赖库可能在支持上还不完善。当然，大部分时候建议是升级的，PHP5很快就不进行安全维护了啊。</p>\n<a id=\"more\"></a>\n<h2 id=\"再探索\"><a href=\"#再探索\" class=\"headerlink\" title=\"再探索\"></a>再探索</h2><p>这个离线队列到底是怎么运行的？有兴趣的朋友可以看下陈昊写的<a href=\"https://blogoss.yinghualuo.cn/blog/2017/08/Laravel框架关键技术解析-陈昊.pdf\" target=\"_blank\" rel=\"noopener\">《laravel框架关键技术解析》</a>中13章【消息队列】，能够大致明白laravel程序消息队列的“前半部分”，为什么我说前半部分？接着看</p>\n<p>这部书讲了<strong>同步类型</strong>和<strong>数据库类型</strong>消息队列，接下来我要讲的是数据库类型里面的<strong>redis驱动类型</strong>以及<strong>worker处理程序</strong>这里面到底发生了什么事。</p>\n<p>laravel优秀的设计与机制给我们提供了很多最佳实践，这也意味着<strong>隐藏了不少黑盒子</strong>，有时候让人不痛快、不明所以。只能一边看源码、一边做实验、一边感叹XX。</p>\n<p>如果你已经了解了laravel队列的机制或者看完了<a href=\"https://blogoss.yinghualuo.cn/blog/2017/08/Laravel框架关键技术解析-陈昊.pdf\" target=\"_blank\" rel=\"noopener\">《laravel框架关键技术解析》</a>这本书，我想你已经明白消息的生成和发送。着重看下消息的处理</p>\n<p>如果你使用supervisor来管理队列程序，一般会开启多个worker</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">numprocs=8</span><br></pre></td></tr></table></figure>\n<p>假设有8个worker(1000，1001，…，1007)，后面再说下只有一个worker会发生什么</p>\n<p>当一个消息来了，会先在redis生成一个list，假设你的队列名称为queueA，就会生成一个名为<strong>queue:queueA</strong>的list，此时，worker1000就会从list中pop一个消息出来处理，把这个消息放入一个名为<strong>queues:queueA:reserved</strong>的zset中，即“保留消息有序集”。</p>\n<p>这时会有一堆信号注册，其中就包括timeout超时信号检测，如上篇文章所说，由于背景是php5，所以并不会注册异步信号，timeout参数就没用了，看下面的源码得知</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Enable async signals for the process.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> void</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listenForSignals</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">$this</span>-&gt;supportsAsyncSignals()) &#123;</span><br><span class=\"line\">            pcntl_async_signals(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            pcntl_signal(SIGTERM, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">$this</span>-&gt;shouldQuit = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            pcntl_signal(SIGUSR2, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">$this</span>-&gt;paused = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            pcntl_signal(SIGCONT, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">$this</span>-&gt;paused = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Register the worker timeout handler (PHP 7.1+).</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>  \\Illuminate\\Contracts\\Queue\\Job|null  $job</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span>  WorkerOptions  $options</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> void</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerTimeoutHandler</span><span class=\"params\">($job, WorkerOptions $options)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">$this</span>-&gt;supportsAsyncSignals()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We will register a signal handler for the alarm signal so that we can kill this</span></span><br><span class=\"line\">            <span class=\"comment\">// process if it is running too long because it has frozen. This uses the async</span></span><br><span class=\"line\">            <span class=\"comment\">// signals supported in recent versions of PHP to accomplish it conveniently.</span></span><br><span class=\"line\">            pcntl_signal(SIGALRM, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">$this</span>-&gt;kill(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            pcntl_alarm(</span><br><span class=\"line\">                max(<span class=\"keyword\">$this</span>-&gt;timeoutForJob($job, $options), <span class=\"number\">0</span>)</span><br><span class=\"line\">            );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Determine if \"async\" signals are supported.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> bool</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">supportsAsyncSignals</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> version_compare(PHP_VERSION, <span class=\"string\">'7.1.0'</span>) &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">               extension_loaded(<span class=\"string\">'pcntl'</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上篇文章就讲到了这里，我们接着看，既然timeout信号无效，任务过时了自然就不会终止，可是时间还在继续，走到了另一个参数retry_after到期要做的事情。</p>\n<blockquote>\n<p>为了避免任务被执行多次，retry_after参数要比timeout参数的值大一些</p>\n</blockquote>\n<p>这里假设<strong>timeout为10s，retry_after为15s，tries为3次</strong></p>\n<blockquote>\n<p>tries是max_tries，即任务执行次数</p>\n</blockquote>\n<p>worker1000检测到tries为3，也就是说，这任务能执行3次，就把任务信息中<strong>attempts改为1，原先是0</strong>，重新释放回队列中，看下面的代码。还没完，这任务还在执行呢….</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Get the Lua script for releasing reserved jobs.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[1] - The \"delayed\" queue we release jobs onto, for example: queues:foo:delayed</span></span><br><span class=\"line\"><span class=\"comment\">     * KEYS[2] - The queue the jobs are currently on, for example: queues:foo:reserved</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[1] - The raw payload of the job to add to the \"delayed\" queue</span></span><br><span class=\"line\"><span class=\"comment\">     * ARGV[2] - The UNIX timestamp at which the job should become available</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> string</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">release</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&lt;&lt;&lt;'LUA'</span></span><br><span class=\"line\"><span class=\"string\">-- Remove the job from the current queue...</span></span><br><span class=\"line\"><span class=\"string\">redis.call('zrem', KEYS[2], ARGV[1])</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">-- Add the job onto the \"delayed\" queue...</span></span><br><span class=\"line\"><span class=\"string\">redis.call('zadd', KEYS[1], ARGV[2], ARGV[1])</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">return true</span></span><br><span class=\"line\"><span class=\"string\">LUA;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>worker1001等呀等，终于等到了一个消息，就拿了执行了，和worker1000一样，到了retry_after的时候，把attempts改为2，又释放回去。</p>\n<p>worker1002同上，把attempts改为3，又释放回去。</p>\n<p>worker1003拿到后，一看，tries为3啊，已经不能再执行了，就抛异常<strong>Illuminate\\Queue\\MaxAttemptsExceededException</strong>，并说</p>\n<blockquote>\n<p>A queued job has been attempted too many times. The job may have previously timed out.</p>\n</blockquote>\n<p>然后，worker1003回调任务里面的failed方法，并终止任务逻辑</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 任务失败回调方法</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span>  Exception  $exception</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failed</span><span class=\"params\">(Exception $exception)</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>注意，此时worker1000、worker1001、worker1002还在执行….这是很可怕的，很容易引起<strong>资源泄露、依赖服务负载过大</strong>等问题。</p>\n<h2 id=\"“曲线救国”\"><a href=\"#“曲线救国”\" class=\"headerlink\" title=\"“曲线救国”\"></a>“曲线救国”</h2><p>上面介绍了laravel队列中worker运行原理，但是问题并没有得到解决。这么说来，升级PHP7应该是最好的办法，确实是的，但是根据laravel worker的运行机制，还能这么做，接着看</p>\n<p>利用laravel的<strong>重试</strong>机制和<strong>异常</strong>机制，我们可以这样设置</p>\n<ul>\n<li>tries=1</li>\n<li>timeout=10 (不变)</li>\n<li>retry_after=15 (不变)</li>\n</ul>\n<p>这样一来，worker1000在执行任务时，我们记录该进程的ID，保存起来，能够让别的进程获取到。在worker1001重试的时候，会报异常，因为tries已经是最大值了。此时，在异常回调函数中，我们把worker1000的进程ID取出来，kill掉，supervisor会重新拉起一个新的worker，问题就解决了！</p>\n<p>这个解决方案是不是特别有趣？:)</p>\n<h2 id=\"特殊情况：只有一个worker\"><a href=\"#特殊情况：只有一个worker\" class=\"headerlink\" title=\"特殊情况：只有一个worker\"></a>特殊情况：只有一个worker</h2><p>上面的解决方案是可行的，但是，这是建立在supervisor能维护worker池的前提下，如果打从一开始，就只有一个worker，这怎么办呢？</p>\n<p>这个问题让人吐血，因为真实的情况是，只有一个worker的情况下，会忽略掉retry_after，并不会释放任务，更别提报异常了，一股脑的往下执行….</p>\n","categories":["技术"],"tags":["PHP","Laravel"]},{"title":"【PHP7】- 编译安装与新特性初体验","url":"/2015/12/03/%E3%80%90PHP7%E3%80%91-%20%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E4%B8%8E%E6%96%B0%E7%89%B9%E6%80%A7%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天是世界上最好的语言革命性的一天，PHP7问世了！实际上我使用php只有一年半多一点，但是却被深深地吸引住，所以也容我感慨一下吧。</p>\n<p>大一下学期，我们学校开始教Java（我的专业方向就是Java），那时班上的很多同学早在上学期就自学了Java，而且学的非常好。我跟着课程的进度一步步的下载，安装，配置环境，然后写一些简单的程序，调试。这个过程非常煎熬，因为在配置环境的时候就出现了很多问题，使用eclipse来写代码，由于当时电脑配置并不好，所以写代码的时候总是会出现“未响应”，然后卡顿很长时间，更不用说MyEclipse了。苦闷的心情还历历在目~</p>\n<p>当时学校还为我们开设了一门PHP课程，我第一次使用的时候感觉很神奇，弱类型的概念还不是很清晰，只是觉得不需要再去考虑变量的类型，php为我们都处理好了。而且网上PHP的环境非常多，其中xampp就是一个著名的跨平台环境，一键安装，可以马上看到自己的代码运行的结果，我可以更关注自己写的逻辑和正确性，不得不说实在是太好用了。最后这门课需要结合另一门jQuery课做一个课程设计，我一个星期就敲出来了，还为我们赢得了不少掌声。就这样，一直用到现在，与php牵连在了一起。</p>\n<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><ul>\n<li>Ubuntu 14.04</li>\n</ul>\n<h3 id=\"准备PHP源码\"><a href=\"#准备PHP源码\" class=\"headerlink\" title=\"准备PHP源码\"></a>准备PHP源码</h3><p><a href=\"http://php.net/get/php-7.0.0.tar.gz/from/a/mirror\" target=\"_blank\" rel=\"noopener\">http://php.net/get/php-7.0.0.tar.gz/from/a/mirror</a></p>\n<p>1.解压源码并重命名为php-7<br>2.安装依赖项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install libxml2-dev</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装依赖项\"><a href=\"#安装依赖项\" class=\"headerlink\" title=\"安装依赖项\"></a>安装依赖项</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get  install  build-essential</span><br><span class=\"line\">sudo apt-get install openssl </span><br><span class=\"line\">sudo apt-get install libssl-dev </span><br><span class=\"line\">sudo apt-get install make</span><br><span class=\"line\">sudo apt-get install curl</span><br><span class=\"line\">sudo apt-get install libcurl4-gnutls-dev</span><br><span class=\"line\">sudo apt-get install libjpeg-dev</span><br><span class=\"line\">sudo apt-get install libpng-dev</span><br><span class=\"line\">sudo apt-get install libmcrypt-dev</span><br><span class=\"line\">sudo apt-get install libreadline6 libreadline6-dev</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译配置\"><a href=\"#编译配置\" class=\"headerlink\" title=\"编译配置\"></a>编译配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./configure（注意斜杠前的点）</span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/php --with-config-file-path=/usr/<span class=\"built_in\">local</span>/php/etc --<span class=\"built_in\">enable</span>-fpm --with-fpm-user=www --with-fpm-group=www --with-mysqli --with-pdo-mysql --with-iconv-dir --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --<span class=\"built_in\">enable</span>-xml --<span class=\"built_in\">disable</span>-rpath --<span class=\"built_in\">enable</span>-bcmath --<span class=\"built_in\">enable</span>-shmop --<span class=\"built_in\">enable</span>-sysvsem --<span class=\"built_in\">enable</span>-inline-optimization --with-curl --<span class=\"built_in\">enable</span>-mbregex --<span class=\"built_in\">enable</span>-mbstring --with-mcrypt --<span class=\"built_in\">enable</span>-ftp --with-gd --<span class=\"built_in\">enable</span>-gd-native-ttf --with-openssl --with-mhash --<span class=\"built_in\">enable</span>-pcntl --<span class=\"built_in\">enable</span>-sockets --with-xmlrpc --<span class=\"built_in\">enable</span>-zip --<span class=\"built_in\">enable</span>-soap --without-pear --with-gettext --<span class=\"built_in\">disable</span>-fileinfo --<span class=\"built_in\">enable</span>-maintainer-zts  </span><br><span class=\"line\"></span><br><span class=\"line\">./configure --prefix=/usr/<span class=\"built_in\">local</span>/php --<span class=\"built_in\">enable</span>-fpm --<span class=\"built_in\">enable</span>-inline-optimization --<span class=\"built_in\">disable</span>-debug --<span class=\"built_in\">disable</span>-rpath --<span class=\"built_in\">enable</span>-shared --<span class=\"built_in\">enable</span>-opcache  --with-mysql --with-mysqli --with-mysql-sock  --<span class=\"built_in\">enable</span>-pdo --with-pdo-mysql --with-gettext --<span class=\"built_in\">enable</span>-mbstring --with-iconv --with-mcrypt --with-mhash --with-openssl --<span class=\"built_in\">enable</span>-bcmath --<span class=\"built_in\">enable</span>-soap --with-libxml-dir --<span class=\"built_in\">enable</span>-pcntl --<span class=\"built_in\">enable</span>-shmop --<span class=\"built_in\">enable</span>-sysvmsg --<span class=\"built_in\">enable</span>-sysvsem --<span class=\"built_in\">enable</span>-sysvshm --<span class=\"built_in\">enable</span>-sockets --with-curl --with-zlib --<span class=\"built_in\">enable</span>-zip --<span class=\"built_in\">enable</span>-bz2 --with-readline --without-sqlite3 --without-pdo-sqlite --with-pear --with-libdir=/lib/x86_64-linux-gnu --with-gd --with-jpeg-dir=/usr/lib --<span class=\"built_in\">enable</span>-gd-native-ttf --<span class=\"built_in\">enable</span>-xml</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装-PHP\"><a href=\"#安装-PHP\" class=\"headerlink\" title=\"安装 PHP\"></a>安装 PHP</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make <span class=\"built_in\">test</span>      （这个过程可能会慢一点，视配置而定，我的虚拟机为单处理器+2G内存）</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/php7新特性与初体验/20151203232056485.jpg\" alt></p>\n<p>这里可能会出现这个问题，save一下就好了，也就是输入字母s即可，如果开源精神爆棚（我我我），可以输入y，然后输入自己的邮箱。啦啦啦~</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; sudo make install   （这里可能需要输入你的root账户密码）</span><br><span class=\"line\">php -v</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/php7新特性与初体验/20151203232255760.jpg\" alt></p>\n<p>到这里已经完成php7的安装，接下来就可以尽情的使用PHP7了！</p>\n<h2 id=\"PHP7新特性\"><a href=\"#PHP7新特性\" class=\"headerlink\" title=\"PHP7新特性\"></a>PHP7新特性</h2><p>php7与以前的版本相比有哪些让人兴奋的新特性，我们来体验一番~</p>\n<h3 id=\"宇宙飞船运算符\"><a href=\"#宇宙飞船运算符\" class=\"headerlink\" title=\"宇宙飞船运算符\"></a>宇宙飞船运算符</h3><p>新增运算符Combined comparison Operator ‘&lt;=&gt;’ 吼吼~</p>\n<p><img src=\"/images/php7新特性与初体验/20151203231855632.jpg\" alt></p>\n<p>代码变少了，小于则返回-1，大于返回1，等于返回0，简单易懂，非常爽~</p>\n<h3 id=\"Return-Type-Declarations\"><a href=\"#Return-Type-Declarations\" class=\"headerlink\" title=\"Return Type Declarations\"></a>Return Type Declarations</h3><p>返回类型声明 和Scalar Type Declarations 标量类型声明</p>\n<p><img src=\"/images/php7新特性与初体验/20151203231720195.jpg\" alt></p>\n<p>对于C/C++/java系的看到这个肯定开心爆了，还可以通过declare(strict_type = 1);开启严格模式，这时php将不会帮你自动转换类型，而是报错。</p>\n<h3 id=\"更多的Error变为可捕获的Exception\"><a href=\"#更多的Error变为可捕获的Exception\" class=\"headerlink\" title=\"更多的Error变为可捕获的Exception\"></a>更多的Error变为可捕获的Exception</h3><p><img src=\"/images/php7新特性与初体验/20151203231410865.jpg\" alt></p>\n<p>在php7前未定义函数是致命错误Fatal error，这样会使整个脚本中止，程序无法继续运行下去。但是现在可以通过捕获错误-&gt;处理错误，让程序继续执行下去，大大提高了异常处理能力。</p>\n<h3 id=\"性能提升\"><a href=\"#性能提升\" class=\"headerlink\" title=\"性能提升\"></a>性能提升</h3><p><img src=\"/images/php7新特性与初体验/20151203231219865.png\" alt></p>\n<p>可以看出，php7比php5提高不止100%的性能。升级后该省多少机器啊！</p>\n<h2 id=\"最后再说两句\"><a href=\"#最后再说两句\" class=\"headerlink\" title=\"最后再说两句\"></a>最后再说两句</h2><p>听说PHP7.1将会重启JIT计划，PHP本来就不适合密集计算，开启JIT后，性能，效率又会有多大的提升？很难想象~再加上swoole，yaf等等优秀的开源框架，PHP社区只会越来越繁荣。简单，门槛低，性能好，这应该就是未来编程语言的走向，人人编程的设想也不会是梦吧~</p>\n<p>感谢开源，感谢自己的坚持~</p>\n<p>本文所有例子皆得到验证，亲测可用。</p>\n<p>本文安装教程参考了<a href=\"http://www.oschina.net/question/2010961_242272\" target=\"_blank\" rel=\"noopener\">http://www.oschina.net/question/2010961_242272</a></p>\n<p>本文PHP7新特性参考了鸟哥的分享与博客<a href=\"http://www.laruence.com/\" target=\"_blank\" rel=\"noopener\">http://www.laruence.com/</a></p>\n","categories":["技术"],"tags":["PHP","PHP7"]},{"title":"socket.io-swoole-server：基于swoole实现socket.io协议","url":"/2019/11/03/socket.io-swoole-server/","content":"<h2 id=\"框架获取\"><a href=\"#框架获取\" class=\"headerlink\" title=\"框架获取\"></a>框架获取</h2><p><a href=\"https://github.com/funsoul/socket.io-swoole-server\" target=\"_blank\" rel=\"noopener\">socket.io-swoole-server</a></p>\n<a id=\"more\"></a>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p><img src=\"https://travis-ci.org/funsoul/socket.io-swoole-server.svg?branch=master\" alt=\"Build Status\"><br><img src=\"https://img.shields.io/badge/PHP-%3E%3D7.1.0-green\" alt><br><img src=\"https://img.shields.io/badge/Swoole-%3E%3D4.0.3-green\" alt><br><img src=\"https://img.shields.io/github/license/funsoul/socket.io-swoole-server\" alt></p>\n<h2 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h2><h3 id=\"Server-Config\"><a href=\"#Server-Config\" class=\"headerlink\" title=\"Server Config\"></a>Server Config</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$config = <span class=\"keyword\">new</span> SocketIO\\Engine\\Server\\ConfigPayload();</span><br><span class=\"line\">$config</span><br><span class=\"line\">    <span class=\"comment\">// server worker_num</span></span><br><span class=\"line\">    -&gt;setWorkerNum(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">// server daemonize</span></span><br><span class=\"line\">    -&gt;setDaemonize(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$io = <span class=\"keyword\">new</span> SocketIO\\Server(<span class=\"number\">9501</span>, $config, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(SocketIO\\Server $io)</span> </span>&#123;</span><br><span class=\"line\">    $io-&gt;on(<span class=\"string\">'connection'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(SocketIO\\Server $socket)</span> </span>&#123;</span><br><span class=\"line\">        $socket-&gt;on(<span class=\"string\">'new message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(SocketIO\\Server $socket)</span> </span>&#123;</span><br><span class=\"line\">            $socket-&gt;broadcast(<span class=\"string\">'new message'</span>, $socket-&gt;getMessage());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        $socket-&gt;on(<span class=\"string\">'new user'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(SocketIO\\Server $socket)</span> </span>&#123;</span><br><span class=\"line\">            $socket-&gt;broadcast(<span class=\"string\">'login'</span>, $socket-&gt;getMessage());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        $socket-&gt;on(<span class=\"string\">'disconnect'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(SocketIO\\Server $socket)</span> </span>&#123;</span><br><span class=\"line\">            $socket-&gt;broadcast(<span class=\"string\">'user left'</span>, $socket-&gt;getMessage());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$io-&gt;start();</span><br></pre></td></tr></table></figure>","categories":["项目"],"tags":["PHP","Swoole","Socket.io"]},{"title":"laravel队列中的timeout参数需要使用php7.1","url":"/2018/12/29/%E3%80%90Laravel%E3%80%91laravel%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84timeout%E5%8F%82%E6%95%B0%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8php7.1/","content":"<h2 id=\"timeout解释\"><a href=\"#timeout解释\" class=\"headerlink\" title=\"timeout解释\"></a>timeout解释</h2><p><a href=\"https://laravel-china.org/docs/laravel/5.4/queues/1256#job-expirations-and-timeouts\" target=\"_blank\" rel=\"noopener\">job-expirations-and-timeouts</a></p>\n<a id=\"more\"></a>\n<h3 id=\"任务过期-amp-超时\"><a href=\"#任务过期-amp-超时\" class=\"headerlink\" title=\"任务过期 &amp; 超时\"></a>任务过期 &amp; 超时</h3><h4 id=\"任务过期\"><a href=\"#任务过期\" class=\"headerlink\" title=\"任务过期\"></a>任务过期</h4><blockquote>\n<p>config/queue.php 配置文件里，每一个队列连接都定义了一个 retry_after 选项。这个选项指定了任务最多处理多少秒后就被当做失败重试了。比如说，如果这个选项设置为 90，那么当这个任务持续执行了 90 秒而没有被删除，那么它将被释放回队列。通常情况下，你应该把 retry_after 设置为最长耗时的任务所对应的时间。<br>{note} 唯一没有 retry_after 选项的连接是 Amazon SQS。当用 Amazon SQS 时，你必须通过 Amazon 命令行来配置这个重试阈值。</p>\n</blockquote>\n<h2 id=\"版本\"><a href=\"#版本\" class=\"headerlink\" title=\"版本\"></a>版本</h2><ul>\n<li>php 5.6.30</li>\n<li>laravel 5.4.*</li>\n</ul>\n<h2 id=\"laravel5-4源码\"><a href=\"#laravel5-4源码\" class=\"headerlink\" title=\"laravel5.4源码\"></a>laravel5.4源码</h2><p><a href=\"https://github.com/laravel/framework/blob/5.4/src/Illuminate/Queue/Worker.php\" target=\"_blank\" rel=\"noopener\">Worker</a></p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">* Register the worker timeout handler (PHP 7.1+).</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> \\Illuminate\\Contracts\\Queue\\Job|null $job</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> WorkerOptions $options</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> void</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerTimeoutHandler</span><span class=\"params\">($job, WorkerOptions $options)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">$this</span>-&gt;supportsAsyncSignals()) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// We will register a signal handler for the alarm signal so that we can kill this</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// process if it is running too long because it has frozen. This uses the async</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// signals supported in recent versions of PHP to accomplish it conveniently.</span></span><br><span class=\"line\">\t\tpcntl_signal(SIGALRM, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">$this</span>-&gt;kill(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tpcntl_alarm(</span><br><span class=\"line\">\t\t\tmax(<span class=\"keyword\">$this</span>-&gt;timeoutForJob($job, $options), <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">* Determine if \"async\" signals are supported.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span> bool</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">supportsAsyncSignals</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> version_compare(PHP_VERSION, <span class=\"string\">'7.1.0'</span>) &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\textension_loaded(<span class=\"string\">'pcntl'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试结论\"><a href=\"#测试结论\" class=\"headerlink\" title=\"测试结论\"></a>测试结论</h2><ol>\n<li>php5.6，无法使用timeout属性</li>\n<li>任务进入重试后，相关参数就全部失效了，如tries，因此长耗时任务会一直跑</li>\n<li>tries为0时，会陷入无限重试。此时，必须要把redis中“queues:【这里是你的queue名称】:reserved”删除才能终止</li>\n<li>上面的设置中，retry_after比timeout大一些，在timeout无效后，任务会进行retry（丢回队列，由其他worker接管执行，这时会出现第2点的问题），当重试次数达到设定值时，原进程就会异常退出，报【A queued job has been attempted too many times. The job may have previously timed out】错误。</li>\n</ol>\n<p>上面的问题都是因为，php5不支持timeout……..看来要使用这个参数，必须要升级到php7.1了….</p>\n","categories":["技术"],"tags":["PHP","Laravel"]},{"title":"【PHP-ML】解决NLP中文文本分类问题","url":"/2019/11/30/%E3%80%90PHP-ML%E3%80%91%E8%A7%A3%E5%86%B3NLP%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/","content":"<h2 id=\"php-ml\"><a href=\"#php-ml\" class=\"headerlink\" title=\"php-ml\"></a>php-ml</h2><p><a href=\"https://php-ml.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\">php-ml</a>是波兰开发者<a href=\"https://arkadiuszkondas.com/\" target=\"_blank\" rel=\"noopener\">Arkadiusz Kondas</a>的作品，前段时间刚翻译了他关于PHP在机器学习领域的看法「3 Reasons Why PHP is Not Yet Perfect for Machine Learning」。php-ml的出现丰富了PHP生态，让PHP开发者也能写机器学习应用，这篇文章讲一讲文本分类问题在php-ml中是怎么解决的。</p>\n<a id=\"more\"></a>\n<p>本文的实践例子已经放在Github：<a href=\"https://github.com/funsoul/php-text-classification\" target=\"_blank\" rel=\"noopener\">php-text-classification</a></p>\n<h2 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h2><p>本文采用<a href=\"https://github.com/fatecbf/toutiao-text-classfication-dataset\" target=\"_blank\" rel=\"noopener\">头条新闻数据集</a></p>\n<ul>\n<li>数据规模：共382688条，分布于15个分类中。</li>\n<li>采集时间：2018年05月</li>\n</ul>\n<p>分类code与名称：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span> 民生 故事 news_story</span><br><span class=\"line\"><span class=\"number\">101</span> 文化 文化 news_culture</span><br><span class=\"line\"><span class=\"number\">102</span> 娱乐 娱乐 news_entertainment</span><br><span class=\"line\"><span class=\"number\">103</span> 体育 体育 news_sports</span><br><span class=\"line\"><span class=\"number\">104</span> 财经 财经 news_finance</span><br><span class=\"line\"><span class=\"number\">106</span> 房产 房产 news_house</span><br><span class=\"line\"><span class=\"number\">107</span> 汽车 汽车 news_car</span><br><span class=\"line\"><span class=\"number\">108</span> 教育 教育 news_edu </span><br><span class=\"line\"><span class=\"number\">109</span> 科技 科技 news_tech</span><br><span class=\"line\"><span class=\"number\">110</span> 军事 军事 news_military</span><br><span class=\"line\"><span class=\"number\">112</span> 旅游 旅游 news_travel</span><br><span class=\"line\"><span class=\"number\">113</span> 国际 国际 news_world</span><br><span class=\"line\"><span class=\"number\">114</span> 证券 股票 stock</span><br><span class=\"line\"><span class=\"number\">115</span> 农业 三农 news_agriculture</span><br><span class=\"line\"><span class=\"number\">116</span> 电竞 游戏 news_game</span><br></pre></td></tr></table></figure>\n<h2 id=\"Classification\"><a href=\"#Classification\" class=\"headerlink\" title=\"Classification\"></a>Classification</h2><p>php-ml有多种文本分类模型</p>\n<ul>\n<li>SVM（依赖libsvm库）</li>\n<li>KNN</li>\n<li>NavieBayes</li>\n<li>MLPClassifier</li>\n</ul>\n<h2 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h2><p>php-ml对分类模型保持高度一致的接口，定义了统一的输入和输出。下面的代码贯穿全文，只需要选取合适的模型，把样本数据集<code>Samples</code>和类别对象<code>Labels</code>灌入训练API，即可进行训练。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$samples = [[<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>], [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>]];</span><br><span class=\"line\">$labels = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">$classifier = <span class=\"keyword\">new</span> ClassificationModel();</span><br><span class=\"line\">$classifier-&gt;train($samples, $labels);</span><br></pre></td></tr></table></figure>\n<p>在这里，ClassificationModel可以是SVM，也可以KNN或者其他分类模型。区别在于，各模型存在算法、核函数或超参差异。当进行深度拟合数据、提高模型分类效果时，可进行调整。然而，php-ml没有交叉验证或者网格搜索等方法，需要自己设计程序进行调参。</p>\n<p>回到主题，我们需要把不同类别的中文文本数据进行训练，中文文本的<code>形式化处理</code>是关键。</p>\n<p>先看原始数据形式，截取第一条数据出来</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6551700932705387022</span>_!_101_!_news_culture_!_京城最值得你来场文化之旅的博物馆_!_保利集团,马未都,中国科学技术馆,博物馆,新中国</span><br></pre></td></tr></table></figure>\n<p>数据以<code>_!_</code>分隔，对本文来说，需要获取类别ID、类别名称和句子，如下：</p>\n<ul>\n<li>category_id: 101</li>\n<li>category_name: news_culture</li>\n<li>text: 京城最值得你来场文化之旅的博物馆</li>\n</ul>\n<p>读取文件，进行分词和停用词过滤后，得到如下的数据结构</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  [</span><br><span class=\"line\">    category_id: <span class=\"number\">101</span>,</span><br><span class=\"line\">    category_name: news_culture,</span><br><span class=\"line\">    text: 京城最值得你来场文化之旅的博物馆</span><br><span class=\"line\">  ]</span><br><span class=\"line\">  <span class=\"comment\">// 此处省略382687行</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h2 id=\"特征提取\"><a href=\"#特征提取\" class=\"headerlink\" title=\"特征提取\"></a>特征提取</h2><h3 id=\"分词\"><a href=\"#分词\" class=\"headerlink\" title=\"分词\"></a>分词</h3><p>分词方式有多种：</p>\n<ol>\n<li>直接调用php jieba分词库<a href=\"https://github.com/fukuball/jieba-php\" target=\"_blank\" rel=\"noopener\">fukuball/jieba-php</a></li>\n<li>直接调用php jieba分词扩展<a href=\"https://github.com/jonnywang/phpjieba\" target=\"_blank\" rel=\"noopener\">jonnywang/phpjieba</a></li>\n<li>使用swoole+jieba分词，提供一个http服务。参考之前写的这篇文章<a href=\"/2019/08/14/Swoole加速结巴分词/\" title=\"Swoole加速结巴分词\">Swoole加速结巴分词</a></li>\n<li>使用python+aiohttp+jieba</li>\n</ol>\n<h3 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h3><ol>\n<li>停用词过滤，可以使用<a href=\"https://github.com/goto456/stopwords\" target=\"_blank\" rel=\"noopener\">goto456/stopwords</a></li>\n<li>对于英文文本，单个字符会被过滤。对于中文同样适用，单个词没有太大意义</li>\n</ol>\n<h3 id=\"语料库（词袋）\"><a href=\"#语料库（词袋）\" class=\"headerlink\" title=\"语料库（词袋）\"></a>语料库（词袋）</h3><p>进行分词和过滤后，将获得特征。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[&apos;京城&apos;, &apos;值得&apos;,  &apos;来场&apos; , &apos;文化&apos;, &apos;之旅&apos;, &apos;博物馆&apos;]</span><br></pre></td></tr></table></figure>\n<p>将特征以空格分隔，合并成句子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">京城 值得 来场 文化 之旅 博物馆</span><br></pre></td></tr></table></figure>\n<p>使用<code>WhitespaceTokenizer</code>进行文本样本集的向量化</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$vectorizer = <span class=\"keyword\">new</span> TokenCountVectorizer(<span class=\"keyword\">new</span> WhitespaceTokenizer());</span><br><span class=\"line\">$vectorizer-&gt;fit($trainX);</span><br><span class=\"line\">$vectorizer-&gt;transform($trainX);</span><br></pre></td></tr></table></figure>\n<p>词袋</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$vectorizer-&gt;getVocabulary();</span><br><span class=\"line\"><span class=\"comment\">// ['之旅', '京城', '值得', '博物馆', '文化', '来场']</span></span><br></pre></td></tr></table></figure>\n<p>语料库</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[<span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span>]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"TF-IDF\"><a href=\"#TF-IDF\" class=\"headerlink\" title=\"TF-IDF\"></a>TF-IDF</h3><blockquote>\n<p>tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</p>\n</blockquote>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$transformer = <span class=\"keyword\">new</span> TfIdfTransformer($trainX);</span><br><span class=\"line\">$transformer-&gt;transform($trainX);</span><br></pre></td></tr></table></figure>\n<p>在这里，由于只有一句话，且这句话里面所有的字词都只有一个，所以权重是一样的。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">[[<span class=\"number\">0.40824829</span> <span class=\"number\">0.40824829</span> <span class=\"number\">0.40824829</span> <span class=\"number\">0.40824829</span> <span class=\"number\">0.40824829</span> <span class=\"number\">0.40824829</span>]]</span><br></pre></td></tr></table></figure>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p>进行特征处理后的<code>特征集</code>和<code>类别对象</code>传入模型的构造方法，即可进行训练。注意，这里可以对比<code>未使用tfidf</code>和<code>使用tfidf</code>前后的效果。</p>\n<p>这里使用朴素贝叶斯举例：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$model = <span class=\"keyword\">new</span> NaiveBayes($trainX, $trainY),</span><br><span class=\"line\">$classifier = $model-&gt;train();</span><br></pre></td></tr></table></figure>\n<h2 id=\"预测\"><a href=\"#预测\" class=\"headerlink\" title=\"预测\"></a>预测</h2><p>准备新的样本文本，并进行分词、过滤和特征提取后，传入即可</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$classifier-&gt;predict($testSample);</span><br></pre></td></tr></table></figure>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>如果想要保存训练结果，避免多次训练，可以将模型持久化到本地。需要使用时，将模型重新导入内存即可使用。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模型导出</span></span><br><span class=\"line\">$filepath = <span class=\"string\">'/path/to/store/the/model'</span>;</span><br><span class=\"line\">$modelManager = <span class=\"keyword\">new</span> ModelManager();</span><br><span class=\"line\">$modelManager-&gt;saveToFile($classifier, $filepath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模型导入</span></span><br><span class=\"line\">$restoredClassifier = $modelManager-&gt;restoreFromFile($filepath);</span><br><span class=\"line\">$restoredClassifier-&gt;predict([<span class=\"number\">3</span>, <span class=\"number\">2</span>]);</span><br></pre></td></tr></table></figure>\n<h2 id=\"评估指标（Metric）\"><a href=\"#评估指标（Metric）\" class=\"headerlink\" title=\"评估指标（Metric）\"></a>评估指标（Metric）</h2><p>仓库代码中，我将样本通过<code>StratifiedRandomSplit</code>划分为<code>训练集</code>和<code>测试集</code>，用于评估模型效果。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$split = <span class=\"keyword\">new</span> StratifiedRandomSplit($dataset, <span class=\"number\">0.2</span>);</span><br></pre></td></tr></table></figure>\n<p>对测试集进行预测</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$predictY = [];</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($testX <span class=\"keyword\">as</span> $test) &#123;</span><br><span class=\"line\">    $testSampleText = [$test];</span><br><span class=\"line\"></span><br><span class=\"line\">    $vectorizer-&gt;transform($testSampleText);</span><br><span class=\"line\"></span><br><span class=\"line\">    $predictY[] = current($classifier-&gt;predict($testSampleText));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Score\"><a href=\"#Score\" class=\"headerlink\" title=\"Score\"></a>Score</h3><p>通过<code>Accuracy</code>得到预测结果的正确率</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">Accuracy::score($testY, $predictY)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Confusion-Matrix\"><a href=\"#Confusion-Matrix\" class=\"headerlink\" title=\"Confusion Matrix\"></a>Confusion Matrix</h3><p>通过<code>ConfusionMatrix</code>得到预测结果的错误情况</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$text = <span class=\"keyword\">new</span> Text($textFile);</span><br><span class=\"line\">$categoryIds = $text-&gt;getCategoryIds();</span><br><span class=\"line\">ConfusionMatrix::compute($testY, $predictY, $categoryIds);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Classification-Report\"><a href=\"#Classification-Report\" class=\"headerlink\" title=\"Classification Report\"></a>Classification Report</h3><p>通过<code>ClassificationReport</code>得到整体分类报告（score、f1、recall）</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$report = <span class=\"keyword\">new</span> ClassificationReport($testY, $predictY);</span><br><span class=\"line\">$report-&gt;getAverage();</span><br></pre></td></tr></table></figure>\n<h2 id=\"Pipeline\"><a href=\"#Pipeline\" class=\"headerlink\" title=\"Pipeline\"></a>Pipeline</h2><p>还可以使用<code>Pipeline</code>来管线化工作流，有两个好处：</p>\n<ol>\n<li>代码少很多，阅读更清晰</li>\n<li>内存占用更低</li>\n</ol>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$transformers = [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> TokenCountVectorizer(<span class=\"keyword\">new</span> WhitespaceTokenizer()),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> TfIdfTransformer()</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">$pipeline = <span class=\"keyword\">new</span> Pipeline($transformers, <span class=\"keyword\">new</span> NaiveBayes());</span><br><span class=\"line\">$pipeline-&gt;train($trainX, $trainY);</span><br><span class=\"line\">$predictY = $pipeline-&gt;predict($testX);</span><br><span class=\"line\">Accuracy::score($testY, $predictY);</span><br></pre></td></tr></table></figure>","categories":["技术"],"tags":["PHP","PHP-ML","机器学习","NLP","文本分类"]},{"title":"funtask：又一个多任务处理框架","url":"/2018/07/29/%E3%80%90funtask%E3%80%91%E5%8F%88%E4%B8%80%E4%B8%AA%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6/","content":"<h2 id=\"框架获取\"><a href=\"#框架获取\" class=\"headerlink\" title=\"框架获取\"></a>框架获取</h2><p><a href=\"https://github.com/funsoul/funtask\" title=\"funtask\" target=\"_blank\" rel=\"noopener\">funtask</a></p>\n<a id=\"more\"></a>\n<h2 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h2><ol>\n<li>2018-07-29 Swoole1.0简单版生产消费模型，采用多进程模式</li>\n<li>2019-04-25 采用Swoole4重构进程池（退出重启），增加进程组（退出不重启）</li>\n<li>2019-05-06 支持协程Coroutine</li>\n</ol>\n<h2 id=\"使用例子\"><a href=\"#使用例子\" class=\"headerlink\" title=\"使用例子\"></a>使用例子</h2><h3 id=\"耗时任务例子\"><a href=\"#耗时任务例子\" class=\"headerlink\" title=\"耗时任务例子\"></a>耗时任务例子</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">Funsoul</span>\\<span class=\"title\">Funtask</span>\\<span class=\"title\">Process</span>\\<span class=\"title\">JobInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * business job</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> bool [exit process or not]</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span><span class=\"params\">()</span>: <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $pid = getmypid();</span><br><span class=\"line\"></span><br><span class=\"line\">        $i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        $running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ($running) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"&#123;$pid&#125;: \"</span> . $i++ . PHP_EOL;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ($i == <span class=\"number\">5</span>)</span><br><span class=\"line\">                $running = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// exit current process</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ProcessPool进程池\"><a href=\"#ProcessPool进程池\" class=\"headerlink\" title=\"ProcessPool进程池\"></a>ProcessPool进程池</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$task = <span class=\"keyword\">new</span> \\Funsoul\\Funtask\\Funtask();</span><br><span class=\"line\">$task-&gt;setType(<span class=\"string\">'POOL'</span>)</span><br><span class=\"line\">    -&gt;setJob(<span class=\"keyword\">new</span> Consumer())</span><br><span class=\"line\">    -&gt;setWorkerNum(<span class=\"number\">3</span>)</span><br><span class=\"line\">    -&gt;setWorkerName(<span class=\"string\">'myWorker'</span>)</span><br><span class=\"line\">    -&gt;start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"ProcessGroup进程组\"><a href=\"#ProcessGroup进程组\" class=\"headerlink\" title=\"ProcessGroup进程组\"></a>ProcessGroup进程组</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$task = <span class=\"keyword\">new</span> \\Funsoul\\Funtask\\Funtask();</span><br><span class=\"line\">$task-&gt;setType(<span class=\"string\">'GROUP'</span>)</span><br><span class=\"line\">    -&gt;setJob(<span class=\"keyword\">new</span> Consumer())</span><br><span class=\"line\">    -&gt;setWorkerNum(<span class=\"number\">3</span>)</span><br><span class=\"line\">    -&gt;setWorkerName(<span class=\"string\">'myWorker'</span>)</span><br><span class=\"line\">    -&gt;start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"Coroutine协程\"><a href=\"#Coroutine协程\" class=\"headerlink\" title=\"Coroutine协程\"></a>Coroutine协程</h3><h4 id=\"协程任务例子\"><a href=\"#协程任务例子\" class=\"headerlink\" title=\"协程任务例子\"></a>协程任务例子</h4><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumerCo</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">Funsoul</span>\\<span class=\"title\">Funtask</span>\\<span class=\"title\">Coroutine</span>\\<span class=\"title\">CoJobInterface</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> \\Swoole\\Http\\Request $request</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> mixed|void</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span><span class=\"params\">(\\Swoole\\Http\\Request $request)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $cid = Co::getuid();</span><br><span class=\"line\"></span><br><span class=\"line\">        $i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        $running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ($running) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"&#123;$cid&#125;: \"</span> . $i++ . PHP_EOL;</span><br><span class=\"line\"></span><br><span class=\"line\">            Co::sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ($i == <span class=\"number\">5</span>)</span><br><span class=\"line\">                $running = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"funtask统一接口\"><a href=\"#funtask统一接口\" class=\"headerlink\" title=\"funtask统一接口\"></a>funtask统一接口</h4><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$task = <span class=\"keyword\">new</span> \\Funsoul\\Funtask\\Funtask();</span><br><span class=\"line\">$task-&gt;setType(<span class=\"string\">'CO'</span>)-&gt;setCoJob(<span class=\"keyword\">new</span> ConsumerCo())-&gt;setWorkerNum(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">/** var \\Swoole\\Http\\Response $response */</span></span><br><span class=\"line\">$task-&gt;setFinishCallback(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">($response)</span> </span>&#123;</span><br><span class=\"line\">\t$response-&gt;end(<span class=\"string\">'finished'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$task-&gt;start();</span><br></pre></td></tr></table></figure>\n<h4 id=\"coroutine接口\"><a href=\"#coroutine接口\" class=\"headerlink\" title=\"coroutine接口\"></a>coroutine接口</h4><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$co = <span class=\"keyword\">new</span> \\Funsoul\\Funtask\\Coroutine\\Coroutine();</span><br><span class=\"line\">$co-&gt;setHost(<span class=\"string\">'127.0.0.1'</span>)</span><br><span class=\"line\">    -&gt;setPort(<span class=\"number\">9501</span>)</span><br><span class=\"line\">    -&gt;setWorkerNum(<span class=\"number\">1</span>)</span><br><span class=\"line\">    -&gt;setCoNum(<span class=\"number\">3</span>)</span><br><span class=\"line\">    -&gt;setJob(<span class=\"keyword\">new</span> ConsumerCo());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** var \\Swoole\\Http\\Response $response */</span></span><br><span class=\"line\">$co-&gt;start(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">($response)</span> </span>&#123;</span><br><span class=\"line\">\t$response-&gt;end(<span class=\"string\">\"finished!\\n\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","categories":["项目"],"tags":["PHP","Swoole","多任务处理"]},{"title":"下载大文件时不得不了解nginx的一个配置","url":"/2019/02/14/%E3%80%90nginx%E3%80%91fastcgi_max_tmp_file_size/","content":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>laravel下载大文件服务，浏览器无法承载大文件下载，会崩溃。改为提供api，外部使用curl或者wget等工具下载。为什么没用scp呢？因为服务器权限问题，这个功能是为了解决浏览器下载大文件崩溃而生的。</p>\n<a id=\"more\"></a>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>大文件下载遇到的问题，每次下载到1024M的时候，就自动停了。</p>\n<h2 id=\"解决过程\"><a href=\"#解决过程\" class=\"headerlink\" title=\"解决过程\"></a>解决过程</h2><ol>\n<li>curl的问题，加上-C参数，提供断点续传。无效</li>\n<li>wget，同上，到了1024M就自动停了</li>\n<li>laravel的问题，并不是，symfony有很好的文件响应组件</li>\n<li>php的问题，没有这样的配置</li>\n<li>php-fpm的问题，同上，没有这样的配置</li>\n<li>nginx的问题，是的！</li>\n</ol>\n<h2 id=\"fastcgi-max-temp-file-size默认为1024M\"><a href=\"#fastcgi-max-temp-file-size默认为1024M\" class=\"headerlink\" title=\"fastcgi_max_temp_file_size默认为1024M\"></a>fastcgi_max_temp_file_size默认为1024M</h2><p>配置说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">When buffering of responses from the FastCGI server is enabled, and the whole response does not fit into the buffers set by the fastcgi_buffer_size and fastcgi_buffers directives, a part of the response can be saved to a temporary file. This directive sets the maximum size of the temporary file. The size of data written to the temporary file at a time is set by the fastcgi_temp_file_write_size directive.</span><br><span class=\"line\">The zero value disables buffering of responses to temporary files.</span><br><span class=\"line\">This restriction does not apply to responses that will be cached or stored on disk.</span><br></pre></td></tr></table></figure>\n<p>改大一点，解决~</p>\n","categories":["技术"],"tags":["nginx"]},{"title":"用shc保护你的敏感信息","url":"/2019/02/14/%E3%80%90shell%E3%80%91shc%E5%8A%A0%E5%AF%86/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>有个功能是在web下载大文件，但是太大的文件，在浏览器下载会崩溃。想了下，能不能改为API的方式，使用CURL来下载？</p>\n<p>一开始不想暴露api，这个api不常用，因为绕过了用户会话（不用登陆），并不安全，如果被恶意利用：数据会被泄露，服务器会被拖慢等等安全隐患。</p>\n<p>于是想过把通过shell文件，把api放在里面，然后使用shc来加密shell文件为二进制文件。这样一来，api就“看不到”了，有一定的安全性，只要不被反编译，应该是目前最可靠的方法。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装shc\"><a href=\"#安装shc\" class=\"headerlink\" title=\"安装shc\"></a>安装shc</h2><p>root用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># wget http://www.datsi.fi.upm.es/~frosal/sources/shc-3.8.3.tgz</span><br><span class=\"line\"># tar -zxvf shc-3.8.3.tgz</span><br><span class=\"line\"># cd shc-3.8.3</span><br><span class=\"line\"># make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p><strong>这里会让你确认，千万别直接enter，而是输入y，enter</strong></p>\n<h2 id=\"使用shc\"><a href=\"#使用shc\" class=\"headerlink\" title=\"使用shc\"></a>使用shc</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">shc -v -r -T -f xxx.sh</span><br></pre></td></tr></table></figure>\n<p>这里也有坑，不用-T的话，是没办法执行的。</p>\n<p>然后会生成两个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xxx.sh.x  --- 二进制文件</span><br><span class=\"line\">xxx.sh.x.c  --- C文件，可删除</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用二进制\"><a href=\"#使用二进制\" class=\"headerlink\" title=\"使用二进制\"></a>使用二进制</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x xxx.sh.x</span><br><span class=\"line\">rname xxx.sh （重命名）</span><br><span class=\"line\">./xxx.sh</span><br></pre></td></tr></table></figure>\n<p>windows下，是执行不了这个二进制文件的，需要使用cygwin或者windows子系统才可以。想过直接用gcc编译c文件，但是会报错，应该是格式原因，还是得在windows下执行shc。</p>\n<h2 id=\"curl注意事项\"><a href=\"#curl注意事项\" class=\"headerlink\" title=\"curl注意事项\"></a>curl注意事项</h2><p>如果想要在windows下执行curl，如果链接里面有&amp;符号是有问题的，需要把整个链接用引号包起来才可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl &quot;https://aa.com/api/excel/download?token=xx&amp;file=xx.csv&quot; &gt;&gt; xx.csv</span><br></pre></td></tr></table></figure>","categories":["技术"],"tags":["shell"]},{"title":"【问题排查】PHP-FPM模式下提示缺失lib","url":"/2017/12/14/%E3%80%90%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E3%80%91PHP-FPM%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%8F%90%E7%A4%BA%E7%BC%BA%E5%A4%B1lib/","content":"<h2 id=\"php-fpm-conf\"><a href=\"#php-fpm-conf\" class=\"headerlink\" title=\"php-fpm.conf\"></a>php-fpm.conf</h2><p>设置worker为1，方便strace</p>\n<a id=\"more\"></a>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">global</span>]</span><br><span class=\"line\">pid = /usr/local/php/var/run/php-fpm.pid</span><br><span class=\"line\">error_log = /usr/local/php/var/<span class=\"built_in\">log</span>/php-fpm.<span class=\"built_in\">log</span></span><br><span class=\"line\">log_level = notice</span><br><span class=\"line\">[www]</span><br><span class=\"line\">listen = /tmp/php-cgi.sock</span><br><span class=\"line\">listen.backlog = -<span class=\"number\">1</span></span><br><span class=\"line\">listen.allowed_clients = <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span></span><br><span class=\"line\">listen.owner = www</span><br><span class=\"line\">listen.group = www</span><br><span class=\"line\">listen.<span class=\"keyword\">mode</span> = <span class=\"number\">0666</span></span><br><span class=\"line\">user = www</span><br><span class=\"line\">group = www</span><br><span class=\"line\">pm = static</span><br><span class=\"line\">pm.max_children = <span class=\"number\">1</span></span><br><span class=\"line\">pm.start_servers = <span class=\"number\">1</span></span><br><span class=\"line\">pm.min_spare_servers = <span class=\"number\">1</span></span><br><span class=\"line\">pm.max_spare_servers = <span class=\"number\">1</span></span><br><span class=\"line\">request_terminate_timeout = <span class=\"number\">100</span></span><br><span class=\"line\">request_slowlog_timeout = <span class=\"number\">0</span></span><br><span class=\"line\">slowlog = var/<span class=\"built_in\">log</span>/slow.<span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ps-ef-grep-php-fpm\"><a href=\"#ps-ef-grep-php-fpm\" class=\"headerlink\" title=\"ps -ef | grep php-fpm\"></a>ps -ef | grep php-fpm</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">root       6598      1  0 10:45 ?        00:00:00 php-fpm: master process (/usr/<span class=\"built_in\">local</span>/php/etc/php-fpm.conf)                                                                    </span><br><span class=\"line\">www        6599   6598  0 10:45 ?        00:00:00 php-fpm: pool www</span><br></pre></td></tr></table></figure>\n<h2 id=\"sudo-strace-p-6599\"><a href=\"#sudo-strace-p-6599\" class=\"headerlink\" title=\"sudo strace -p 6599\"></a>sudo strace -p 6599</h2><p>查看worker进程系统调用，找到问题行</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/lib64/tls/libssl.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory) </span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/lib64/libssl.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory) </span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/usr/lib64/tls/libssl.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory) </span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/usr/lib64/libssl.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory</span><br></pre></td></tr></table></figure>\n<p>发现系统中确实没有libssl.so.1.0.0，只有libssl.so.1.0.1e，一般而言都会向下兼容，设置软链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ln -s /usr/lib64/libssl.so.1.0.1e /usr/lib64/tls/libssl.so.1.0.0</span><br></pre></td></tr></table></figure>\n<p>再次执行，刚刚出现的“libssl”缺失已经不见了，出现了新的lib缺失</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/lib64/tls/libcrypto.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/lib64/libcrypto.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/usr/lib64/tls/libcrypto.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br><span class=\"line\"><span class=\"keyword\">open</span>(<span class=\"string\">\"/usr/lib64/libcrypto.so.1.0.0\"</span>, O_RDONLY) = -<span class=\"number\">1</span> ENOENT (No such <span class=\"keyword\">file</span> <span class=\"built_in\">or</span> directory)</span><br></pre></td></tr></table></figure>\n<p>同上，找到系统中存在的libcrypto.so.1.0.1e，并设置软链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ln -s /usr/lib64/libcrypto.so.1.0.1e /usr/lib64/libcrypto.so.1.0.0</span><br></pre></td></tr></table></figure>\n<p>问题解决~ :)</p>\n","categories":["技术"],"tags":["问题排查","PHP"]},{"title":"【字符编码】PHP导出CSV中文乱码问题研究","url":"/2018/02/02/%E3%80%90%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E3%80%91PHP%E5%AF%BC%E5%87%BACSV%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6/","content":"<p>没有踩过字符编码问题的程序生涯是不完整的，还记得曾经还踩过Apache+PHP+MySQL的编码问题，不过那时候没总结下来，今天遇到了导出文件的编码问题，一起来好好研究一下:)</p>\n<p>推荐一下这篇文章<a href=\"http://cenalulu.github.io/linux/character-encoding/\" title=\"十分钟搞清字符集和字符编码\" target=\"_blank\" rel=\"noopener\">十分钟搞清字符集和字符编码</a>，可以快速了解一下字符编码的知识</p>\n<a id=\"more\"></a>\n<h3 id=\"业务背景\"><a href=\"#业务背景\" class=\"headerlink\" title=\"业务背景\"></a>业务背景</h3><p>把数据查询结果导出到CSV，由于Laravel Excel内部实现方法的问题，载入大数据量时，容易爆内存，因此这里分了两种实现，小数据量则采用Laravel Excel，大数据量则使用无缓冲查询+Yield，详情可参考这篇文章<a href=\"http://funsoul.org/2018/02/01/【Yield】大数据下的应用/\" title=\"【Yield】大数据下的应用\">【Yield】大数据下的应用</a></p>\n<p>由于使用了Laravel Excel工具集，先来看看这个工具内部是如何实现编码兼容的<br><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ..\\vendor\\maatwebsite\\excel\\src\\Maatwebsite\\Excel\\Writers\\LaravelExcelWriter.php</span></span><br><span class=\"line\"><span class=\"comment\"># 约347行</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_download</span><span class=\"params\">(Array $headers = [])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Set the headers</span></span><br><span class=\"line\">    <span class=\"keyword\">$this</span>-&gt;_setHeaders(</span><br><span class=\"line\">        $headers,</span><br><span class=\"line\">        [</span><br><span class=\"line\">            <span class=\"string\">'Content-Type'</span>        =&gt; <span class=\"keyword\">$this</span>-&gt;contentType,</span><br><span class=\"line\">            <span class=\"string\">'Content-Disposition'</span> =&gt; <span class=\"string\">'attachment; filename=\"'</span> . <span class=\"keyword\">$this</span>-&gt;filename . <span class=\"string\">'.'</span> . <span class=\"keyword\">$this</span>-&gt;ext . <span class=\"string\">'\"'</span>,</span><br><span class=\"line\">            <span class=\"string\">'Expires'</span>             =&gt; <span class=\"string\">'Mon, 26 Jul 1997 05:00:00 GMT'</span>, <span class=\"comment\">// Date in the past</span></span><br><span class=\"line\">            <span class=\"string\">'Last-Modified'</span>       =&gt; Carbon::now()-&gt;format(<span class=\"string\">'D, d M Y H:i:s'</span>),</span><br><span class=\"line\">            <span class=\"string\">'Cache-Control'</span>       =&gt; <span class=\"string\">'cache, must-revalidate'</span>,</span><br><span class=\"line\">            <span class=\"string\">'Pragma'</span>              =&gt; <span class=\"string\">'public'</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ..</span><br><span class=\"line\">    .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过区分不同的文件类型设置$this-&gt;contentType，但是这里是用来设置浏览器下载的header的，并不是保存为服务器文件，继续找。</p>\n<h3 id=\"查看PHPExcel对CSV格式的兼容性实现\"><a href=\"#查看PHPExcel对CSV格式的兼容性实现\" class=\"headerlink\" title=\"查看PHPExcel对CSV格式的兼容性实现\"></a>查看PHPExcel对CSV格式的兼容性实现</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ..\\vendor\\phpoffice\\phpexcel\\Classes\\PHPExcel\\Writer\\CSV.php</span></span><br><span class=\"line\"><span class=\"comment\"># 约116行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">$this</span>-&gt;_excelCompatibility) &#123;</span><br><span class=\"line\">\tfwrite($fileHandle, <span class=\"string\">\"\\xEF\\xBB\\xBF\"</span>);\t<span class=\"comment\">//\tEnforce UTF-8 BOM Header</span></span><br><span class=\"line\">\t<span class=\"keyword\">$this</span>-&gt;setEnclosure(<span class=\"string\">'\"'</span>);\t\t\t\t<span class=\"comment\">//\tSet enclosure to \"</span></span><br><span class=\"line\">\t<span class=\"keyword\">$this</span>-&gt;setDelimiter(<span class=\"string\">\";\"</span>);\t\t\t    <span class=\"comment\">//\tSet delimiter to a semi-colon</span></span><br><span class=\"line\">    <span class=\"keyword\">$this</span>-&gt;setLineEnding(<span class=\"string\">\"\\r\\n\"</span>);</span><br><span class=\"line\">\tfwrite($fileHandle, <span class=\"string\">'sep='</span> . <span class=\"keyword\">$this</span>-&gt;getDelimiter() . <span class=\"keyword\">$this</span>-&gt;_lineEnding);</span><br><span class=\"line\">&#125; <span class=\"keyword\">elseif</span> (<span class=\"keyword\">$this</span>-&gt;_useBOM) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Write the UTF-8 BOM code if required</span></span><br><span class=\"line\">\tfwrite($fileHandle, <span class=\"string\">\"\\xEF\\xBB\\xBF\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发现$this-&gt;_useBOM这个配置项，默认是没有开启的。查看使用LaravelExcel下载的CSV文件的BOM确实没有支持UTF-8</p>\n<h3 id=\"laravel-Excel配置开启use-bom\"><a href=\"#laravel-Excel配置开启use-bom\" class=\"headerlink\" title=\"laravel Excel配置开启use_bom\"></a>laravel Excel配置开启use_bom</h3><p>config/excel.php，设置csv的use_bom为true，默认为false</p>\n<h3 id=\"查看BOM\"><a href=\"#查看BOM\" class=\"headerlink\" title=\"查看BOM\"></a>查看BOM</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">]$ head -c 3 file | hexdump -C</span><br><span class=\"line\"></span><br><span class=\"line\">00000000  ef bb bf                                          |...|</span><br><span class=\"line\">00000003</span><br></pre></td></tr></table></figure>\n<p>找到问题的关键了，在需要写入文件前，添加UTF-8的BOM即可<br><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">fwrite($fp, <span class=\"string\">\"\\xEF\\xBB\\xBF\"</span>); <span class=\"comment\">// 添加 UTF-8 BOM</span></span><br></pre></td></tr></table></figure></p>\n","categories":["技术"],"tags":["PHP","乱码"]},{"title":"Redis：排查 read error on connection 小记","url":"/2019/08/13/%E3%80%90Redis%E3%80%91brpop%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6/","content":"<h2 id=\"从错误说起\"><a href=\"#从错误说起\" class=\"headerlink\" title=\"从错误说起\"></a>从错误说起</h2><p>版本信息</p>\n<ul>\n<li>php-7.1.x</li>\n<li><a href=\"https://github.com/phpredis/phpredis/tree/4.0.2\" target=\"_blank\" rel=\"noopener\">phpredis-4.0.x</a></li>\n</ul>\n<p>一个<code>PHP常驻内存进程</code>，连上<code>Redis</code>后，定时做<code>brpop</code>操作，阻塞时间为<code>10s</code>。问题出现在，几天（不定时）后，该进程就会<br><code>僵死</code>，表现为：</p>\n<a id=\"more\"></a>\n<ol>\n<li><code>netstat</code>下，php进程与redis建立的客户端连接仍在（ESTABLISHED)</li>\n<li>在客户机<code>tcpdump</code>，没有输出任何数据包信息（没有通信？)</li>\n<li><code>strace</code>该php进程，并没有输出任何系统调用（阻塞在哪了？）</li>\n<li>查看redis-server，发现<code>client list</code>中，并不存在该client（被移除了？）</li>\n</ol>\n<h2 id=\"phpredis客户端连接为何不断？\"><a href=\"#phpredis客户端连接为何不断？\" class=\"headerlink\" title=\"phpredis客户端连接为何不断？\"></a>phpredis客户端连接为何不断？</h2><p>关于phpredis连接，有下面几个地方需要理解清楚</p>\n<ol>\n<li>connect() 函数参数 timeout 为 0</li>\n<li>ini_set(‘default_socket_timeout’, -1)</li>\n<li>setOption(\\Redis::OPT_READ_TIMEOUT, -1)</li>\n<li>pconnect</li>\n</ol>\n<h3 id=\"connect-函数参数-timeout\"><a href=\"#connect-函数参数-timeout\" class=\"headerlink\" title=\"connect 函数参数 timeout\"></a>connect 函数参数 timeout</h3><p>参数：</p>\n<ul>\n<li><em>host</em>: string. can be a host, or the path to a unix domain socket. Starting from version 5.0.0 it is possible to specify schema </li>\n<li><em>port</em>: int, optional  </li>\n<li><em>timeout</em>: float, value in seconds (optional, default is 0 meaning unlimited)  </li>\n<li><em>reserved</em>: should be NULL if retry_interval is specified  </li>\n<li><em>retry_interval</em>: int, value in milliseconds (optional)  </li>\n<li><em>read_timeout</em>: float, value in seconds (optional, default is 0 meaning unlimited)</li>\n</ul>\n<p>这里的<code>timeout</code>表示<code>建立连接</code>时的超时时间，调用此函数时，客户端将与服务端进行三次握手，建立TCP连接。由于网络原因，可以指定一个超时时间，意思是，如果客户端和服务端在该<code>时间限制</code>内未能建立连接，则返回false</p>\n<p>文件：redis.c 行：935</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">PHP_METHOD(Redis, connect)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class=\"number\">0</span>) == FAILURE) &#123;</span><br><span class=\"line\">        RETURN_FALSE;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        RETURN_TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，redis_connect的函数原型为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">PHP_REDIS_API <span class=\"keyword\">int</span> <span class=\"title\">redis_connect</span><span class=\"params\">(INTERNAL_FUNCTION_PARAMETERS, <span class=\"keyword\">int</span> persistent)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>persistent 为 <code>0</code> 表示不建立<code>持久连接</code>，下面会聊到<code>等于 1</code>的情况。说明<code>connect</code>函数建立的是<code>短连接</code>，当调用<code>close</code>函数时，连接就会关闭。看下面的源码确实如此，如果在建立连接前已经存在另一个连接，则关闭。</p>\n<p>文件：redis.c 行：1011</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis = PHPREDIS_GET_OBJECT(redis_object, object);</span><br><span class=\"line\"><span class=\"comment\">/* if there is a redis sock already we have to remove it */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (redis-&gt;sock) &#123;</span><br><span class=\"line\">    redis_sock_disconnect(redis-&gt;sock, <span class=\"number\">0</span>);</span><br><span class=\"line\">    redis_free_socket(redis-&gt;sock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"default-socket-timeout\"><a href=\"#default-socket-timeout\" class=\"headerlink\" title=\"default_socket_timeout\"></a>default_socket_timeout</h3><p>这个配置可以在php.ini找到，文档注释很简单：<code>基于 socket 的流的默认超时时间（秒）</code></p>\n<p>redis是基于<code>tcp协议</code>的程序，所以这个配置也会对其造成影响。比如<code>read error on connection</code>错误，这是phpredis在执行get、brpop等操作时，如果在<code>default_socket_timeout</code>时间内不返回结果就会报这个错误。php.ini中默认为<code>60s</code>。可以在程序中使用内置函数<code>ini_set</code>在运行时修改。</p>\n<h3 id=\"OPT-READ-TIMEOUT\"><a href=\"#OPT-READ-TIMEOUT\" class=\"headerlink\" title=\"OPT_READ_TIMEOUT\"></a>OPT_READ_TIMEOUT</h3><p>phpredis版本的“default_socket_timeout”，通过这个值，一样可以达到同样的效果。那么如果同时设置了<code>default_socket_timeout</code>和<code>OPT_READ_TIMEOUT</code>，优先级是怎样的？</p>\n<p>实测发现，<strong>如果同时存在两个配置，优先使用<code>OPT_READ_TIMEOUT</code>的配置</strong>，这样是合理的。</p>\n<p>文件：redis_commands.c 行：3980</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> REDIS_OPT_READ_TIMEOUT:</span><br><span class=\"line\">    redis_sock-&gt;read_timeout = zval_get_double(val);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis_sock-&gt;stream) &#123;</span><br><span class=\"line\">        read_tv.tv_sec  = (<span class=\"keyword\">time_t</span>)redis_sock-&gt;read_timeout;</span><br><span class=\"line\">        read_tv.tv_usec = (<span class=\"keyword\">int</span>)((redis_sock-&gt;read_timeout -</span><br><span class=\"line\">                                    read_tv.tv_sec) * <span class=\"number\">1000000</span>);</span><br><span class=\"line\">        php_stream_set_option(redis_sock-&gt;stream,</span><br><span class=\"line\">                                PHP_STREAM_OPTION_READ_TIMEOUT, <span class=\"number\">0</span>,</span><br><span class=\"line\">                                &amp;read_tv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RETURN_TRUE;</span><br></pre></td></tr></table></figure>\n<h2 id=\"pconnect的原理是什么？\"><a href=\"#pconnect的原理是什么？\" class=\"headerlink\" title=\"pconnect的原理是什么？\"></a>pconnect的原理是什么？</h2><p>文件：redis.c 行：947</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">PHP_METHOD(Redis, pconnect)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class=\"number\">1</span>) == FAILURE) &#123;</span><br><span class=\"line\">        RETURN_FALSE;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        RETURN_TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>建立连接时，先到<code>连接池</code>获取连接（最后一个），并移除最后一个连接实例。如果连接是活跃的（PHP_STREAM_OPTION_CHECK_LIVENESS），则直接返回。如果连接已失效，则建立新的连接。</p>\n<p>文件：library.c 行：1828</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (redis_sock-&gt;persistent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INI_INT(<span class=\"string\">\"redis.pconnect.pooling_enabled\"</span>)) &#123;</span><br><span class=\"line\">        p = redis_sock_get_connection_pool(redis_sock);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zend_llist_count(&amp;p-&gt;<span class=\"built_in\">list</span>) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            redis_sock-&gt;stream = *(php_stream **)zend_llist_get_last(&amp;p-&gt;<span class=\"built_in\">list</span>);</span><br><span class=\"line\">            zend_llist_remove_tail(&amp;p-&gt;<span class=\"built_in\">list</span>);</span><br><span class=\"line\">            <span class=\"comment\">/* Check socket liveness using 0 second timeout */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (php_stream_set_option(redis_sock-&gt;stream, PHP_STREAM_OPTION_CHECK_LIVENESS, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>) == PHP_STREAM_OPTION_RETURN_OK) &#123;</span><br><span class=\"line\">                redis_sock-&gt;status = REDIS_SOCK_STATUS_CONNECTED;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            php_stream_pclose(redis_sock-&gt;stream);</span><br><span class=\"line\">            p-&gt;nb_active--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> limit = INI_INT(<span class=\"string\">\"redis.pconnect.connection_limit\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (limit &gt; <span class=\"number\">0</span> &amp;&amp; p-&gt;nb_active &gt;= limit) &#123;</span><br><span class=\"line\">            redis_sock_set_err(redis_sock, <span class=\"string\">\"Connection limit reached\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"Connection limit reached\"</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> FAILURE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        gettimeofday(&amp;tv, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        persistent_id = strpprintf(<span class=\"number\">0</span>, <span class=\"string\">\"phpredis_%ld%ld\"</span>, tv.tv_sec, tv.tv_usec);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (redis_sock-&gt;persistent_id) &#123;</span><br><span class=\"line\">            persistent_id = strpprintf(<span class=\"number\">0</span>, <span class=\"string\">\"phpredis:%s:%s\"</span>, host, ZSTR_VAL(redis_sock-&gt;persistent_id));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            persistent_id = strpprintf(<span class=\"number\">0</span>, <span class=\"string\">\"phpredis:%s:%f\"</span>, host, redis_sock-&gt;timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    tv.tv_sec  = (<span class=\"keyword\">time_t</span>)redis_sock-&gt;timeout;</span><br><span class=\"line\">    tv.tv_usec = (<span class=\"keyword\">int</span>)((redis_sock-&gt;timeout - tv.tv_sec) * <span class=\"number\">1000000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tv.tv_sec != <span class=\"number\">0</span> || tv.tv_usec != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        tv_ptr = &amp;tv;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    redis_sock-&gt;stream = php_stream_xport_create(host, host_len,</span><br><span class=\"line\">        <span class=\"number\">0</span>, STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,</span><br><span class=\"line\">        persistent_id ? ZSTR_VAL(persistent_id) : <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        tv_ptr, <span class=\"literal\">NULL</span>, &amp;estr, &amp;err);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (persistent_id) &#123;</span><br><span class=\"line\">        zend_string_release(persistent_id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!redis_sock-&gt;stream) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (estr) &#123;</span><br><span class=\"line\">            redis_sock_set_err(redis_sock, ZSTR_VAL(estr), ZSTR_LEN(estr));</span><br><span class=\"line\">            zend_string_release(estr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p) p-&gt;nb_active++;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Attempt to set TCP_NODELAY/TCP_KEEPALIVE if we're not using a unix socket. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!usocket) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">php_netstream_data_t</span> *sock = (<span class=\"keyword\">php_netstream_data_t</span>*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">        err = setsockopt(sock-&gt;socket, IPPROTO_TCP, TCP_NODELAY, (<span class=\"keyword\">char</span>*) &amp;tcp_flag, <span class=\"keyword\">sizeof</span>(tcp_flag));</span><br><span class=\"line\">        PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">        err = setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (<span class=\"keyword\">char</span>*) &amp;redis_sock-&gt;tcp_keepalive, <span class=\"keyword\">sizeof</span>(redis_sock-&gt;tcp_keepalive));</span><br><span class=\"line\">        PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    php_stream_auto_cleanup(redis_sock-&gt;stream);</span><br><span class=\"line\"></span><br><span class=\"line\">    read_tv.tv_sec  = (<span class=\"keyword\">time_t</span>)redis_sock-&gt;read_timeout;</span><br><span class=\"line\">    read_tv.tv_usec = (<span class=\"keyword\">int</span>)((redis_sock-&gt;read_timeout - read_tv.tv_sec) * <span class=\"number\">1000000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (read_tv.tv_sec != <span class=\"number\">0</span> || read_tv.tv_usec != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        php_stream_set_option(redis_sock-&gt;stream,PHP_STREAM_OPTION_READ_TIMEOUT,</span><br><span class=\"line\">            <span class=\"number\">0</span>, &amp;read_tv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    php_stream_set_option(redis_sock-&gt;stream,</span><br><span class=\"line\">        PHP_STREAM_OPTION_WRITE_BUFFER, PHP_STREAM_BUFFER_NONE, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    redis_sock-&gt;status = REDIS_SOCK_STATUS_CONNECTED;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点来了，注意看上面代码中这一段，先卖个关子，后面聊<code>tcp_keepalive</code>的时候会着重分析</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Attempt to set TCP_NODELAY/TCP_KEEPALIVE if we're not using a unix socket. */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!usocket) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">php_netstream_data_t</span> *sock = (<span class=\"keyword\">php_netstream_data_t</span>*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">    err = setsockopt(sock-&gt;socket, IPPROTO_TCP, TCP_NODELAY, (<span class=\"keyword\">char</span>*) &amp;tcp_flag, <span class=\"keyword\">sizeof</span>(tcp_flag));</span><br><span class=\"line\">    PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">    err = setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (<span class=\"keyword\">char</span>*) &amp;redis_sock-&gt;tcp_keepalive, <span class=\"keyword\">sizeof</span>(redis_sock-&gt;tcp_keepalive));</span><br><span class=\"line\">    PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"redis-server为什么会移除client？\"><a href=\"#redis-server为什么会移除client？\" class=\"headerlink\" title=\"redis-server为什么会移除client？\"></a>redis-server为什么会移除client？</h2><p>先回顾一下TCP协议是怎么<code>keepalive</code>（保活）的。</p>\n<h3 id=\"模拟tcp-keepalive\"><a href=\"#模拟tcp-keepalive\" class=\"headerlink\" title=\"模拟tcp keepalive\"></a>模拟tcp keepalive</h3><ul>\n<li>服务端：nc</li>\n<li>客户端：<a href=\"https://github.com/cyberelf/netcat-keepalive\" target=\"_blank\" rel=\"noopener\">netcat-keepalive</a></li>\n</ul>\n<h3 id=\"开始通信\"><a href=\"#开始通信\" class=\"headerlink\" title=\"开始通信\"></a>开始通信</h3><p>开启一个TCP服务端</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nc -lp 9999</span><br></pre></td></tr></table></figure>\n<p>启动一个客户端，连接服务端</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./nckl-linux -K -O 15 -I 5 -P 5 127.0.0.1 9999</span><br></pre></td></tr></table></figure>\n<p>netcat-keepalive的使用参数</p>\n<ul>\n<li>-K Turn on TCP Keepalive</li>\n<li>-O secs TCP keepalive timeout</li>\n<li>-I secs TCP keepalive interval</li>\n<li>-P count TCP keepalive probe count</li>\n</ul>\n<p>如果不设置，默认为<code>系统的默认配置</code>，如linux下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl -a | grep keepalive</span><br></pre></td></tr></table></figure>\n<ul>\n<li>net.ipv4.tcp_keepalive_time = 7200</li>\n<li>net.ipv4.tcp_keepalive_probes = 9</li>\n<li>net.ipv4.tcp_keepalive_intvl = 75</li>\n</ul>\n<p>使用tcpdump查看发包情况</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">15</span>:<span class=\"number\">24.852471</span> IP localhost.<span class=\"number\">45698</span> &gt; localhost.<span class=\"number\">9999</span>: Flags [S], seq <span class=\"number\">253066745</span>, win <span class=\"number\">43690</span>, <span class=\"keyword\">options</span> [mss <span class=\"number\">65495</span>,sackOK,TS val <span class=\"number\">23438901</span> ecr <span class=\"number\">0</span>,nop,wscale <span class=\"number\">7</span>], length <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">15</span>:<span class=\"number\">24.852510</span> IP localhost.<span class=\"number\">9999</span> &gt; localhost.<span class=\"number\">45698</span>: Flags [S.], seq <span class=\"number\">2889588682</span>, ack <span class=\"number\">253066746</span>, win <span class=\"number\">43690</span>, <span class=\"keyword\">options</span> [mss <span class=\"number\">65495</span>,sackOK,TS val <span class=\"number\">23438901</span> ecr <span class=\"number\">23438901</span>,nop,wscale <span class=\"number\">7</span>], length <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">15</span>:<span class=\"number\">24.852542</span> IP localhost.<span class=\"number\">45698</span> &gt; localhost.<span class=\"number\">9999</span>: Flags [.], ack <span class=\"number\">1</span>, win <span class=\"number\">342</span>, <span class=\"keyword\">options</span> [nop,nop,TS val <span class=\"number\">23438901</span> ecr <span class=\"number\">23438901</span>], length <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">15</span>:<span class=\"number\">32.933719</span> IP localhost.<span class=\"number\">45698</span> &gt; localhost.<span class=\"number\">9999</span>: Flags [<span class=\"keyword\">P</span>.], seq <span class=\"number\">1</span>:<span class=\"number\">3</span>, ack <span class=\"number\">1</span>, win <span class=\"number\">342</span>, <span class=\"keyword\">options</span> [nop,nop,TS val <span class=\"number\">23439709</span> ecr <span class=\"number\">23438901</span>], length <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">15</span>:<span class=\"number\">32.933814</span> IP localhost.<span class=\"number\">9999</span> &gt; localhost.<span class=\"number\">45698</span>: Flags [.], ack <span class=\"number\">3</span>, win <span class=\"number\">342</span>, <span class=\"keyword\">options</span> [nop,nop,TS val <span class=\"number\">23439709</span> ecr <span class=\"number\">23439709</span>], length <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">15</span>:<span class=\"number\">47.962915</span> IP localhost.<span class=\"number\">45698</span> &gt; localhost.<span class=\"number\">9999</span>: Flags [.], ack <span class=\"number\">1</span>, win <span class=\"number\">342</span>, <span class=\"keyword\">options</span> [nop,nop,TS val <span class=\"number\">23441216</span> ecr <span class=\"number\">23439709</span>], length <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">15</span>:<span class=\"number\">47.962992</span> IP localhost.<span class=\"number\">9999</span> &gt; localhost.<span class=\"number\">45698</span>: Flags [.], ack <span class=\"number\">3</span>, win <span class=\"number\">342</span>, <span class=\"keyword\">options</span> [nop,nop,TS val <span class=\"number\">23441216</span> ecr <span class=\"number\">23439709</span>], length <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">16</span>:<span class=\"number\">03.321743</span> IP localhost.<span class=\"number\">45698</span> &gt; localhost.<span class=\"number\">9999</span>: Flags [.], ack <span class=\"number\">1</span>, win <span class=\"number\">342</span>, <span class=\"keyword\">options</span> [nop,nop,TS val <span class=\"number\">23442752</span> ecr <span class=\"number\">23441216</span>], length <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">16</span>:<span class=\"number\">03.321802</span> IP localhost.<span class=\"number\">9999</span> &gt; localhost.<span class=\"number\">45698</span>: Flags [.], ack <span class=\"number\">3</span>, win <span class=\"number\">342</span>, <span class=\"keyword\">options</span> [nop,nop,TS val <span class=\"number\">23442752</span> ecr <span class=\"number\">23439709</span>], length <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>分三段来看，</p>\n<ul>\n<li>第一段：三次握手，建立连接</li>\n<li>第二段：客户端发包，服务端应答（这里是我在客户端发了一个数字1）</li>\n<li>第三段：每隔15秒发一个<code>keepalive</code>包</li>\n</ul>\n<h2 id=\"使用docker重现问题\"><a href=\"#使用docker重现问题\" class=\"headerlink\" title=\"使用docker重现问题\"></a>使用docker重现问题</h2><h3 id=\"docker-compose建立本地网络\"><a href=\"#docker-compose建立本地网络\" class=\"headerlink\" title=\"docker-compose建立本地网络\"></a>docker-compose建立本地网络</h3><h3 id=\"断开服务端容器的网络\"><a href=\"#断开服务端容器的网络\" class=\"headerlink\" title=\"断开服务端容器的网络\"></a>断开服务端容器的网络</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker network disconnect docker_network docker_redis</span><br></pre></td></tr></table></figure>\n<h3 id=\"phpredis客户端\"><a href=\"#phpredis客户端\" class=\"headerlink\" title=\"phpredis客户端\"></a>phpredis客户端</h3><p>这里出现了两种情况，分别是「已发完PSH包」和「正在发PSH包」</p>\n<ol>\n<li>已发完PSH包，过一段时间，然后连续发几次<code>FIN_WAIT1</code>包，最后断开与服务端的单边连接</li>\n<li>正在发PSH包，不断重试，重试几次后，如果没有得到服务端的确认，直接发一个F包，然后断开与服务端的单边连接</li>\n</ol>\n<p>无论是哪一种情况，当客户端主动断开与服务端的连接时，都会返回一个异常 —— <code>read error on connection</code>，这是可以捕获的。但是，如果在执行<code>brpop</code>操作，当断开后，的确会返回该异常，然而，下一次再执行<code>brpop</code>的时候，就不走网络了，因为连接已经断开，所以redis客户端会直接返回<code>false</code>。</p>\n<h3 id=\"网络恢复？\"><a href=\"#网络恢复？\" class=\"headerlink\" title=\"网络恢复？\"></a>网络恢复？</h3><h4 id=\"docker模拟\"><a href=\"#docker模拟\" class=\"headerlink\" title=\"docker模拟\"></a>docker模拟</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker network connect docker_network docker_redis</span><br></pre></td></tr></table></figure>\n<p>网络恢复的时机也分为两种情况，分别对应断开的时机</p>\n<ol>\n<li>已发完PSH包，此时网络中断，客户端等待1分钟，然后开始发F包。这时，网络恢复了！</li>\n<li>正在发PSH包，此时网络中断，客户端不断重试，在重试结束前，网络恢复了！</li>\n</ol>\n<p>第一种情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">16:50:53.555004 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 155, ack 21, win 229, options [nop,nop,TS val 19885306 ecr 19879304], length 0</span><br><span class=\"line\">16:50:53.774621 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 155, ack 21, win 229, options [nop,nop,TS val 19885328 ecr 19879304], length 0</span><br><span class=\"line\">16:50:53.995675 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 155, ack 21, win 229, options [nop,nop,TS val 19885350 ecr 19879304], length 0</span><br><span class=\"line\">16:50:54.425041 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 155, ack 21, win 229, options [nop,nop,TS val 19885393 ecr 19879304], length 0</span><br><span class=\"line\">16:50:55.296710 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 155, ack 21, win 229, options [nop,nop,TS val 19885480 ecr 19879304], length 0</span><br><span class=\"line\">16:50:57.055424 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 155, ack 21, win 229, options [nop,nop,TS val 19885656 ecr 19879304], length 0</span><br><span class=\"line\">16:51:00.495806 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 155, ack 21, win 229, options [nop,nop,TS val 19886000 ecr 19879304], length 0</span><br><span class=\"line\">16:51:00.496113 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38658: Flags [P.], seq 21:26, ack 156, win 227, options [nop,nop,TS val 19886000 ecr 19886000], length 5: RESP null</span><br><span class=\"line\">16:51:00.496207 IP 2388ad577c4b.38658 &gt; web_docker_redis.web_docker_web_network.6379: Flags [R], seq 721889775, win 0, length 0</span><br></pre></td></tr></table></figure>\n<p><strong>因为客户端已经发了F包，就算这时候网络恢复了，也会断开连接，最终结果为，客户端异常</strong></p>\n<p>第二种情况：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">16:59:45.126281 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 123:155, ack 21, win 229, options [nop,nop,TS val 19938525 ecr 19938424], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">16:59:45.126422 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38666: Flags [.], ack 155, win 227, options [nop,nop,TS val 19938525 ecr 19938525], length 0</span><br><span class=\"line\">16:59:48.191229 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38666: Flags [P.], seq 21:26, ack 155, win 227, options [nop,nop,TS val 19938831 ecr 19938525], length 5: RESP null</span><br><span class=\"line\">16:59:48.191365 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [.], ack 26, win 229, options [nop,nop,TS val 19938831 ecr 19938831], length 0</span><br><span class=\"line\">16:59:49.196785 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 155:187, ack 26, win 229, options [nop,nop,TS val 19938932 ecr 19938831], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">16:59:49.196919 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38666: Flags [.], ack 187, win 227, options [nop,nop,TS val 19938932 ecr 19938932], length 0</span><br><span class=\"line\">16:59:52.276131 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38666: Flags [P.], seq 26:31, ack 187, win 227, options [nop,nop,TS val 19939240 ecr 19938932], length 5: RESP null</span><br><span class=\"line\">16:59:52.276197 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [.], ack 31, win 229, options [nop,nop,TS val 19939240 ecr 19939240], length 0</span><br><span class=\"line\">16:59:53.156963 IP 2388ad577c4b.38662 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 219, ack 31, win 229, options [nop,nop,TS val 19939328 ecr 19930202], length 0</span><br><span class=\"line\">16:59:53.279121 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19939340 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">16:59:53.496082 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19939362 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">16:59:53.715753 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19939384 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">16:59:54.147245 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19939427 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">16:59:54.997751 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19939512 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">16:59:56.756647 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19939688 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">17:00:00.197701 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19940032 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">17:00:07.238143 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19940736 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">17:00:21.282035 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19942144 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">17:00:48.768290 IP 2388ad577c4b.38666 &gt; web_docker_redis.web_docker_web_network.6379: Flags [P.], seq 187:219, ack 31, win 229, options [nop,nop,TS val 19944896 ecr 19939240], length 32: RESP <span class=\"string\">\"BRPOP\"</span> <span class=\"string\">\"test\"</span> <span class=\"string\">\"3\"</span></span><br><span class=\"line\">17:00:48.768815 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38666: Flags [.], ack 219, win 227, options [nop,nop,TS val 19944896 ecr 19944896], length 0</span><br><span class=\"line\">17:00:51.830821 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38666: Flags [P.], seq 31:36, ack 219, win 227, options [nop,nop,TS val 19945202 ecr 19944896], length 5: RESP null</span><br></pre></td></tr></table></figure>\n<p><strong>在客户端重试发PSH包的时候，网络恢复了，连接还在，服务端也会继续返回结果，客户端不再阻塞，继续运行</strong></p>\n<h2 id=\"解决方案：忙连接\"><a href=\"#解决方案：忙连接\" class=\"headerlink\" title=\"解决方案：忙连接\"></a>解决方案：忙连接</h2><ol>\n<li>使用php.ini的<code>default_socket_timeout</code>，或者phpredis的<code>OPT_READ_TIMEOUT</code>,设置一个自定义值，比如<code>60s</code></li>\n<li>设置connect函数的<code>timeout</code>为一个自定义值，如<code>10s</code></li>\n<li>在客户端断开连接并报异常<code>read error on connection</code>时，进行异常捕获，开启一个阻塞循环，不断的重连redis，只有连接成功后才返回</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopData</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@var</span> Redis */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $redis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;newRedis();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            $data = <span class=\"keyword\">$this</span>-&gt;popData();</span><br><span class=\"line\">            var_dump([<span class=\"string\">'data'</span> =&gt; $data, <span class=\"string\">'time'</span> =&gt; date(<span class=\"string\">'Y-m-d H:i:s'</span>, time())]);</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 连接Redis</span></span><br><span class=\"line\"><span class=\"comment\">     */</span> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newRedis</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;redis = <span class=\"keyword\">new</span> \\Redis();</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;redis-&gt;connect(<span class=\"string\">'192.168.48.4'</span>, <span class=\"number\">6379</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;redis-&gt;auth(<span class=\"number\">123456</span>);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-redis-&gt;setOption(\\Redis::OPT_READ_TIMEOUT, <span class=\"number\">60</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * brpop</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">popData</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发完Fin包后，直接从redis返回，不走网络请求。这里已经结束socket连接了，所以，即使网络情况好了也不会重连</span></span><br><span class=\"line\">            $data = <span class=\"keyword\">$this</span>-&gt;redis-&gt;brPop([<span class=\"string\">'test'</span>], <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> $data;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只打印了一次</span></span><br><span class=\"line\">            var_dump( $e-&gt;getMessage() );</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 进入重连逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;reconnect();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 重连成功，返回结果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 重连redis</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reconnect</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $isLostConnect = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>($isLostConnect) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">$this</span>-&gt;newRedis();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 重连成功</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">$this</span>-&gt;redis-&gt;ping() === <span class=\"string\">'+PONG'</span>) &#123;</span><br><span class=\"line\">                    $isLostConnect = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (\\<span class=\"keyword\">Exception</span> $e) &#123;</span><br><span class=\"line\">                var_dump($e-&gt;getMessage());</span><br><span class=\"line\"></span><br><span class=\"line\">                sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"系统与网络情况\"><a href=\"#系统与网络情况\" class=\"headerlink\" title=\"系统与网络情况\"></a>系统与网络情况</h3><p>tcpdump看下，在定时重连期间，客户端的发包情况</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">7:33:18.326086 IP 2388ad577c4b.38700 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 91, ack 11, win 229, options [nop,nop,TS val 20140076 ecr 20134070], length 0</span><br><span class=\"line\">17:33:18.326556 IP 2388ad577c4b.38702 &gt; web_docker_redis.web_docker_web_network.6379: Flags [S], seq 3300121440, win 29200, options [mss 1460,sackOK,TS val 20140076 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">17:33:18.544393 IP 2388ad577c4b.38700 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 91, ack 11, win 229, options [nop,nop,TS val 20140098 ecr 20134070], length 0</span><br><span class=\"line\">17:33:18.767654 IP 2388ad577c4b.38700 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 91, ack 11, win 229, options [nop,nop,TS val 20140120 ecr 20134070], length 0</span><br><span class=\"line\">17:33:19.194564 IP 2388ad577c4b.38700 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 91, ack 11, win 229, options [nop,nop,TS val 20140163 ecr 20134070], length 0</span><br><span class=\"line\">17:33:19.404336 IP 2388ad577c4b.38702 &gt; web_docker_redis.web_docker_web_network.6379: Flags [S], seq 3300121440, win 29200, options [mss 1460,sackOK,TS val 20140184 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">17:33:20.044337 IP 2388ad577c4b.38700 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 91, ack 11, win 229, options [nop,nop,TS val 20140248 ecr 20134070], length 0</span><br><span class=\"line\">17:33:21.807982 IP 2388ad577c4b.38700 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 91, ack 11, win 229, options [nop,nop,TS val 20140424 ecr 20134070], length 0</span><br><span class=\"line\">17:33:24.329065 IP 2388ad577c4b.38704 &gt; web_docker_redis.web_docker_web_network.6379: Flags [S], seq 717381143, win 29200, options [mss 1460,sackOK,TS val 20140676 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">17:33:25.255734 IP 2388ad577c4b.38700 &gt; web_docker_redis.web_docker_web_network.6379: Flags [F.], seq 91, ack 11, win 229, options [nop,nop,TS val 20140769 ecr 20134070], length 0</span><br><span class=\"line\">17:33:25.403884 IP 2388ad577c4b.38704 &gt; web_docker_redis.web_docker_web_network.6379: Flags [S], seq 717381143, win 29200, options [mss 1460,sackOK,TS val 20140784 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">17:34:59.783849 IP 2388ad577c4b.38738 &gt; web_docker_redis.web_docker_web_network.6379: Flags [S], seq 1730851263, win 29200, options [mss 1460,sackOK,TS val 20150126 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">17:34:59.784023 IP web_docker_redis.web_docker_web_network.6379 &gt; 2388ad577c4b.38738: Flags [S.], seq 1414026707, ack 1730851264, win 28960, options [mss 1460,sackOK,TS val 20150232 ecr 20150126,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure>\n<p>可以发现，有两个线程正在疯狂的“试探”，一个想要结束，一个想要连接。</p>\n<p>netstat看下，在定时重连期间，客户端的连接状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tcp        0      1 192.168.48.5:38700      192.168.48.4:6379       FIN_WAIT1   -</span><br><span class=\"line\">tcp        0      1 192.168.48.5:38728      192.168.48.4:6379       SYN_SENT    682/php</span><br></pre></td></tr></table></figure>\n<p>由于“连接线程”是通过<code>new Redis</code>来实现的，所以端口会一直变化。</p>\n<h2 id=\"OPT-TCP-KEEPALIVE-到底是什么？怎么用？\"><a href=\"#OPT-TCP-KEEPALIVE-到底是什么？怎么用？\" class=\"headerlink\" title=\"OPT_TCP_KEEPALIVE 到底是什么？怎么用？\"></a>OPT_TCP_KEEPALIVE 到底是什么？怎么用？</h2><p>在官方文档中，根本找不到这个选项的说明。查看源码发现，phpredis在建立连接时，<code>tcp_keepalive</code>参数默认为 <code>0</code></p>\n<p>文件：library.c 行：1783</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">redis_sock-&gt;tcp_keepalive = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>可以通过函数<code>setOption</code>来设置<code>tcp_keepalive</code>的值</p>\n<p>文件：redis_commands.c 行：3991</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> REDIS_OPT_TCP_KEEPALIVE:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Don't set TCP_KEEPALIVE if we're using a unix socket. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ZSTR_VAL(redis_sock-&gt;host)[<span class=\"number\">0</span>] == <span class=\"string\">'/'</span> &amp;&amp; redis_sock-&gt;port &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        RETURN_FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tcp_keepalive = zval_get_long(val) &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis_sock-&gt;tcp_keepalive == tcp_keepalive) &#123;</span><br><span class=\"line\">        RETURN_TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis_sock-&gt;stream) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* set TCP_KEEPALIVE */</span></span><br><span class=\"line\">        sock = (<span class=\"keyword\">php_netstream_data_t</span>*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (<span class=\"keyword\">char</span>*)&amp;tcp_keepalive,</span><br><span class=\"line\">                    <span class=\"keyword\">sizeof</span>(tcp_keepalive)) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            RETURN_FALSE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        redis_sock-&gt;tcp_keepalive = tcp_keepalive;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RETURN_TRUE;</span><br></pre></td></tr></table></figure>\n<p>刚刚谈pconnect的时候，聊到下面这个地方，现在着重看看</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Attempt to set TCP_NODELAY/TCP_KEEPALIVE if we're not using a unix socket. */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!usocket) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">php_netstream_data_t</span> *sock = (<span class=\"keyword\">php_netstream_data_t</span>*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">    err = setsockopt(sock-&gt;socket, IPPROTO_TCP, TCP_NODELAY, (<span class=\"keyword\">char</span>*) &amp;tcp_flag, <span class=\"keyword\">sizeof</span>(tcp_flag));</span><br><span class=\"line\">    PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">    err = setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (<span class=\"keyword\">char</span>*) &amp;redis_sock-&gt;tcp_keepalive, <span class=\"keyword\">sizeof</span>(redis_sock-&gt;tcp_keepalive));</span><br><span class=\"line\">    PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在连接的时候，会通过判断<code>host</code>来看是否开启<code>TCP_KEEPALIVE</code>，前面在说connect函数的时候了解到，host由下面几种：</p>\n<p><em>host</em>: string. can be </p>\n<ul>\n<li>a host（ip/域名）</li>\n<li>or the path to a unix domain socket. （本地域socket）</li>\n<li>Starting from version 5.0.0 it is possible to specify schema</li>\n</ul>\n<p>我把这句话拆开来看会比较清晰，上面这段代码中可以看到，如果是<code>unix domain socket</code>，则不会启用<code>TCP_KEEPALIVE</code>。然而，在<code>connect</code>阶段，根本没有这个配置项，也就是说，真正设置该配置的地方在别处..</p>\n<h3 id=\"docker模拟-1\"><a href=\"#docker模拟-1\" class=\"headerlink\" title=\"docker模拟\"></a>docker模拟</h3><h4 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p><strong>test.php</strong></p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$redis = <span class=\"keyword\">new</span> \\Redis();</span><br><span class=\"line\">$redis-&gt;connect(<span class=\"string\">'192.168.80.2'</span>, <span class=\"number\">6379</span>);</span><br><span class=\"line\">$redis-&gt;auth(<span class=\"number\">123456</span>);</span><br><span class=\"line\">$redis-&gt;setOption(\\Redis::OPT_TCP_KEEPALIVE, <span class=\"number\">10</span>);</span><br><span class=\"line\">var_dump($redis-&gt;ping());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>host</code>方式连接服务端，并设置选项<code>OPT_TCP_KEEPALIVE</code>为<code>10s</code>，通过ping查看连通性，然后进行<code>阻塞</code>操作。<code>lsof</code>看下，确实使用<code>TCP</code>方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">php     899 root    3u  IPv4 741397      0t0     TCP 2388ad577c4b:38782-&gt;web_docker_redis.web_docker_web_network:6379 (ESTABLISHED)</span><br></pre></td></tr></table></figure>\n<p>断开服务端容器的网络发现，在设定条件下，并不会发keepalive包，可能与docker的实现机制有关，自动转化为unix domain socket?目前不确定是<code>phpredis</code>的问题还是<code>docker网络机制</code>的问题。接下来，先看看phpredis究竟有没有执行到相应的逻辑。</p>\n<h4 id=\"非debug模式\"><a href=\"#非debug模式\" class=\"headerlink\" title=\"非debug模式\"></a>非debug模式</h4><p>为了看这段代码是否被执行到，我改一下phpredis的源码，在这里打印一下日志，再重新编译。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -O http://pecl.php.net/get/redis-4.0.2.tgz</span><br><span class=\"line\">tar zxvf redis-4.0.2.tgz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-4.0.2</span><br><span class=\"line\">vim library.c</span><br></pre></td></tr></table></figure>\n<p>找到<code>redis_sock_connect</code>函数，在下面的代码中，加入<code>打印日志</code>的代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Attempt to set TCP_NODELAY/TCP_KEEPALIVE if we're not using a unix socket. */</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!usocket) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"open keepalive\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">php_netstream_data_t</span> *sock = (<span class=\"keyword\">php_netstream_data_t</span>*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">    err = setsockopt(sock-&gt;socket, IPPROTO_TCP, TCP_NODELAY, (<span class=\"keyword\">char</span>*) &amp;tcp_flag, <span class=\"keyword\">sizeof</span>(tcp_flag));</span><br><span class=\"line\">    PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">    err = setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (<span class=\"keyword\">char</span>*) &amp;redis_sock-&gt;tcp_keepalive, <span class=\"keyword\">sizeof</span>(redis_sock-&gt;tcp_keepalive));</span><br><span class=\"line\">    PHPREDIS_NOTUSED(err);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"not open keepalive\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样做发现，打印的结果是<code>open keepalive</code>。要想得到整个<code>调用栈</code>以及<code>打印变量</code>，不是很方便。下面使用gdb来调试，设置断点。</p>\n<h4 id=\"debug模式\"><a href=\"#debug模式\" class=\"headerlink\" title=\"debug模式\"></a>debug模式</h4><p>为了使用<code>gdb</code>断点调试PHP扩展，需要把PHP编译为<code>debug</code>模式，然后再把phpredis重新编译一次</p>\n<p><strong>编译php</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget -c https://github.com/php/php-src/archive/php-7.1.30.tar.gz</span><br><span class=\"line\">tar zxvf php-7.1.30.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> php-src-php-7.1.30</span><br><span class=\"line\">./buildconf --force</span><br><span class=\"line\">./configure \\</span><br><span class=\"line\">--prefix=/usr/<span class=\"built_in\">local</span>/php7.1.30 \\</span><br><span class=\"line\">--<span class=\"built_in\">exec</span>-prefix=/usr/<span class=\"built_in\">local</span>/php7.1.30 \\</span><br><span class=\"line\">--bindir=/usr/<span class=\"built_in\">local</span>/php7.1.30/bin \\</span><br><span class=\"line\">--sbindir=/usr/<span class=\"built_in\">local</span>/php7.1.30/sbin \\</span><br><span class=\"line\">--includedir=/usr/<span class=\"built_in\">local</span>/php7.1.30/include \\</span><br><span class=\"line\">--libdir=/usr/<span class=\"built_in\">local</span>/php7.1.30/lib/php \\</span><br><span class=\"line\">--mandir=/usr/<span class=\"built_in\">local</span>/php7.1.30/php/man \\</span><br><span class=\"line\">--with-config-file-path=/usr/<span class=\"built_in\">local</span>/php7.1.30/etc \\</span><br><span class=\"line\">--<span class=\"built_in\">enable</span>-pcntl \\</span><br><span class=\"line\">--with-curl \\</span><br><span class=\"line\">--<span class=\"built_in\">enable</span>-debug \\</span><br><span class=\"line\">--<span class=\"built_in\">enable</span>-cli</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\">cp php-src-php-7.1.30/php.ini-development /usr/<span class=\"built_in\">local</span>/php7.1.30/etc/php.ini</span><br></pre></td></tr></table></figure>\n<p><strong>编译phpredis</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -O http://pecl.php.net/get/redis-4.0.2.tgz</span><br><span class=\"line\">tar zxvf redis-4.0.2.tgz</span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/php7.1.30/bin/phpize</span><br><span class=\"line\">./configure --with-php-config=/usr/<span class=\"built_in\">local</span>/php7.1.30/bin/php-config</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\">vim /usr/<span class=\"built_in\">local</span>/php7.1.30/etc/php.ini</span><br><span class=\"line\">// 添加extension=redis.so到文件尾</span><br></pre></td></tr></table></figure>\n<p>编译完成后，会发现安装目录为 <code>/usr/local/php7.1.30/lib/php/extensions/debug-non-zts-20160303</code></p>\n<p><strong>开始gdb调试</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gdb /usr/<span class=\"built_in\">local</span>/php7.1.30/bin/php</span><br><span class=\"line\"></span><br><span class=\"line\">Reading symbols from /usr/<span class=\"built_in\">local</span>/php7.1.30/bin/php...done.</span><br><span class=\"line\">(gdb) b redis_sock_connect</span><br><span class=\"line\">Function <span class=\"string\">\"redis_sock_connect\"</span> not defined.</span><br><span class=\"line\">Make breakpoint pending on future shared library load? (y or [n]) y</span><br><span class=\"line\">Breakpoint 1 (redis_sock_connect) pending.</span><br><span class=\"line\">(gdb) run test.php</span><br><span class=\"line\">Starting program: /usr/<span class=\"built_in\">local</span>/php7.1.30/bin/php test.php</span><br><span class=\"line\">95337</span><br><span class=\"line\">Breakpoint 1, redis_sock_connect (redis_sock=0x7ffff687e0e0) at /data/tools/redis-4.0.2/library.c:1416</span><br><span class=\"line\">1416\t&#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1417\t    struct timeval tv, read_tv, *tv_ptr = NULL;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1418\t    char host[1024], *persistent_id = NULL;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1419\t    const char *fmtstr = <span class=\"string\">\"%s:%d\"</span>;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1420\t    int host_len, usocket = 0, err = 0;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1422\t    int tcp_flag = 1;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1426\t    zend_string *estr = NULL;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1429\t    <span class=\"keyword\">if</span> (redis_sock-&gt;stream != NULL) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1433\t    tv.tv_sec  = (time_t)redis_sock-&gt;timeout;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1434\t    tv.tv_usec = (int)((redis_sock-&gt;timeout - tv.tv_sec) * 1000000);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1435\t    <span class=\"keyword\">if</span>(tv.tv_sec != 0 || tv.tv_usec != 0) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1439\t    read_tv.tv_sec  = (time_t)redis_sock-&gt;read_timeout;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1440\t    read_tv.tv_usec = (int)((redis_sock-&gt;read_timeout-read_tv.tv_sec)*1000000);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1442\t    <span class=\"keyword\">if</span> (ZSTR_VAL(redis_sock-&gt;host)[0] == <span class=\"string\">'/'</span> &amp;&amp; redis_sock-&gt;port &lt; 1) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1446\t        <span class=\"keyword\">if</span>(redis_sock-&gt;port == 0)</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1452\t        <span class=\"keyword\">if</span> (strchr(ZSTR_VAL(redis_sock-&gt;host), <span class=\"string\">':'</span>) != NULL) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1456\t        host_len = snprintf(host, sizeof(host), fmtstr, ZSTR_VAL(redis_sock-&gt;host), redis_sock-&gt;port);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1459\t    <span class=\"keyword\">if</span> (redis_sock-&gt;persistent) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1469\t    redis_sock-&gt;stream = php_stream_xport_create(host, host_len,</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1473\t    <span class=\"keyword\">if</span> (persistent_id) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1477\t    <span class=\"keyword\">if</span> (!redis_sock-&gt;stream) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1491\t    sock = (php_netstream_data_t*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">(gdb) p persistent_id</span><br><span class=\"line\"><span class=\"variable\">$1</span> = 0x0</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1492\t    <span class=\"keyword\">if</span> (!usocket) &#123;</span><br><span class=\"line\">(gdb) p usocket</span><br><span class=\"line\"><span class=\"variable\">$2</span> = 0</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1493\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"open keepalive\"</span>);</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1494\t        err = setsockopt(sock-&gt;socket, IPPROTO_TCP, TCP_NODELAY, (char*) &amp;tcp_flag, sizeof(tcp_flag));</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">1496\t        err = setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (char*) &amp;redis_sock-&gt;tcp_keepalive, sizeof(redis_sock-&gt;tcp_keepalive));</span><br><span class=\"line\">(gdb) p redis_sock-&gt;tcp_keepalive</span><br><span class=\"line\"><span class=\"variable\">$5</span> = 0</span><br></pre></td></tr></table></figure>\n<p>通过上面的gdb调试纪录可以发现，</p>\n<ol>\n<li><code>usocket</code>的值为<code>0</code>，说明docker没有做什么“小动作”，host模式没问题。</li>\n<li>在<code>connect</code>阶段，<code>tcp_keepalive</code>默认为<code>0</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">(gdb) b redis_setoption_handler</span><br><span class=\"line\">Function <span class=\"string\">\"redis_setoption_handler\"</span> not defined.</span><br><span class=\"line\">Make breakpoint pending on future shared library load? (y or [n]) y</span><br><span class=\"line\">Breakpoint 1 (redis_setoption_handler) pending.</span><br><span class=\"line\">(gdb) run /data/webapp/<span class=\"built_in\">test</span>/test.php</span><br><span class=\"line\">Starting program: /usr/<span class=\"built_in\">local</span>/php7.1.30/bin/php /data/webapp/<span class=\"built_in\">test</span>/test.php</span><br><span class=\"line\">6</span><br><span class=\"line\">open keepalive</span><br><span class=\"line\">Breakpoint 1, redis_setoption_handler (execute_data=0x7ffff6814160, return_value=0x7fffffffb000, redis_sock=0x7ffff687e0e0, c=0x0)</span><br><span class=\"line\">    at /data/tools/redis-4.0.2/redis_commands.c:3089</span><br><span class=\"line\">3089\t&#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3095\t    int tcp_keepalive = 0;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3098\t    <span class=\"keyword\">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class=\"string\">\"ls\"</span>, &amp;option,</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3104\t    switch(option) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3150\t            <span class=\"keyword\">if</span> (ZSTR_VAL(redis_sock-&gt;host)[0] == <span class=\"string\">'/'</span> &amp;&amp; redis_sock-&gt;port &lt; 1) &#123;</span><br><span class=\"line\">(gdb) p option</span><br><span class=\"line\"><span class=\"variable\">$1</span> = 6</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3153\t            tcp_keepalive = atol(val_str) &gt; 0 ? 1 : 0;</span><br><span class=\"line\">(gdb) p val_str</span><br><span class=\"line\"><span class=\"variable\">$2</span> = 0x7ffff6802bd8 <span class=\"string\">\"10\"</span></span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3154\t            <span class=\"keyword\">if</span> (redis_sock-&gt;tcp_keepalive == tcp_keepalive) &#123;</span><br><span class=\"line\">(gdb) p tcp_keepalive</span><br><span class=\"line\"><span class=\"variable\">$3</span> = 1</span><br><span class=\"line\">(gdb) p redis_sock-&gt;tcp_keepalive</span><br><span class=\"line\"><span class=\"variable\">$4</span> = 0</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3157\t            <span class=\"keyword\">if</span> (redis_sock-&gt;stream) &#123;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3159\t                sock = (php_netstream_data_t*)redis_sock-&gt;stream-&gt;abstract;</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3160\t                <span class=\"keyword\">if</span> (setsockopt(sock-&gt;socket, SOL_SOCKET, SO_KEEPALIVE, (char*)&amp;tcp_keepalive,</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3164\t                redis_sock-&gt;tcp_keepalive = tcp_keepalive;</span><br><span class=\"line\">(gdb) p redis_sock-&gt;tcp_keepalive</span><br><span class=\"line\"><span class=\"variable\">$5</span> = 0</span><br><span class=\"line\">(gdb) p tcp_keepalive</span><br><span class=\"line\"><span class=\"variable\">$6</span> = 1</span><br><span class=\"line\">(gdb) n</span><br><span class=\"line\">3166\t            RETURN_TRUE;</span><br></pre></td></tr></table></figure>\n<p>通过上面的调试可以知道，</p>\n<ul>\n<li>在调用<code>setOption</code>函数阶段，成功设置了<code>tcp_keepalive</code>为<code>1</code>。</li>\n</ul>\n<h3 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h3><p>前面我们通过docker模拟，gdb断点排查，现在进行小结：</p>\n<ol>\n<li>版本问题：一开始怀疑是phpredis没有<code>TCP_KEEPALIVE</code>的配置项，查看源码发现4.0以上的版本都支持了。</li>\n<li>环境问题：通过gdb断点发现，host是没问题的，并没有采用<code>unix domain socket</code>模式，在docker环境下模拟没问题。</li>\n<li>逻辑问题：通过gdb断点发现，在<code>connect</code>阶段，sock-&gt;tcp_keepalive默认为<code>0</code>，在<code>setOption</code>阶段，sock-&gt;tcp_keepalive被设置为<code>1</code>，逻辑也没问题</li>\n</ol>\n<p>到现在，几乎任何关于代码的地方都“似乎”没问题，所以走不通了，只能回头再看看，有什么细节遗漏了。前面，我们在<code>setOption</code>阶段，把<code>OPT_TCP_KEEPALIVE</code>设置为<code>10</code>，当时我说，把时间设置为<code>10s</code>，因为我把这里理所当然的理解为<code>tcp_keepalive_time</code>，我希望在断网后10秒内，能给服务端发<code>keepalive</code>包。可是，查看源码发现，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">tcp_keepalive = zval_get_long(val) &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>这里传入的值，似乎被当作了另一种用法，<code>只要是正整数，就把tcp_keepalive设置为1，否则设置为0</code>。也就是说，这里并没有<code>tcp_keepalive_time</code>的功能，仅作为开关！！！</p>\n<p>但是，我找不到任何提供的API可以设置了…</p>\n<h3 id=\"设置系统默认TCP-KEEPALIVE各参数值\"><a href=\"#设置系统默认TCP-KEEPALIVE各参数值\" class=\"headerlink\" title=\"设置系统默认TCP_KEEPALIVE各参数值\"></a>设置系统默认TCP_KEEPALIVE各参数值</h3><p>前面我们知道，系统有一个全局默认的TCP_KEEPALIVE配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl -a | grep keepalive</span><br><span class=\"line\"></span><br><span class=\"line\">net.ipv4.tcp_keepalive_intvl = 75</span><br><span class=\"line\">net.ipv4.tcp_keepalive_probes = 9</span><br><span class=\"line\">net.ipv4.tcp_keepalive_time = 7200</span><br></pre></td></tr></table></figure>\n<p>上面这个配置是两个小时（7200s）后才发包，现在我把这些设置改一下，改短一点</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl -w net.ipv4.tcp_keepalive_time=15 net.ipv4.tcp_keepalive_probes=3 net.ipv4.tcp_keepalive_intvl=10</span><br></pre></td></tr></table></figure>\n<ul>\n<li>net.ipv4.tcp_keepalive_time：15</li>\n<li>net.ipv4.tcp_keepalive_probes：3</li>\n<li>net.ipv4.tcp_keepalive_intvl：10</li>\n</ul>\n<p>重新跑一遍代码，断开服务端网络，tcpdump看发包情况。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">15:38:24.862503 IP web_docker_php.web_docker_web_network.42480 &gt; ce6e2fa39930.6379: Flags [.], ack 13, win 229, options [nop,nop,TS val 35239808 ecr 35238270], length 0</span><br><span class=\"line\">15:38:24.862592 IP ce6e2fa39930.6379 &gt; web_docker_php.web_docker_web_network.42480: Flags [.], ack 41, win 227, options [nop,nop,TS val 35239808 ecr 35238275], length 0</span><br><span class=\"line\">15:38:39.866247 IP web_docker_php.web_docker_web_network.42480 &gt; ce6e2fa39930.6379: Flags [.], ack 13, win 229, options [nop,nop,TS val 35241312 ecr 35239808], length 0</span><br><span class=\"line\">15:38:39.866290 IP ce6e2fa39930.6379 &gt; web_docker_php.web_docker_web_network.42480: Flags [.], ack 41, win 227, options [nop,nop,TS val 35241312 ecr 35238275], length 0</span><br><span class=\"line\">15:38:54.907073 IP web_docker_php.web_docker_web_network.42480 &gt; ce6e2fa39930.6379: Flags [.], ack 13, win 229, options [nop,nop,TS val 35242816 ecr 35241312], length 0</span><br><span class=\"line\">15:38:54.907178 IP ce6e2fa39930.6379 &gt; web_docker_php.web_docker_web_network.42480: Flags [.], ack 41, win 227, options [nop,nop,TS val 35242816 ecr 35238275], length 0</span><br></pre></td></tr></table></figure>\n<p>重新试一下发现，竟然没问题了！确实每隔15秒发一次<code>keepalive包</code>。也就是说，我一直对phpredis的<code>TCP_KEEPALIVE</code>用法理解错了。先入为主的认为这个就是<code>tcp_keepalive_time</code>。其实，之前的程序一直没有问题，只不过，因为系统默认的时间太久了，程序一直阻塞着，所以我才觉得这个参数没有正确被设置。</p>\n<h2 id=\"更简单的方案\"><a href=\"#更简单的方案\" class=\"headerlink\" title=\"更简单的方案?\"></a>更简单的方案?</h2><p>前面讨论了解决<code>brpop</code>在网络抖动的情况下，使用<code>忙连接</code>的方案。后来，我们了解了<code>OPT_TCP_KEEPALIVE</code>的用法，能不能有更简单的方案？要是phpredis客户端能定时发<code>keepalive包</code>，如果网络中断，直接报异常，然后进行异常捕获，重新连接。岂不是更佳？</p>\n<p>然而，在实测过程中（使用test.php），当网络中断后，客户端便不再发送<code>keepalive包</code>，通过netstat看，客户端在<strong>短时间内自动断开客户端与服务端的单边连接</strong>，然后也没有报异常:(</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>使用nc和netcat-keepalive工具，回顾TCP_KEEPALIVE机制</li>\n<li>理清redis几个关于timeout的API，以及结合使用时它们的优先级</li>\n<li>理清phpredis客户端keepalive用法，没有开放TCP_KEEPALIVE的三个关键配置，而是仅作为开关，使用系统环境的参数配置</li>\n<li>把网络异常当作常态，在应用层做更健壮的长连接检测</li>\n</ol>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>本文使用Redis的brpop做消息获取，这只是其中一种情况，还有其他网络API也是需要长连接的，如subscribe，针对其他API，解决方案是否如出一辙呢？留到下一次继续分析～</p>\n","categories":["技术"],"tags":["PHP","Redis","TCP/IP"]},{"title":"今天玩了一款让我写代码的游戏","url":"/2018/04/13/%E4%BB%8A%E5%A4%A9%E7%8E%A9%E4%BA%86%E4%B8%80%E6%AC%BE%E8%AE%A9%E6%88%91%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%B8%B8%E6%88%8F/","content":"<h2 id=\"编程？游戏？\"><a href=\"#编程？游戏？\" class=\"headerlink\" title=\"编程？游戏？\"></a>编程？游戏？</h2><p>今天看到一个有趣的网站，这是个通过游戏的形式学习python的网站，玩到了第二关<a href=\"http://www.pythonchallenge.com/pc/def/map.html\" target=\"_blank\" rel=\"noopener\">pythonchallenge</a>，很有意思，虽然作者的本意是让玩家学习python，但是我决定用PHP…</p>\n<a id=\"more\"></a>\n<p>游戏中给出了一张图，图里面是这样的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">E -&gt; G</span><br><span class=\"line\">K -&gt; M</span><br><span class=\"line\">O -&gt; Q</span><br></pre></td></tr></table></figure>\n<p>然后给出了一段”乱码”:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&apos;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.</span><br></pre></td></tr></table></figure>\n<p>显然，只要把“乱码”中每个字母往后移动两位即可…</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$str = <span class=\"string\">\"g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.\"</span>;</span><br><span class=\"line\">$arr = str_split($str);</span><br><span class=\"line\">$res = [];</span><br><span class=\"line\">$filter = [<span class=\"string\">' '</span>,<span class=\"string\">'.'</span>,<span class=\"string\">'\\''</span>,<span class=\"string\">'('</span>,<span class=\"string\">')'</span>];</span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($arr <span class=\"keyword\">as</span> $item)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(in_array($item,$filter)) &#123;</span><br><span class=\"line\">        $res[] = $item;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    $tmp = ord($item);</span><br><span class=\"line\">    $res[] = $item == <span class=\"string\">'z'</span> ? <span class=\"string\">'b'</span> : ($item == <span class=\"string\">'y'</span> ? <span class=\"string\">'a'</span> : chr($tmp + <span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$str = implode($res,<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $str;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long. using string.maketrans() is recommended. now apply on the url.</p>\n","categories":["技术"],"tags":["PHP","有趣"]},{"title":"基于统计机器学习的自动回复","url":"/2019/12/02/%E5%9F%BA%E4%BA%8E%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇文章是最近工作的总结，受到<code>费曼技巧</code>的影响，还有一个简陋的<a href=\"https://slides.com/funsoul/auto_response_v2\" target=\"_blank\" rel=\"noopener\">PPT</a></p>\n<a id=\"more\"></a>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>这篇文章的背景是游戏环境下的客服投诉系统，玩家和游戏开发者的联系不止在游戏中，很多时候，游戏开发者需要提供一个通道让玩家表达意见、怀疑与不满。很常见的情况是，</p>\n<p>玩家想知道</p>\n<ol>\n<li>系统公告问题（开服、合服时间）</li>\n<li>装备掉落概率问题（打副本爆装备概率低）</li>\n<li>系统奖励资源问题（礼包、奖励未到账）</li>\n<li>游戏下载问题（下载地址）</li>\n<li>关于玩家举报反馈</li>\n</ol>\n<p>对于简单、重复的问题，客服常常会有一套差不多的回复。既然问题有规律/规则、有共性，那么只要识别问题的规则，面对特定的规则，自动回复特定的内容，好像就解决了。</p>\n<p>然而，事情远远没有那么简单。我们很快开发了一套识别用户问题意图的基于规则的自动回复系统，上线运行了一段时间后，各项指标非常惨烈。分别是，</p>\n<ol>\n<li>准确率，衡量正确识别用户意图的指标。只有85～90%</li>\n<li>匹配率，衡量单位时间内匹配当前所有配置规则的指标，只有18～20%</li>\n<li>召回率，衡量单个规则在同性质问题的匹配度，未统计，通过匹配率可以看出，也是相当惨烈</li>\n</ol>\n<p>准确率的反面就是未解决率+错误率的总和，通过这两个反向指标，我们终于发现问题，后面会详细说说。</p>\n<h2 id=\"鸟瞰自然语言处理的历史\"><a href=\"#鸟瞰自然语言处理的历史\" class=\"headerlink\" title=\"鸟瞰自然语言处理的历史\"></a>鸟瞰自然语言处理的历史</h2><p>学习新东西，我喜欢看它的历史，从历史进程中认识发展的脉络。</p>\n<p>我很喜欢的一个作家吴军博士，在《数学之美》一书的第二章「自然语言处理，从规则到统计」中把自然语言处理的历史讲述的非常深入人心。计算机诞生之时，科学家希望计算机能懂人类语言，于是在长达20年的时间里（1950～1970），研究人类语言的句法和语义，不断完善句法，到1960年基于规则的研究已经获得了普遍的认同。然而，局限于句法的多义性和复杂度，算法设计的复杂度也随之攀升，性能是个大问题，而且如果要让计算机认识人类语言，或许需要世界的知识和常识。</p>\n<p>时间来到1970年代，IBM基于数学模型和统计设计的系统横空出世（准确率达到90%），让人们不禁想，也许方向错了。学派之争到了1990年代，随着参与基于规则的研究人员越来越少，参与基于统计的研究人员越来越多，自然语言处理的过渡完成了。2005年，Google基于统计的翻译系统出来后，人们终于放弃了基于规则的方法。</p>\n<h3 id=\"句法分析、语义分析\"><a href=\"#句法分析、语义分析\" class=\"headerlink\" title=\"句法分析、语义分析\"></a>句法分析、语义分析</h3><p>下面来看看这个简单的例子，玩家发了一条投诉意见：</p>\n<blockquote>\n<p>你们合区啊，这区人少的，简直打不掉装备。</p>\n</blockquote>\n<p>我们可以很容易理解，这句话的意思是需要针对「合服」类做回复。但是基于规则的自然语言处理系统能理解吗？</p>\n<p><img src=\"/images/基于统计机器学习的自动回复/基于规则.png\" alt=\"基于规则的自然语言处理\"></p>\n<p>基于规则的系统会先进行分词，得到每个词的词性。简单的关键字匹配，可以得到几个有价值的关键词：合区、装备。但是我们怎么知道这是属于「合区」的类别，还是属于「概率」的类别呢？这里，机器开始不明白用户的意图了。</p>\n<p>于是我们想，单靠一个词机器理解不了，那就再来一个。然后，我们得到了组合词规则：「合区 + 人少」、「装备 + 不掉」。我们开始思考词法和语义分析了，希望通过主谓关系来理解用户的意图，接下来你也想到了，<strong>规则的复杂度开始加大了，算法设计的复杂度也开始增加</strong>。</p>\n<p>我们明白：人类语言的句法中含有并列、转折等多重关系，单纯的规则（关键字）无法识别用户真正的意图。</p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>下面我们通过<code>词云</code>来呈现每个规则的关键词有多么复杂和庞大。</p>\n<p><img src=\"/images/基于统计机器学习的自动回复/word_cloud_概率.png\" alt=\"词云-概率类\"></p>\n<center>（概率类）</center>\n\n<p><img src=\"/images/基于统计机器学习的自动回复/word_cloud_举报.png\" alt=\"词云-举报类\"></p>\n<center>（举报类）</center>\n\n<p>也就是说，人工设计的规则，还带来一个问题，人类语言是演进和繁杂的，而人工无法设计涵盖所有词的程序。</p>\n<h3 id=\"多义性\"><a href=\"#多义性\" class=\"headerlink\" title=\"多义性\"></a>多义性</h3><p>人工智能专家<code>马文·明斯基</code>举过一个例子：</p>\n<blockquote>\n<p>The pen is in the box.（笔在盒子里。）<br>The box is in the pen. (盒子在围栏里。)</p>\n</blockquote>\n<p>这是另一个无法解决的问题，中文语境博大精深，同样存在此类问题。但在今天这篇文章中，我们暂且不谈。</p>\n<p>下面这句话摘自吴军博士《数学之美》第二章「自然语言处理，从规则到统计」</p>\n<blockquote>\n<p>在20世纪60年代，摆在科学家面前的问题是怎样才能理解自然语言，当时普遍的认识是首先要做好两件事，即分析语句和获取语义，这实际上又是惯性思维的结果，它收到传统语言学的影响。</p>\n</blockquote>\n<h2 id=\"从规则到统计\"><a href=\"#从规则到统计\" class=\"headerlink\" title=\"从规则到统计\"></a>从规则到统计</h2><p><img src=\"/images/基于统计机器学习的自动回复/从规则到统计.jpeg\" alt=\"从规则到统计\"></p>\n<center>图片来自《深度学习》</center>\n\n<p>最近在读《<a href=\"https://book.douban.com/subject/27087503/\" target=\"_blank\" rel=\"noopener\">深度学习</a>》这本书，业界俗称「花书」。这张图很好地展示了近几十年人工智能发展的趋势。可以发现，基于规则的系统必然会成为历史。从经典机器学习到后面的表示学习，都属于基于统计的范畴。区别在于，谁来挖掘特征？经典机器学习依赖人工挖掘特征，这是大前提。意味着人去告诉/教会机器，什么是系统需要的特征，然后从特征去对应输出。表示学习就不依赖任何东西，但同样需要明确输入和输出，只是挖掘特征的过程交给模型/算法去做。</p>\n<p>回到主题，对于文本分类领域，是否也可以使用基于统计的方法？答案是肯定的。</p>\n<p><img src=\"/images/基于统计机器学习的自动回复/基于统计.png\" alt=\"基于统计的自然语言处理\"></p>\n<p>本文使用经典机器学习的方式，将文本分词，但是不使用词性。而是先过滤<code>停用词</code>和<code>单词</code>（单个文字的词）。这里，我们得到了文本的特征。到这里，你也许问，这不是和关键字一样了吗？是的，如果仅仅处理一条文本，和基于规则的方式并无二致。基于统计的精髓在于 —— 统计，这意味着庞大的样本集。</p>\n<p>然后，我们进行特征映射，构造词袋。从词袋中，获取真正的语料，这些语料已经成为数字形式了。也就是说，从最初的文本到现在的语料，我们对文本进行了形式化处理。有了这些语料，就可以使用分类模型了。举个简单的例子，下面使用sklearn的NavieBayes模型中的<code>GaussianNB</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.naive_bayes <span class=\"keyword\">import</span> GaussianNB</span><br><span class=\"line\"></span><br><span class=\"line\">data = [[<span class=\"number\">1</span>, <span class=\"number\">1</span>]]</span><br><span class=\"line\">target = [<span class=\"number\">1</span>]    <span class=\"comment\"># 假设「合区」类的ID为1</span></span><br><span class=\"line\"></span><br><span class=\"line\">gnb = GaussianNB()</span><br><span class=\"line\">gnb.fit(data, target)</span><br></pre></td></tr></table></figure>\n<p>图中，我还用了<code>TF-IDF</code>，这是一种获取文本权重值的方法，可以显著提高文本分类的效果。</p>\n<h2 id=\"结合基于规则和基于统计的新方案\"><a href=\"#结合基于规则和基于统计的新方案\" class=\"headerlink\" title=\"结合基于规则和基于统计的新方案\"></a>结合基于规则和基于统计的新方案</h2><ol>\n<li>第一阶段：结合人工校对和机器分类，生成可用训练的历史投诉记录作为样本</li>\n<li>第二阶段：基于充足样本数以及高准确率的机器分类，结合原方案（关键字分类）制定新策略</li>\n<li>第三阶段：完成全部历史记录训练样本，并开始校对匹配记录中的机器判定结果，完成机器分类正反馈闭环</li>\n</ol>\n<h3 id=\"第一阶段：样本集\"><a href=\"#第一阶段：样本集\" class=\"headerlink\" title=\"第一阶段：样本集\"></a>第一阶段：样本集</h3><p><img src=\"/images/基于统计机器学习的自动回复/第一阶段.png\" alt=\"第一阶段\"></p>\n<p>这里有15W无分类的历史记录，第一阶段也是最耗费人力、时间成本的阶段，需要非常仔细的把每一条数据对应类别，只有这样，才能称之为样本。没有做人工处理的数据，不能用于训练，在经典机器学习中，这一步尤其重要，后面我会说到为什么。总的来说就是<strong>有多少人工，就有多少智能</strong>。</p>\n<p>这一步是值得的，但是能不能缩短人工分类的时间？答案是肯定的。如上图所示，我们先人工分出5k样本，有朋友看到这里，也许会问，为什么是5k？而不是更大的数。这是经过验证的，5k刚好是能让大家接受的人工分类的样本数，对于我们的模型来说，5k的准确率已经相当不错了（超过90%）。为什么这么早就要聊准确率了？</p>\n<p>接下来，我们使用这5k数据做训练，然后，给下一个5k做预测（对新的未人工分类的数据做泛化），并保存这个结果。是的，你也想到了。这5k被模型分类了一遍，虽然不是完全正确的，但是也有相当一部分是被正确归类了，相当于多了好几个人帮我们做这件事（分类速度很快，但有点粗心的人）。然后我们只需要做二次校对，把归类错误的找出来放到正确的类别即可。</p>\n<p>不断的做增量的循环：<strong>先使用机器分类一遍，然后人工做校对。你会发现，随着数据量越来越大，正确率会非常高，后面基本就不用人工分类了，只需要扫一眼，没啥问题就过了。</strong></p>\n<p>让人振奋的是，这种加速机器学习的方法，原来已经被发表过了，被称为<code>主动学习</code>，链接：<a href=\"http://www.52nlp.cn/accelerate-machine-learning\" target=\"_blank\" rel=\"noopener\">加速机器学习：从主动学习到BERT和流体标注</a>。</p>\n<p>人工分完类后，我们可以得到下面的特征分布散点图（使用PCA降维TF-IDF的结果）。这个图的分布情况在一定程度上，决定了我们的模型与核函数选择</p>\n<p><img src=\"/images/基于统计机器学习的自动回复/特征分布情况tfidf将维.png\" alt=\"特征分布情况\"></p>\n<h3 id=\"第二阶段：新策略\"><a href=\"#第二阶段：新策略\" class=\"headerlink\" title=\"第二阶段：新策略\"></a>第二阶段：新策略</h3><ol>\n<li>结合关键字+机器分类做判断</li>\n<li>未训练或样本数较少时，使用关键字分类</li>\n<li>样本集大、高准确率时，使用机器分类</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>关键字分类</th>\n<th>机器分类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>匹配率</td>\n<td>18%</td>\n<td>30%</td>\n</tr>\n<tr>\n<td>准确率</td>\n<td>91%</td>\n<td>97%</td>\n</tr>\n</tbody>\n</table>\n<p>很快，我们就进入了第二阶段。可以发现，相比基于规则的文本分类，我们的新模型表现的更好。</p>\n<h3 id=\"第三阶段：正反馈闭环\"><a href=\"#第三阶段：正反馈闭环\" class=\"headerlink\" title=\"第三阶段：正反馈闭环\"></a>第三阶段：正反馈闭环</h3><p><img src=\"/images/基于统计机器学习的自动回复/第三阶段.png\" alt=\"第三阶段\"></p>\n<p>很快，我们进入了第三阶段。在第三阶段之前，模型训练的操作也是需要人员去跟进的。其实，整个系统可以产生一个<code>正反馈闭环</code>，模型训练可以使用定时脚本来触发。但是，为了保证模型训练的样本是正确的，还需要加入一个<code>校对</code>的环节。</p>\n<p>每一次产生新的投诉，都会带来一条新的匹配记录，这条新记录是不能作为样本来训练的，需要人工进行校对，校对后的结果才能进行训练。于是，我们可以制定一个模型训练时刻，在这个时刻前，需要保证新记录是经过人工校对后的结果。</p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><blockquote>\n<p>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限。</p>\n</blockquote>\n<p>我们做了一个准确率折线图，记录样本数从最初的1k到最后15W样本集的评估。可以发现，从13W样本集开始，准确率开始放缓，而不是继续往上攀升。</p>\n<p><img src=\"/images/基于统计机器学习的自动回复/历史投诉记录准确率.png\" alt=\"历史投诉记录准确率\"></p>\n","categories":["技术"],"tags":["机器学习","NLP","文本分类","监督学习"]},{"title":"可靠的PHP：契约式设计","url":"/2020/05/22/%E5%8F%AF%E9%9D%A0%E7%9A%84PHP%EF%BC%9A%E5%A5%91%E7%BA%A6%E5%BC%8F%E8%AE%BE%E8%AE%A1/","content":"<p>前段时间读了云风翻译的《程序员修炼之道》，里面提到了契约式设计（Design by Contract），在多人合作项目中，规范是大家共同履行的契约，但是大多数时候，我们总是在不经意间忽视规范的重要性。如果能在开发过程中，通过契约设计，也许能免掉不少麻烦，最重要的是，提高软件的可靠性和健壮性。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是契约\"><a href=\"#什么是契约\" class=\"headerlink\" title=\"什么是契约\"></a>什么是契约</h2><blockquote>\n<p>契约，最初是指双方或多方共同协议订立的有关买卖、抵押、租赁等关系的文书，可以理解为“守信用”。形式有精神契约和文字合同契约，对象多样，可以是：生意伙伴、挚友、爱人、国家、世界、全人类，以及对自己的契约等，可以用“文字合同”来约定，可以用“语言”来约定，还可以是“无言”的契约。</p>\n</blockquote>\n<p>—— 来自百度百科</p>\n<p>由上可知，关键词有：信用、双方（或多方）、约定。</p>\n<h2 id=\"什么是契约式设计\"><a href=\"#什么是契约式设计\" class=\"headerlink\" title=\"什么是契约式设计\"></a>什么是契约式设计</h2><blockquote>\n<p>契约式设计（英语：Design by Contract，缩写为 DbC），一种设计计算机软件的方法。这种方法要求软件设计者为软件组件定义正式的，精确的并且可验证的接口，这样，为传统的抽象数据类型又增加了先验条件、后验条件和不变式。这种方法的名字里用到的“契约”或者说“契约”是一种比喻，因为它和商业契约的情况有点类似。</p>\n</blockquote>\n<p>—— 来自WIKI</p>\n<p>由上可知，关键词有：软件方法、可验证、先验条件、后验条件、不变式。</p>\n<p><code>契约式设计</code>最早由伯特兰·迈耶于1986年提出，并在Eiffel语言实现了该设计。</p>\n<p>这是Eiffel语言对契约式设计的官方介绍：<a href=\"https://www.eiffel.com/values/design-by-contract/introduction/\" target=\"_blank\" rel=\"noopener\">Building bug-free O-O software: An Introduction to Design by Contract™</a>，不想看英文版，可以看看我翻译的中文版（如有错误，请不吝赐教）：<a href=\"https://funsoul.gitbook.io/notebook/she-ji-mo-shi/yi-gou-jian-wu-bug-mian-xiang-dui-xiang-ruan-jian-qi-yue-shi-she-ji-jian-jie\" target=\"_blank\" rel=\"noopener\">构建无bug面向对象软件：契约式设计简介</a></p>\n<p>契约一词来源自商业，在客户和供应商之间产生。双方必须针对某一协议（契约）履行义务，如有一方不履行相应的义务（责任），则视为毁约。可见契约在商业社会代表着<code>可靠</code>、<code>信任</code>。</p>\n<p>在面向对象编程范式中，契约式设计由几部分组成</p>\n<ul>\n<li>前置条件（对输入参数的值进行检验，如果不符合契约，则不会进入函数体，而是抛异常）</li>\n<li>后置条件（进入函数体后，针对例程参数做进一步检验，或处理资源释放等情况）</li>\n<li>类的不变式（针对类的整体属性做断言）</li>\n</ul>\n<p>在非面向对象编程语言，不变式可视为一种<code>状态</code></p>\n<h2 id=\"为什么要使用契约式设计\"><a href=\"#为什么要使用契约式设计\" class=\"headerlink\" title=\"为什么要使用契约式设计\"></a>为什么要使用契约式设计</h2><p>理解契约式设计前，先看另一种安全编程方法——防御性编程。其做法是，客户在调用供应方代码前，先做好前置检验。契约式设计和防御性编程中，如果客户违反了前置条件，供应方都会抛出异常，然后给到客户。但是契约式设计的做法更简单，不仅如此，还有以下明显的好处：</p>\n<ol>\n<li>面向对象：在编写继承、多态等重用性代码时，不满足契约会提前终止，解决隐性覆盖的问题</li>\n<li>文档化：例程的契约是很好的说明文档</li>\n<li>调试体：契约模块是一种单元测试</li>\n<li>质量保证：容易在调试阶段找出不满足契约的情况</li>\n<li>测试文化：面向契约设计可以引导供应方思考例程的边界条件</li>\n</ol>\n<h2 id=\"PHP如何实现契约式设计\"><a href=\"#PHP如何实现契约式设计\" class=\"headerlink\" title=\"PHP如何实现契约式设计\"></a>PHP如何实现契约式设计</h2><p>按照契约式设计思想，可以实现一个简易版的PHP库：<a href=\"https://github.com/funsoul/contract-php\" target=\"_blank\" rel=\"noopener\">contract-php</a>，这个库可以很方便的通过<code>注解</code>的方式定义函数的<code>前置条件</code>、<code>不变式</code>和<code>后置条件</code>。</p>\n<h3 id=\"通过代理和切面\"><a href=\"#通过代理和切面\" class=\"headerlink\" title=\"通过代理和切面\"></a>通过代理和切面</h3><p>在Python中，在不改变原功能代码的前提下，我们可以通过装饰器来对类或函数进行<code>切面</code>，提供诸如日志收集、缓存等功能。但PHP就没有那么好用的语法糖了，如果想要管理对象的生命周期，可以像Laravel框架，提供一个依赖管理容器，把对象的控制权交给容器，而容器在程序运行过程中，扮演着<code>代理</code>的角色。这样一来，容器就能在对象的生命周期上“做手脚”，比如在对象方法运行时提供切面功能，在方法执行前、执行后做一些增强的<code>装饰</code>。</p>\n<p><code>contract-php</code>库的存在意义只为说明契约式设计，无意实现一个DI容器，所以仅通过一个代理类来托管原类，在运行时反射原类方法，进而获取契约注解中的前置条件、不变式和后置条件，最后通过切面的方式，进行契约检查。</p>\n<p><strong>目前这个库是实验性的玩具，请不要在生产环境中使用，借助这个库，可以对契约式设计进行窥探，丰富我们的软件开发思路。</strong></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/funsoul/contract-php.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> contract-php</span><br><span class=\"line\">composer install</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><h4 id=\"通过注解来制定契约\"><a href=\"#通过注解来制定契约\" class=\"headerlink\" title=\"通过注解来制定契约\"></a>通过注解来制定契约</h4><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">@DbcRequire(condition=<span class=\"string\">\"a &gt;= 1, a &lt; 10, b &gt;= 1\"</span>)</span><br><span class=\"line\">@DbcInvariant(condition=<span class=\"string\">\"discount = 0.6\"</span>)</span><br><span class=\"line\">@DbcEnsure(callback=<span class=\"string\">\"ContractExamples\\MyEnsureCallback\"</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"目前支持的条件\"><a href=\"#目前支持的条件\" class=\"headerlink\" title=\"目前支持的条件\"></a>目前支持的条件</h4><ul>\n<li>gt &gt;</li>\n<li>ge &gt;=</li>\n<li>lt &lt;</li>\n<li>le &lt;=</li>\n<li>e =</li>\n<li>ne !=</li>\n</ul>\n<h4 id=\"自定义回调-如果条件不满足你的需求\"><a href=\"#自定义回调-如果条件不满足你的需求\" class=\"headerlink\" title=\"自定义回调 (如果条件不满足你的需求)\"></a>自定义回调 (如果条件不满足你的需求)</h4><p>MyRequireCallback.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">Contract</span>\\<span class=\"title\">ContractCallbackInterface</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRequireCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">ContractCallbackInterface</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">match</span><span class=\"params\">(array $arguments)</span>: <span class=\"title\">bool</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">list</span>($a, $b) = $arguments;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> $a &gt;= <span class=\"number\">1</span> || $b &gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"供应商\"><a href=\"#供应商\" class=\"headerlink\" title=\"供应商\"></a>供应商</h4><p>Test.php</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@var</span> float */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $discount = <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DbcRequire</span>(condition=\"a &gt;= 1, a &lt; 10, b &gt;= 1\")</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> int $a</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> int $b</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwoNums</span><span class=\"params\">(int $a, int $b)</span>: <span class=\"title\">int</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $a + $b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DbcRequire</span>(callback=\"ContractExamples\\MyRequireCallback\")</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DbcEnsure</span>(callback=\"ContractExamples\\MyEnsureCallback\")</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> int $a</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> int $b</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwoNumsCallback</span><span class=\"params\">(int $a, int $b)</span>: <span class=\"title\">int</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $a + $b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DbcRequire</span>(callback=\"ContractExamples\\MyRequireCallback\")</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DbcEnsure</span>(callback=\"ContractExamples\\MyEnsureCallback\")</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DbcInvariant</span>(condition=\"discount = 0.6\")</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> int $a</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> int $b</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> float</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiplyDiscount</span><span class=\"params\">(int $a, int $b)</span>: <span class=\"title\">float</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ($a + $b) * <span class=\"keyword\">$this</span>-&gt;discount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"客户\"><a href=\"#客户\" class=\"headerlink\" title=\"客户\"></a>客户</h4><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@var</span> ContractExamples\\Test $proxy */</span></span><br><span class=\"line\">$proxy = <span class=\"keyword\">new</span> Contract\\Proxy(<span class=\"keyword\">new</span> ContractExamples\\Test());</span><br><span class=\"line\"></span><br><span class=\"line\">$res1 = $proxy-&gt;addTwoNums(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$res2 = $proxy-&gt;addTwoNumsCallback(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$res3 = $proxy-&gt;multiplyDiscount(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">var_dump($res1, $res2, $res3);</span><br></pre></td></tr></table></figure>\n<h2 id=\"类比\"><a href=\"#类比\" class=\"headerlink\" title=\"类比\"></a>类比</h2><h3 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h3><p>断言是一种对逻辑条件运行时检查，属于契约式设计方法的子集，并不能完全实现契约式设计。理由如下</p>\n<ol>\n<li>面向对象编程的继承结构中，断言无法将契约传播，需要手动复制断言逻辑的代码。</li>\n<li>在某些语言中，断言也许会被全局关闭。</li>\n<li>传统的运行时系统和库不是为支持契约而设计的，因此这些调用不会检查。</li>\n</ol>\n<h3 id=\"测试驱动开发\"><a href=\"#测试驱动开发\" class=\"headerlink\" title=\"测试驱动开发\"></a>测试驱动开发</h3><ol>\n<li>测试方法一次只针对一种特定的情况，契约式设计可以定义出参数何时成立、何时失败的所有情况。</li>\n<li>契约式设计和断言在软件开发周期（设计、开发、部署）中永远存在，而测试只发生在“测试环节”。</li>\n<li>测试更多只检查公共接口，没有重点考虑不变式。</li>\n</ol>\n<p><strong>契约式设计和测试都有必要，不可完全替代。</strong></p>\n<h3 id=\"尽早崩溃理念\"><a href=\"#尽早崩溃理念\" class=\"headerlink\" title=\"尽早崩溃理念\"></a>尽早崩溃理念</h3><p>契约式设计非常符合尽早崩溃理念，因为死掉的程序不会说谎，不要让异常传播，而是尽早崩溃，让问题及早暴露出来，这是更务实的做法。如Erlang、Elixir语言的设计哲学：</p>\n<blockquote>\n<p>防御式编程是在浪费时间，让它崩溃！</p>\n</blockquote>\n<p>故障由专门的<code>监控程序</code>掌控，在程序崩溃时进行特定的<code>善后</code>工作。从而形成一种由<code>监管程序树</code>构成的设计。</p>\n<h2 id=\"模式？规范？\"><a href=\"#模式？规范？\" class=\"headerlink\" title=\"模式？规范？\"></a>模式？规范？</h2><p>契约式设计不是一种设计模式，而是规范。除了Eiffel类语言，大多数编程语言（C/C++/C#/Java/PHP/Golang/Python..）都没有实现契约式设计，而是把异常、断言、返回值和程序终止指令交给开发人员，由开发人员自己制定规范。</p>\n<p>喜欢防御性编程的开发人员，会在任何地方编写校验代码，这会编写许多一致的代码（违反DRY原则）。</p>\n<p>契约式设计规范可以防止巧合式编程，通过契约设计，可以在程序运行之前考虑边界条件，对于不符合契约的客户，提前抛出问题。</p>\n<h2 id=\"尾\"><a href=\"#尾\" class=\"headerlink\" title=\"尾\"></a>尾</h2><p>在《程序员修炼之道》一书的第4章“务实的偏执”中，对契约式设计有很好的利弊分析，推荐阅读。</p>\n<blockquote>\n<p>文档化及对主张进行检验是契约式设计的核心</p>\n</blockquote>\n","categories":["项目"],"tags":["PHP","契约式设计"]},{"title":"安装impala-shell遇到的问题","url":"/2017/12/05/%E5%AE%89%E8%A3%85impala-shell%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"<h3 id=\"下载rpm包\"><a href=\"#下载rpm包\" class=\"headerlink\" title=\"下载rpm包\"></a>下载rpm包</h3><p> <a href=\"http://archive.cloudera.com/cdh5/redhat/6/x86_64/cdh/5.4.9/RPMS/x86_64/\" target=\"_blank\" rel=\"noopener\">impala-shell-2.2.0+cdh5.4.9+0-1.cdh5.4.9.p0.30.el6.x86_64.rpm</a></p>\n<a id=\"more\"></a>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># yum install python-setuptools</span><br><span class=\"line\"># rpm -ivh impala-shell-2.2.0+cdh5.4.9+0-1.cdh5.4.9.p0.30.el6.x86_64.rpm</span><br></pre></td></tr></table></figure>\n<h4 id=\"报错\"><a href=\"#报错\" class=\"headerlink\" title=\"报错\"></a>报错</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: Failed dependencies: libpython2.6.so.1.0()(64bit) is needed by impala-shell-2.2.0+cdh5.4.9+0-1.cdh5.4.9.p0.30.el6.x86_64.rpm</span><br></pre></td></tr></table></figure>\n<h4 id=\"下载并安装\"><a href=\"#下载并安装\" class=\"headerlink\" title=\"下载并安装\"></a>下载并安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -Uvh lib64python2.6-2.6.6-1mdv2011.0.x86_64.rpm</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># impala-shell</span><br></pre></td></tr></table></figure>\n<h4 id=\"报错-1\"><a href=\"#报错-1\" class=\"headerlink\" title=\"报错\"></a>报错</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">···</span><br><span class=\"line\">···</span><br><span class=\"line\">ImportError: libsasl2.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<h4 id=\"检查sasl\"><a href=\"#检查sasl\" class=\"headerlink\" title=\"检查sasl\"></a>检查sasl</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep sasl</span><br><span class=\"line\">rpm -ql cyrus-sasl-lib</span><br></pre></td></tr></table></figure>\n<p>发现 libsasl2.so.3被 cyrus-sasl-lib 安装在了 /usr/lib64/.这个目录下</p>\n<h4 id=\"重装sasl\"><a href=\"#重装sasl\" class=\"headerlink\" title=\"重装sasl\"></a>重装sasl</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip uninstall sasl</span><br><span class=\"line\">pip install sasl</span><br></pre></td></tr></table></figure>\n<p>pip不存在</p>\n<h4 id=\"安装pip\"><a href=\"#安装pip\" class=\"headerlink\" title=\"安装pip\"></a>安装pip</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yun install -y pip</span><br><span class=\"line\">Nothing to do</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装epel扩展源\"><a href=\"#安装epel扩展源\" class=\"headerlink\" title=\"安装epel扩展源\"></a>安装epel扩展源</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum -y install epel-release</span><br><span class=\"line\">yum -y install python-pip</span><br></pre></td></tr></table></figure>\n<h4 id=\"卸载sasl\"><a href=\"#卸载sasl\" class=\"headerlink\" title=\"卸载sasl\"></a>卸载sasl</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip uninstall sasl</span><br></pre></td></tr></table></figure>\n<p>无法删除</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cannot uninstall requirement sasl, not installed</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装sasl\"><a href=\"#安装sasl\" class=\"headerlink\" title=\"安装sasl\"></a>安装sasl</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip install sasl</span><br><span class=\"line\"></span><br><span class=\"line\">sasl/saslwrapper.cpp:8:22: fatal error: pyconfig.h: No such file or directory</span><br><span class=\"line\">#include &quot;pyconfig.h&quot;</span><br><span class=\"line\">^</span><br><span class=\"line\">compilation terminated.</span><br><span class=\"line\">error: command &apos;gcc&apos; failed with exit status 1</span><br></pre></td></tr></table></figure>\n<h4 id=\"继续找问题，回到这一步\"><a href=\"#继续找问题，回到这一步\" class=\"headerlink\" title=\"继续找问题，回到这一步\"></a>继续找问题，回到这一步</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ImportError: libsasl2.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Sometimes these version problems can be resolved by creating a symbolic link with another version of the same library. If you have libsasl2.so installed, create a linked file libsasl2.so.2 for the same:</span><br><span class=\"line\"></span><br><span class=\"line\">sudo ln -s /usr/lib64/libsasl2.so /usr/lib64/libsasl2.so.2</span><br></pre></td></tr></table></figure>","categories":["技术"],"tags":["问题排查","impala"]},{"title":"使用C++扩展PHP","url":"/2020/06/15/%E4%BD%BF%E7%94%A8cplusplus%E6%89%A9%E5%B1%95PHP/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><a href=\"https://github.com/CopernicaMarketingSoftware/PHP-CPP\" target=\"_blank\" rel=\"noopener\">PHP-CPP</a>是一个用来开发PHP扩展的C++库，它提供了一个文档完善且易于使用的类集合，这些类可以用于为PHP构建本地扩展。有完整的<a href=\"http://www.php-cpp.com/documentation/introduction\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<a id=\"more\"></a>\n<p>注意：仅适用于PHP7。这个库已经更新为适用于 PHP 7.0 及以上版本。如果你想为旧版本的 PHP 创建扩展，请使用 <a href=\"https://github.com/CopernicaMarketingSoftware/PHP-CPP-LEGACY\" target=\"_blank\" rel=\"noopener\">PHP-CPP-LEGACY</a> 库。PHP-CPP 和 PHP-CPP-LEGACY 库有（几乎）相同的 API，所以你可以很容易地将 PHP 5.*的扩展移植到 PHP 7，反之亦然。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ol>\n<li>注意：目前，PHP-CPP仅适用于Linux或OSX系统</li>\n<li>本文实验环境为OSX</li>\n</ol>\n<h3 id=\"下载源码\"><a href=\"#下载源码\" class=\"headerlink\" title=\"下载源码\"></a>下载源码</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> -b v2.1.0 https://github.com/CopernicaMarketingSoftware/PHP-CPP.git</span><br></pre></td></tr></table></figure>\n<p>打开<code>Makefile</code>文件（Makefile是一个保存编译器设置和指令的文件），大多数情况下，该文件中的默认配置已经足够好，但是你或许需要针对自己的环境做一些轻微的改动，比如改变安装目录或者选择自己的编译器。</p>\n<h3 id=\"开始构建PHP-CPP库\"><a href=\"#开始构建PHP-CPP库\" class=\"headerlink\" title=\"开始构建PHP-CPP库\"></a>开始构建PHP-CPP库</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<h3 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h3><ol>\n<li>如果你使用OSX来编译构建，可能会遇到<code>链接</code>和<code>unresolved symbol</code>错误，如果你正面临此问题，那么需要对<code>Makefile</code>文件做一些改动，在这个 Makefile的某个地方有一个选项<code>LINKER_FLAGS</code>。修改为<code>-shared -undefined dynamic_lookup</code>。</li>\n<li><a href=\"https://github.com/CopernicaMarketingSoftware/PHP-CPP/issues/368\" target=\"_blank\" rel=\"noopener\">ld: unknown option: -soname clang: error: linker command failed with exit code 1</a></li>\n</ol>\n<h3 id=\"安装PHP-CPP库到系统中\"><a href=\"#安装PHP-CPP库到系统中\" class=\"headerlink\" title=\"安装PHP-CPP库到系统中\"></a>安装PHP-CPP库到系统中</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n<h2 id=\"PHP如何载入扩展\"><a href=\"#PHP如何载入扩展\" class=\"headerlink\" title=\"PHP如何载入扩展\"></a>PHP如何载入扩展</h2><p>你可能知道在类unix的系统中，本地的PHP扩展名被编译成<code>.so</code>文件，在Windows环境中，编译成<code>.dll</code>文件，而全局的<code>php.ini</code>文件保存了系统中所有可用的扩展的列表，这意味着如果你正在创建自己的扩展，你也要创建这样的<code>.so</code>或<code>.dll</code>文件，并且你必须更新PHP配置文件，以便你自己的扩展被PHP加载。</p>\n<h3 id=\"get-module启动函数\"><a href=\"#get-module启动函数\" class=\"headerlink\" title=\"get_module启动函数\"></a>get_module启动函数</h3><p>在解释如何创建自己的扩展之前，我们先解释一下 PHP 如何加载一个扩展。当 PHP 启动时，它从配置目录中加载 <code>*.ini</code> 配置文件，对于这些配置文件中的每一行 <code>extension=name.so</code>，它都会打开相应的库，并调用其中的<code>get_module()</code>函数。因此，每个扩展库（你的扩展也是）都必须定义并实现这个<code>get_module()</code>函数。这个函数在库加载后就被 PHP 调用（因此在处理 pageviews 之前就被调用了），它应该返回一个指向一个结构的内存地址，这个结构保存了所有扩展库提供的函数、类、变量和常量的信息。</p>\n<p><code>get_module()</code>返回的结构是在Zend引擎的头文件中定义的，但它是一个相当复杂的结构，而且没有很好的文档。幸运的是，PHP-CPP库让你的生活变得更简单，并提供了一个扩展类，可以用来代替。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  tell the compiler that the get_module is a pure C function</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Function that is called by PHP right after the PHP process</span></span><br><span class=\"line\"><span class=\"comment\">     *  has started, and that returns an address of an internal PHP</span></span><br><span class=\"line\"><span class=\"comment\">     *  strucure with all the details and features of your extension</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*   a pointer to an address that is understood by PHP</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// static(!) Php::Extension object that should stay in memory</span></span><br><span class=\"line\">        <span class=\"comment\">// for the entire duration of the process (that's why it's static)</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// @todo    add your own functions, classes, namespaces to the extension</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，你看到了<code>get_module()</code>函数的一个非常直接的实现。每个使用 PHP-CPP 库的 PHP 扩展都或多或少地实现了这个函数，它是每个扩展的起点。有一些元素需要特别注意，首先，你看到的唯一的头文件是 phpcpp.h 头文件。如果你使用PHP-CPP库来构建你自己的扩展，你不需要包含Zend引擎的那些复杂的、非结构化的、大部分没有文档的头文件——你需要的只是PHP-CPP库的这个单一的phpcpp.h头文件。如果你坚持的话，你当然也可以包含核心 PHP 引擎的头文件——但你不必这样做。PHP-CPP 负责处理 PHP 引擎的内部，并提供给你一个简单易用的 API。</p>\n<p>接下来你会注意到，我们将<code>get_module()</code>函数放在了一个 <code>extern &quot;C&quot;</code>的代码块中。正如库的名字所透露的那样，PHP-CPP 是一个 C++ 库。然而，PHP 希望你的库，尤其是 <code>get_module()</code> 函数是用 C 而不是 C++ 实现的。这就是为什么我们把 <code>get_module()</code> 函数包装在一个 <code>extern &quot;C&quot;</code> 块中。这将指示 C++ 编译器 <code>get_module()</code> 是一个常规的 C 函数，并且它不应该对它进行任何 C++ 名称的篡改。</p>\n<p>PHP-CPP 库定义了一个 <code>PHPCPP_EXPORT</code> 宏，它应该放在 <code>get_module()</code> 函数的前面。这个宏确保<code>get_module()</code>函数是公开导出的，因此可以被PHP调用。这个宏根据编译器和操作系统的不同有不同的实现。</p>\n<p>顺便说一下，这也是 PHP-CPP 提供的唯一一个宏。PHP-CPP打算成为一个普通的C++库，不使用魔术或预处理器的技巧。你所看到的就是你所得到的。如果某些东西看起来像函数，你可以肯定它实际上就是一个函数，而当某些东西看起来像一个变量，你可以肯定它也是一个变量。</p>\n<p>我们继续往下看。在<code>get_module()</code>函数里面，<code>Php::Extension</code>对象被实例化，并被返回。至关重要的是，你必须为这个<code>Php::Extension</code>类创建一个静态实例，因为这个对象必须在PHP进程的整个生命周期内存在，而不仅仅是在调用<code>get_module()</code>的期间。构造函数有两个参数：扩展名和版本号。</p>\n<p><code>get_module()</code> 函数的最后一步是返回扩展对象。这看起来很奇怪，因为get_module()函数应该返回一个指向void的指针，而不是一个完整的Php::Extension对象。为什么编译器没有报告这个问题呢？那是因为<code>Php::Extension</code>类有一个<code>cast-to-void-pointer-operator</code>。因此，虽然看起来你返回的是完整的扩展对象，但实际上你只是返回了一个指向一个数据结构的内存地址，这个数据结构被 PHP 核心引擎所理解，并且保存了你的扩展的所有细节。</p>\n<p>请注意，上面的例子还没有导出任何<code>本地函数</code>或<code>本地类</code>到PHP中——它只是创建了扩展。</p>\n<h2 id=\"编写第一个扩展\"><a href=\"#编写第一个扩展\" class=\"headerlink\" title=\"编写第一个扩展\"></a>编写第一个扩展</h2><p>当你创建你自己的 PHP-CPP 扩展时，你也必须编译和部署它。一个普通的PHP脚本只需要复制到web服务器上就可以部署，但是部署一个扩展需要花费更多的精力：你需要一个<code>Makefile</code>，一个扩展专用的<code>php.ini</code>文件，当然还有实现扩展的<code>*.cpp</code>文件。</p>\n<p>为了帮助你完成这些步骤，我们创建了一个几乎是空的扩展，包含了所有需要的文件。它包含了一个示例<code>Makefile</code>，一个示例配置文件，以及第一个<code>main.cpp</code>文件，其中的<code>get_module()</code>调用已经被实现。这为你开发扩展提供了一个良好的开端。</p>\n<p>该扩展代码在PHP-CPP源码的<code>Example</code>目录下，本文后面的所有扩展源码都在这里可以找到。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── CallPhpFunctions</span><br><span class=\"line\">│   ├── 30-callphpfunction.ini</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── callphpfunction.cpp</span><br><span class=\"line\">│   └── callphpfunction.php</span><br><span class=\"line\">├── ConstStaticProp</span><br><span class=\"line\">│   ├── cpp</span><br><span class=\"line\">│   ├── readme</span><br><span class=\"line\">│   └── test.php</span><br><span class=\"line\">├── CppClassesInPhp</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── check_map.php</span><br><span class=\"line\">│   ├── cppclassinphp.cpp</span><br><span class=\"line\">│   ├── cppclassinphp.ini</span><br><span class=\"line\">│   ├── cppclassinphp.php</span><br><span class=\"line\">│   └── includeMyCustomClass.h</span><br><span class=\"line\">├── DlUnrestricted</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── dlunrestricted.cpp</span><br><span class=\"line\">│   ├── dlunrestricted.ini</span><br><span class=\"line\">│   └── dlunrestricted.php</span><br><span class=\"line\">├── EmptyExtension</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── main.cpp</span><br><span class=\"line\">│   └── yourextension.ini</span><br><span class=\"line\">├── Exceptions</span><br><span class=\"line\">│   ├── ExceptionCatch</span><br><span class=\"line\">│   └── ExceptionThrow</span><br><span class=\"line\">├── Extension</span><br><span class=\"line\">│   ├── 30-phpcpp.ini</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── extension.cpp</span><br><span class=\"line\">│   ├── extension.o</span><br><span class=\"line\">│   ├── extension.php</span><br><span class=\"line\">│   └── extension.so</span><br><span class=\"line\">├── FunctionNoParameters</span><br><span class=\"line\">│   ├── 30-functionnoparameters.ini</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── functionnoparameters.cpp</span><br><span class=\"line\">│   └── functionnoparameters.php</span><br><span class=\"line\">├── FunctionReturnValue</span><br><span class=\"line\">│   ├── 30-functionreturnvalue.ini</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── functionreturnvalue.cpp</span><br><span class=\"line\">│   └── functionreturnvalue.php</span><br><span class=\"line\">├── FunctionVoid</span><br><span class=\"line\">│   ├── 30-functionvoid.ini</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── functionvoid.cpp</span><br><span class=\"line\">│   ├── functionvoid.o</span><br><span class=\"line\">│   ├── functionvoid.php</span><br><span class=\"line\">│   └── functionvoid.so</span><br><span class=\"line\">├── FunctionWithParameters</span><br><span class=\"line\">│   ├── 30-functionwithparameters.ini</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── functionwithparameters.cpp</span><br><span class=\"line\">│   └── functionwithparameters.php</span><br><span class=\"line\">├── Globals</span><br><span class=\"line\">│   ├── 30-globals.ini</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── globals.cpp</span><br><span class=\"line\">│   └── globals.php</span><br><span class=\"line\">├── Makefile</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── ReturnObject</span><br><span class=\"line\">│   ├── Makefile</span><br><span class=\"line\">│   ├── child.h</span><br><span class=\"line\">│   ├── main.cpp</span><br><span class=\"line\">│   ├── master.h</span><br><span class=\"line\">│   ├── returnobject.ini</span><br><span class=\"line\">│   └── test.php</span><br><span class=\"line\">└── simple</span><br><span class=\"line\">    ├── 30-phpcpp.ini</span><br><span class=\"line\">    ├── Makefile</span><br><span class=\"line\">    ├── simple.cpp</span><br><span class=\"line\">    └── simple.php</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看例子：Extension\"><a href=\"#查看例子：Extension\" class=\"headerlink\" title=\"查看例子：Extension\"></a>查看例子：Extension</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── 30-phpcpp.ini   <span class=\"comment\"># 扩展声明文件</span></span><br><span class=\"line\">├── Makefile        <span class=\"comment\"># 构建文件</span></span><br><span class=\"line\">├── extension.cpp   <span class=\"comment\"># 扩展源码文件</span></span><br><span class=\"line\">└── extension.php   <span class=\"comment\"># 测试文件</span></span><br></pre></td></tr></table></figure>\n<p>修改<code>Makefile</code>文件中下面两行内容。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">LIBRARY_DIR\t\t= <span class=\"variable\">$(<span class=\"built_in\">shell</span> php-config --extension-<span class=\"built_in\">dir</span>)</span></span><br><span class=\"line\">PHP_CONFIG_DIR\t= /usr/local/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行用于获取扩展的目录</li>\n<li>第二行为你的PHP配置目录，用于存放你的扩展声明<code>extension=name.so</code></li>\n</ul>\n<p>通过以下步骤安装扩展</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;make</span><br><span class=\"line\">g++ -Wall -c -I. -O2 -std=c++11 -fpic -o extension.o extension.cpp</span><br><span class=\"line\">g++ -Wall -shared -O2  -o extension.so extension.o -lphpcpp</span><br><span class=\"line\">&gt;&gt;sudo make install</span><br><span class=\"line\">cp -f extension.so /usr/<span class=\"built_in\">local</span>/Cellar/php@7.1/7.1.30/pecl/20160303</span><br><span class=\"line\">cp -f 30-phpcpp.ini     /usr/<span class=\"built_in\">local</span>/etc/php/7.1/conf.d</span><br></pre></td></tr></table></figure>\n<p>测试扩展</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;php -m | grep extension</span><br><span class=\"line\">my_simple_extension</span><br><span class=\"line\">&gt;&gt;php extension.php</span><br><span class=\"line\">Array</span><br><span class=\"line\">(</span><br><span class=\"line\">    [67] =&gt; my_simple_extension</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"输出和错误\"><a href=\"#输出和错误\" class=\"headerlink\" title=\"输出和错误\"></a>输出和错误</h2><p>你可以使用常规的C++流来进行IO，使用常规的<code>&lt;&lt;</code>操作符和特殊的函数，如<code>std::endl</code>。但是使用<code>std::cout</code>和<code>std::cerr</code>流并不是一个好主意。</p>\n<p>当 PHP 作为 webserver 模块运行时，stdout 被重定向到 webserver 进程最初启动的终端。在生产服务器上，这样的终端是不活动的，所以任何发送到stdout的输出都会丢失。因此，在webserver模块中运行的扩展中使用<code>std::cout</code>是不行的。但是即使 PHP 以 <code>CLI</code> 脚本的形式运行（并且 <code>std::cout</code> 也能工作），也不应该直接向 <code>stdout</code> 写入。写入<code>stdout</code>会绕过所有PHP用户空间脚本可能设置的输出处理程序。</p>\n<p>PHP-CPP 库提供了一个 <code>Php::out</code> 流用来替代标准输出。这个<code>Php::out</code>变量是众所周知的<code>std::ostream</code>类的一个实例，并且尊重PHP中所有的输出缓冲设置。它的作用与PHP脚本中的echo()函数基本相同。</p>\n<p><code>Php::out</code>是一个普通的 <code>std::ostream</code> 对象。其结果是它使用了一个需要刷新的内部缓冲区。当你在输出中添加<code>std::endl</code>或明确添加<code>std::flush</code>时，刷新会自动发生。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Example function that shows how to generate output</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">example</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 等同于php中的echo()</span></span><br><span class=\"line\">    Php::out &lt;&lt; <span class=\"string\">\"example output\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不带换行符，刷新输出缓冲</span></span><br><span class=\"line\">    Php::out &lt;&lt; <span class=\"string\">\"example output\"</span> &lt;&lt; <span class=\"built_in\">std</span>::flush;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 也可以直接调用flush</span></span><br><span class=\"line\">    Php::out &lt;&lt; <span class=\"string\">\"example output\"</span>;</span><br><span class=\"line\">    Php::out.flush();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 也可以直接使用echo</span></span><br><span class=\"line\">    Php::echo(<span class=\"string\">\"Example output\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你想触发一个PHP错误（相当于PHP trigger_error()的C++函数），你可以使用<code>Php::error</code>、<code>Php::notice</code>、<code>Php::warning</code>和<code>Php::deprecated</code>流中的一个。这些也是<code>std::ostream</code>类的实例。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Example function that shows how to generate output</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">example</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 输出一个 PHP notice</span></span><br><span class=\"line\">    Php::notice &lt;&lt; <span class=\"string\">\"this is a notice\"</span> &lt;&lt; <span class=\"built_in\">std</span>::flush;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出一个 PHP warning</span></span><br><span class=\"line\">    Php::warning &lt;&lt; <span class=\"string\">\"this is a warning\"</span> &lt;&lt; <span class=\"built_in\">std</span>::flush;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通知用户，该函数已经不推荐使用</span></span><br><span class=\"line\">    Php::deprecated &lt;&lt; <span class=\"string\">\"this method is deprecated\"</span> &lt;&lt; <span class=\"built_in\">std</span>::flush;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出一个 PHP fatal error</span></span><br><span class=\"line\">    Php::error &lt;&lt; <span class=\"string\">\"fatal error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::flush;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当输出 fatal error 后，这一行不会执行</span></span><br><span class=\"line\">    Php::out &lt;&lt; <span class=\"string\">\"regular output\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子中，你可以看到我们使用了 <code>std::flush</code> 而不是 <code>std::endl</code>。原因是<code>std::endl</code>内部做了两件事：它附加了一个换行符，以及它刷新了缓冲区。对于错误、通知和警告，我们不需要换行，但我们仍然需要刷新缓冲区来实际生成输出。</p>\n<p><code>Php::error</code>流有一个非常奇特的地方：当你刷新它时，PHP脚本以一个致命的错误结束，而你的C++代码立即退出！！在引擎下面，PHP引擎做了一个<code>longjump</code>，到了Zend引擎深处的一个地方。在这个例子中，<code>Php::out &lt;&lt; &quot;regular output&quot;;</code> 语句从未被执行。</p>\n<p>这一切都很不寻常，而且（根据我们的说法）与软件工程的一般规则相冲突。一个输出生成函数的行为不应该像抛出一个异常。看起来像正常代码的代码，也应该表现得像正常代码一样，而不应该做意想不到的事情，比如跳出当前的调用栈。因此，我们建议不要使用<code>Php::error</code>，或者在使用它时要格外小心。</p>\n<h2 id=\"注册原生函数\"><a href=\"#注册原生函数\" class=\"headerlink\" title=\"注册原生函数\"></a>注册原生函数</h2><h3 id=\"无返回值：FunctionVoid\"><a href=\"#无返回值：FunctionVoid\" class=\"headerlink\" title=\"无返回值：FunctionVoid\"></a>无返回值：FunctionVoid</h3><p>在<code>get_module</code>中声明扩展信息</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create extension</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_function_void\"</span>,<span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add function to extension</span></span><br><span class=\"line\">extension.add&lt;my_function_void&gt;(<span class=\"string\">\"my_void_function\"</span>);</span><br></pre></td></tr></table></figure>\n<p>编写一个直接打印字符串的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">my_function_void</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"In my_function_void()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"有返回值：FunctionReturnValue\"><a href=\"#有返回值：FunctionReturnValue\" class=\"headerlink\" title=\"有返回值：FunctionReturnValue\"></a>有返回值：FunctionReturnValue</h3><p>在<code>get_module</code>中声明扩展信息</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create extension</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_function_return_value\"</span>,<span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add function to extension</span></span><br><span class=\"line\">extension.add&lt;my_return_value_function&gt;(<span class=\"string\">\"my_return_value_function\"</span>);</span><br></pre></td></tr></table></figure>\n<p>通过<code>Php::Value</code>来标示返回值类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  my_return_value_function()</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return Php::Value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">my_return_value_function</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"42\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Php::Value</code>是存储在Zend引擎中的值的基类。value类的一个实例代表了在PHP环境用户空间中存在的一个变量，例如作为全局变量、函数中的局部变量、对象或数组的成员。可以是标量类型也可以是更复杂的数组或对象类型。</p>\n<p>在内核中，Zend引擎使用<code>zval</code>对象来实现。这些<code>zval</code>对象持有引用计数和引用配置。PHP-CPP的<code>Value</code>类负责处理这些工作，所以你需要做的就是使用这个类的对象。</p>\n<h2 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h2><h3 id=\"查看例子：functionwithparameters\"><a href=\"#查看例子：functionwithparameters\" class=\"headerlink\" title=\"查看例子：functionwithparameters\"></a>查看例子：functionwithparameters</h3><h4 id=\"如何获取未定义参数\"><a href=\"#如何获取未定义参数\" class=\"headerlink\" title=\"如何获取未定义参数\"></a>如何获取未定义参数</h4><p>添加一个获取未定义参数的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add function, with undefined parameters, to extension</span></span><br><span class=\"line\">extension.add&lt;my_with_undefined_parameters_function&gt;(<span class=\"string\">\"my_with_undefined_parameters_function\"</span>);</span><br></pre></td></tr></table></figure>\n<p>可以通过<code>Php::Parameters</code>来获取函数参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">my_with_undefined_parameters_function</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; params.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Parameter \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; params[i] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这个例子，尽管在定义函数时没有定义参数，但是也可以通过<code>Php::Parameters</code>来获取，非常神奇。</p>\n<h4 id=\"如何写一个加法运算函数\"><a href=\"#如何写一个加法运算函数\" class=\"headerlink\" title=\"如何写一个加法运算函数\"></a>如何写一个加法运算函数</h4><p>添加一个有参数的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add function, with defined numeric parameters, to extension</span></span><br><span class=\"line\">extension.add&lt;my_with_defined_parameters_function&gt;(<span class=\"string\">\"my_with_defined_parameters_function\"</span>, &#123;</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"x\"</span>, Php::Type::Numeric),</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"y\"</span>, Php::Type::Numeric)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>编写函数定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  my_with_defined_parameters_function()</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  Php::Parameters     the given parameters</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return Php::Value          Param[0] and Param[1] added</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">my_with_defined_parameters_function</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; params.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Parameter \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; params[i] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> params[<span class=\"number\">0</span>] + params[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数的含义是，接收两个整型数字，并返回求和结果。</p>\n<h4 id=\"如何传递引用\"><a href=\"#如何传递引用\" class=\"headerlink\" title=\"如何传递引用\"></a>如何传递引用</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add function, with defined parameter by reference, to extension</span></span><br><span class=\"line\">extension.add&lt;my_with_defined_parameters_reference_function&gt;(<span class=\"string\">\"my_with_defined_parameters_reference_function\"</span>, &#123;</span><br><span class=\"line\">    Php::ByRef(<span class=\"string\">\"string\"</span>, Php::Type::String)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>修改传递进来的参数值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  This functions receives a reference to a variable. When the variable is altered,</span></span><br><span class=\"line\"><span class=\"comment\"> *  so is the value in the php script.</span></span><br><span class=\"line\"><span class=\"comment\"> *  my_with_defined_parameters_reference_function()</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  Php::Parameters     the given parameters</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">my_with_defined_parameters_reference_function</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    params[<span class=\"number\">0</span>] = <span class=\"string\">\"I changed!\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何接收数组\"><a href=\"#如何接收数组\" class=\"headerlink\" title=\"如何接收数组\"></a>如何接收数组</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add function, with defined array parameter, to extension</span></span><br><span class=\"line\">extension.add&lt;my_with_defined_array_parameters_function&gt;(<span class=\"string\">\"my_with_defined_array_parameters_function\"</span>, &#123;</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"array\"</span>, Php::Type::Array)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何接收对象\"><a href=\"#如何接收对象\" class=\"headerlink\" title=\"如何接收对象\"></a>如何接收对象</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add function, with defined object parameter, to extension</span></span><br><span class=\"line\">extension.add&lt;my_with_defined_object_parameters_function&gt;(<span class=\"string\">\"my_with_defined_object_parameters_function\"</span>, &#123;</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"myClassObjVar\"</span>, <span class=\"string\">\"MyPhpClass\"</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Php-Type支持情况\"><a href=\"#Php-Type支持情况\" class=\"headerlink\" title=\"Php::Type支持情况\"></a>Php::Type支持情况</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Supported types for variables</span></span><br><span class=\"line\"><span class=\"comment\"> *  The values are the same as the ones used internally in Zend</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Type</span> :</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> &#123;</span><br><span class=\"line\">    Undefined       =   <span class=\"number\">0</span>,  <span class=\"comment\">// Variable is not set</span></span><br><span class=\"line\">    Null            =   <span class=\"number\">1</span>,  <span class=\"comment\">// Null will allow any type</span></span><br><span class=\"line\">    False           =   <span class=\"number\">2</span>,  <span class=\"comment\">// Boolean false</span></span><br><span class=\"line\">    True            =   <span class=\"number\">3</span>,  <span class=\"comment\">// Boolean true</span></span><br><span class=\"line\">    Numeric         =   <span class=\"number\">4</span>,  <span class=\"comment\">// Integer type</span></span><br><span class=\"line\">    Float           =   <span class=\"number\">5</span>,  <span class=\"comment\">// Floating point type</span></span><br><span class=\"line\">    String          =   <span class=\"number\">6</span>,  <span class=\"comment\">// A string obviously</span></span><br><span class=\"line\">    Array           =   <span class=\"number\">7</span>,  <span class=\"comment\">// An array of things</span></span><br><span class=\"line\">    Object          =   <span class=\"number\">8</span>,  <span class=\"comment\">// An object</span></span><br><span class=\"line\">    Resource        =   <span class=\"number\">9</span>,  <span class=\"comment\">// A resource</span></span><br><span class=\"line\">    Reference       =  <span class=\"number\">10</span>,  <span class=\"comment\">// Reference to another value (can be any type!)</span></span><br><span class=\"line\">    Constant        =  <span class=\"number\">11</span>,  <span class=\"comment\">// A constant value</span></span><br><span class=\"line\">    ConstantAST     =  <span class=\"number\">12</span>,  <span class=\"comment\">// I think an Abstract Syntax tree, not quite sure</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// \"fake types\", not quite sure what that means</span></span><br><span class=\"line\">    Bool            = <span class=\"number\">13</span>,   <span class=\"comment\">// You will never get this back as a type</span></span><br><span class=\"line\">    Callable        = <span class=\"number\">14</span>,   <span class=\"comment\">// I don't know why this is a \"fake\" type</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ol>\n<li>使用<code>Php::ByVal</code>定义接收参数（值传递）</li>\n<li>使用<code>Php::ByRef</code>定义接收引用</li>\n<li><code>Php::Parameters</code>是一个数组，用来获取参数</li>\n</ol>\n<h2 id=\"调用函数\"><a href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"></a>调用函数</h2><p>首先让我们弄清楚一件事。 运行编译后的机器码比运行PHP代码快得多。 因此，一旦最终调用了C++函数或C++方法，通常就将参数转换为本地变量，然后开始运行自己的快速算法。从那时起，您就不想调用其他PHP函数。</p>\n<p>但是，如果您要调用PHP函数（无论是Zend内置的函数，在扩展中定义的函数，还是来自PHP用户空间的函数），也是可以做到的。</p>\n<h3 id=\"查看例子：callphpfunction\"><a href=\"#查看例子：callphpfunction\" class=\"headerlink\" title=\"查看例子：callphpfunction\"></a>查看例子：callphpfunction</h3><p>添加一个含有两个参数的函数，第一个参数是回调函数，第二个参数是数字</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add function to extension</span></span><br><span class=\"line\">extension.add&lt;call_php_function&gt;(<span class=\"string\">\"call_php_function\"</span>, &#123;</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"addFunc\"</span>, Php::Type::Callable),</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"x\"</span>, Php::Type::Numeric)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  call_php_function()</span></span><br><span class=\"line\"><span class=\"comment\"> *  Calls a function in PHP space.</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param      &amp;params</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return     Php::Value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">call_php_function</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// check whether the parameter is callable</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!params[<span class=\"number\">0</span>].isCallable()) <span class=\"keyword\">throw</span> Php::Exception(<span class=\"string\">\"Not a callable type.\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// perform the callback</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> params[<span class=\"number\">0</span>](params[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Lambda（匿名）函数\"><a href=\"#Lambda（匿名）函数\" class=\"headerlink\" title=\"Lambda（匿名）函数\"></a>Lambda（匿名）函数</h2><p>C++和PHP都支持lambda函数或匿名函数（在C++世界里，”lambda “这个词用得最多，PHPer讲的是 “匿名函数”）。使用 PHP-CPP 可以将这些函数从一种语言传递到另一种语言。可以从C++代码中调用一个匿名的PHP函数，也可以从PHP脚本中调用一个C++ lambda函数。</p>\n<p>让我们从一个非常简单的PHP例子开始。在PHP中，你可以创建匿名函数，并将它们赋值给一个变量（或者直接将它们传递给一个函数）。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// 使用变量$f保存匿名函数</span></span><br><span class=\"line\">$f = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($a, $b)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// return the sum of the parameters</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> $a + $b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把这个变量传递给另一个函数</span></span><br><span class=\"line\">other_function($f);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者直接传递匿名函数</span></span><br><span class=\"line\">other_function(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// return the product of the parameters</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> $a * $b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码对于大多数PHP程序员来说应该是很熟悉的，当然’other_function’也可以在PHP用户空间中实现，但是我们要用C++来演示如何用PHP-CPP来实现。’other_function’当然可以在PHP用户空间中实现，但是为了演示如何用PHP-CPP来实现，我们将用C++来构建它。就像你在前面的例子中看到的所有其他函数一样，这样的C++函数函数接收一个<code>Php::Parameters</code>对象作为参数，它是一个由<code>Php::Value</code>对象组成的<code>std::vector</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Native function that is callable from PHP</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  This function gets one parameter that holds a callable anonymous</span></span><br><span class=\"line\"><span class=\"comment\"> *  PHP function.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  params      The parameters passed to the function</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">other_function</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// make sure the function was really called with at least one parameter</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (params.size() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// this function is called from PHP user space, and it is called</span></span><br><span class=\"line\">    <span class=\"comment\">// with a anonymous function as its first parameter</span></span><br><span class=\"line\">    Php::Value func = params[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// the Php::Value class has implemented the operator (), which allows</span></span><br><span class=\"line\">    <span class=\"comment\">// us to use the object just as if it is a real function</span></span><br><span class=\"line\">    Php::Value result = func(<span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// @todo do something with the result</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class=\"line\"><span class=\"comment\"> *  to have a C style function signature</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  when PHP starts, and that should return the extension details</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the example function so that it can be called from PHP scripts</span></span><br><span class=\"line\">        extension.add&lt;other_function&gt;(<span class=\"string\">\"other_function\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension details</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是这么简单。但是反过来说也是可以的。想象一下，我们在PHP用户空间代码中有一个接受回调函数的函数，下面的函数是PHP array_map()函数的简单版本。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// function that iterates over an array, and calls a function on every</span></span><br><span class=\"line\"><span class=\"comment\">// element in that array, it returns a new array with every item</span></span><br><span class=\"line\"><span class=\"comment\">// replaced by the result of the callback</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">my_array_map</span><span class=\"params\">($array, $callback)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// initial result variable</span></span><br><span class=\"line\">    $result = <span class=\"keyword\">array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// loop through the array</span></span><br><span class=\"line\">    <span class=\"keyword\">foreach</span> ($array <span class=\"keyword\">as</span> $index =&gt; $item) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// call the callback on the item</span></span><br><span class=\"line\">        $result[$index] = $callback($item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// done</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> $result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>想象一下，我们想从你的C++代码中调用这个PHP函数，使用一个C++ lambda函数作为回调。这是有可能的，而且很简单。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Native function that is callable from PHP</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run_test</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// create the anonymous function</span></span><br><span class=\"line\">    Php::<span class=\"function\">Function <span class=\"title\">multiply_by_two</span><span class=\"params\">([](Php::Parameters &amp;params) -&gt; Php::Value &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"comment\">// make sure the function was really called with at least one parameter</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">if</span> (params.empty()) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"comment\">// one parameter is passed to the function</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Php::Value param = params[<span class=\"number\">0</span>];</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"comment\">// multiple the parameter by two</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">return</span> param * <span class=\"number\">2</span>;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    &#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// the function now is callable</span></span><br><span class=\"line\">    Php::Value four = multiply_by_two(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a Php::Function object is a derived Php::Value, and its value can </span></span><br><span class=\"line\">    <span class=\"comment\">// also be stored in a normal Php::Value object, it will then still </span></span><br><span class=\"line\">    <span class=\"comment\">// be a callback function then</span></span><br><span class=\"line\">    Php::Value value = multiply_by_two;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// the value object now also holds the function</span></span><br><span class=\"line\">    Php::Value six = value(<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// create an array</span></span><br><span class=\"line\">    Php::Value <span class=\"built_in\">array</span>;</span><br><span class=\"line\">    <span class=\"built_in\">array</span>[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">array</span>[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">array</span>[<span class=\"number\">2</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">array</span>[<span class=\"number\">3</span>] = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// call the user-space function</span></span><br><span class=\"line\">    Php::Value result = Php::call(<span class=\"string\">\"my_array_map\"</span>, <span class=\"built_in\">array</span>, multiply_by_two);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// @todo do something with the result variable (which now holds</span></span><br><span class=\"line\">    <span class=\"comment\">// an array with values 2, 4, 6 and 8).</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context, because the Zend engine expects the get_module()</span></span><br><span class=\"line\"><span class=\"comment\"> *  to have a C style function signature</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  when PHP starts, and that should return the extension details</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the example function so that it can be called from PHP scripts</span></span><br><span class=\"line\">        extension.add&lt;run_test&gt;(<span class=\"string\">\"run_test\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension details</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，我们将一个C++ lambda函数分配给一个<code>Php::Function</code>对象。<code>Php::Function</code>类是由<code>Php::Value</code>类派生出来的。<code>Php::Value</code>和<code>Php::Function</code>的唯一区别是<code>Php::Function</code>的构造函数接受一个函数。尽管有这个区别，这两个类是完全相同的。事实上，我们更希望能够让C++函数直接赋值给<code>Php::Value</code>对象，而跳过<code>Php::Function</code>构造函数，但这是不可能的，因为存在调用歧义。</p>\n<p><code>Php::Function</code>类可以像普通的<code>Php::Value</code>对象一样使用：你可以把它赋值给其他<code>Php::Value</code>对象，也可以在调用用户空间PHP函数时把它作为参数使用。在上面的例子中，我们正是这样做的：我们用我们自己的 “乘以二 “C++函数调用用户空间的my_iterate()函数。</p>\n<h3 id=\"C-函数签名\"><a href=\"#C-函数签名\" class=\"headerlink\" title=\"C++ 函数签名\"></a>C++ 函数签名</h3><p>你可以向<code>Php::Function</code>构造函数传递不同类型的C++函数，只要它们与以下两个函数签名兼容：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">function</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">function</span><span class=\"params\">(Php::Parameters &amp;params)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>在内核，<code>Php::Function</code>类使用一个C++的<code>std::function</code>对象来存储函数，所以凡是可以存储在这样一个<code>std::function</code>对象中的东西，都可以分配给<code>Php::Function</code>类。</p>\n<h2 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h2><p>C++和PHP都是面向对象的编程语言，你可以在其中创建类和对象。PHP-CPP 库为你提供了将这两种语言结合起来的工具，并使本地 C++ 类可以从 PHP 中访问。</p>\n<p>遗憾的是（但如果你考虑一下，也是符合逻辑的），并不是每一个可以想到的C++类都可以直接导出到PHP中。这需要更多的工作（虽然不是那么多）。首先，你必须确保你的类是从<code>Php::Base</code>派生出来的，其次，当你把你的类添加到扩展对象中时，你还必须指定所有你想从PHP中访问的方法。</p>\n<ol>\n<li>必须公开继承自<code>Php::Base</code></li>\n<li>指定访问控制</li>\n</ol>\n<h3 id=\"查看例子：cppclassinphp\"><a href=\"#查看例子：cppclassinphp\" class=\"headerlink\" title=\"查看例子：cppclassinphp\"></a>查看例子：cppclassinphp</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// we are going to define a class</span></span><br><span class=\"line\">Php::Class&lt;MyCustomClass&gt; customClass(<span class=\"string\">\"MyClass\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add methods to it</span></span><br><span class=\"line\">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class=\"string\">\"myMethod\"</span>, Php::Final, &#123;&#125;);</span><br><span class=\"line\">customClass.method&lt;&amp;MyCustomClass::myMethod&gt;(<span class=\"string\">\"myMethod2\"</span>);</span><br><span class=\"line\">customClass.property(<span class=\"string\">\"property1\"</span>, <span class=\"string\">\"prop1\"</span>);</span><br><span class=\"line\">customClass.property(<span class=\"string\">\"property2\"</span>, <span class=\"string\">\"prop2\"</span>, Php::Protected);</span><br><span class=\"line\"></span><br><span class=\"line\">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class=\"string\">\"loopArray\"</span>, &#123;</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"arr\"</span>, Php::Type::Array)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">customClass.method&lt;&amp;MyCustomClass::loop&gt;(<span class=\"string\">\"loopObject\"</span>, &#123;</span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"obj\"</span>, Php::Type::Object)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在扩展对象中，</p>\n<ol>\n<li>通过<code>Php::Class</code>定义类;</li>\n<li>使用<code>method</code>方法来指定需要php代码访问的方法，和普通函数一样，也可以定义参数;</li>\n<li>使用<code>property</code>来指定类成员，并设置访问权限</li>\n</ol>\n<p>静态方法也支持。静态方法是指一个不能访问<code>this</code>指针的方法。因此，在C++中，这种静态方法和普通函数是一样的，普通函数也不能访问<code>this</code>指针。静态C++方法与普通C++函数的唯一区别是在编译时：编译器允许静态方法访问私有数据。然而，静态方法的签名与普通函数的签名完全相同。</p>\n<p><strong>PHP-CPP允许你注册静态方法。但是由于静态方法的签名与普通函数的签名完全相同，所以你注册的方法甚至不一定是同一个类的方法。普通函数和其他类的静态方法的签名完全一样，也可以注册! 从软件架构的角度来看，最好只使用同一类的静态方法，但C++允许你做的更多。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  普通函数</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  因为普通函数没有this指针,</span></span><br><span class=\"line\"><span class=\"comment\"> *  所以它和静态方法拥有相同的签名</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  params      Parameters passed to the function</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">regularFunction</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// @todo add implementation</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  不会暴露给php调用的类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrivateClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    PrivateClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~PrivateClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     *  静态方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *  静态方法没有this指针</span></span><br><span class=\"line\"><span class=\"comment\">     *  因此它的签名和普通函数相同</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params      Parameters passed to the method</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticMethod</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// @todo add implementation</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  暴露给php使用的类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublicClass</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    PublicClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~PublicClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     *  另一个静态方法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *  这个静态方法的签名和前面提到的普通函数和静态方法完全一样。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params      Parameters passed to the method</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticMethod</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// @todo add implementation</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static instance of the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;PublicClass&gt; myClass(<span class=\"string\">\"MyClass\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将PublicClass::staticMethod注册为一个可在PHP中调用的静态方法</span></span><br><span class=\"line\">        myClass.method&lt;&amp;PublicClass::staticMethod&gt;(<span class=\"string\">\"static1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 普通函数与静态方法具有相同的签名。所以，没有什么能禁止你把普通函数也注册为静态方法。</span></span><br><span class=\"line\">        myClass.method&lt;regularFunction&gt;(<span class=\"string\">\"static2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 甚至来自完全不同类的静态方法也有相同的函数签名，因此可以注册</span></span><br><span class=\"line\">        myClass.method&lt;&amp;PrivateClass::staticMethod&gt;(<span class=\"string\">\"static3\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(myClass));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 事实上，由于静态方法的签名与普通函数相同，你也可以将静态C++方法注册为普通的全局PHP函数。</span></span><br><span class=\"line\">        myExtension.add(<span class=\"string\">\"myFunction\"</span>, &amp;PrivateClass::staticMethod);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在PHP代码中使用扩展的功能</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// this will call PublicClass::staticMethod()</span></span><br><span class=\"line\">MyClass::static1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this will call PrivateClass::staticMethod()</span></span><br><span class=\"line\">MyClass::static2();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this will call regularFunction()</span></span><br><span class=\"line\">MyClass::static3();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this will also call PrivateClass::staticMethod()</span></span><br><span class=\"line\">myFunction();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h3><p>在PHP中（在C++中也是），你可以将方法标记为<code>public</code>、<code>private</code>或<code>protected</code>。为了使你的本地类也能实现这一点，你应该在向<code>Php::Class</code>对象添加方法时传递一个额外的flags参数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">Php::Class&lt;Counter&gt; counter(<span class=\"string\">\"Counter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// register the increment method, and specify its parameters</span></span><br><span class=\"line\">counter.method&lt;&amp;Counter::increment&gt;(<span class=\"string\">\"increment\"</span>, Php::Protected, &#123; </span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"change\"</span>, Php::Type::Numeric, <span class=\"literal\">false</span>) </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// register the decrement, and specify its parameters</span></span><br><span class=\"line\">counter.method&lt;&amp;Counter::decrement&gt;(<span class=\"string\">\"decrement\"</span>, Php::Protected, &#123; </span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"change\"</span>, Php::Type::Numeric, <span class=\"literal\">false</span>) </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// register the value method</span></span><br><span class=\"line\">counter.method&lt;&amp;Counter::value&gt;(<span class=\"string\">\"value\"</span>, Php::Public | Php::Final);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，每一个方法 (还有每一个属性，但我们稍后会处理) 都是<code>公开</code>的。如果你想把一个方法标记为受保护的或私有的，你可以传递一个额外的 <code>Php::Protected</code> 或 <code>Php::Private</code> 标志。如果你也想把你的方法标记为抽象的或最终的，那么可以用<code>Php::Abstract</code>或<code>Php::Final</code>来对flag参数进行<code>位或</code>。PHP-CPP对value()方法做了这样的处理，这样在派生类中就不可能覆盖这个方法了。</p>\n<p>请记住，C++ 类中的导出方法必须始终是公共的(即使在 PHP 中标记为私有或保护)。这是有道理的，因为毕竟你的方法会被 PHP-CPP 库调用，如果你把它们变成私有的，它们就会被库所忽略。</p>\n<h3 id=\"Abstract-and-final\"><a href=\"#Abstract-and-final\" class=\"headerlink\" title=\"Abstract and final\"></a>Abstract and final</h3><p>在上一节中，我们展示了如何使用<code>Php::Final</code>和<code>Php::Abstract</code>标志来创建一个final或抽象方法。如果你想让你的整个类成为抽象的或最终的，你可以通过把这个标志传递给<code>Php::Class</code>构造函数来实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">Php::Class&lt;Counter&gt; counter(<span class=\"string\">\"Counter\"</span>, Php::Final);</span><br></pre></td></tr></table></figure>\n<p>就像我们之前解释的那样，当你想注册一个抽象方法时，你应该在调用Php::Class::method()时传递一个Php::Abstract标志。然而，可能看起来很奇怪，这个方法也需要你传入一个真正的C++方法的地址。抽象方法通常没有实现，那么你需要提供一个方法的指针干什么呢？幸运的是，也有一种不同的方法来注册抽象方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// register the decrement, and specify its parameters</span></span><br><span class=\"line\">counter.method(<span class=\"string\">\"decrement\"</span>, &#123; </span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"change\"</span>, Php::Type::Numeric, <span class=\"literal\">false</span>) </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>要注册抽象方法，你可以简单地使用Counter::method()方法的另一种形式，它不接受指向C++方法的指针。</p>\n<h2 id=\"构造与析构\"><a href=\"#构造与析构\" class=\"headerlink\" title=\"构造与析构\"></a>构造与析构</h2><p>在 C++ 中的构造函数和析构函数与 PHP 中的 <strong>construct() 和 </strong>destruct() 方法之间有一个很小但非常重要的区别。</p>\n<p>C++ 中的构造函数是在一个正在初始化的对象上调用的，但这个对象还没有处于初始化状态。你可以通过调用构造函数中的一个虚拟方法来体验这种情况。即使这个虚拟方法在派生类中被重写，这也将始终执行类本身的方法，而不是重写的实现。原因是在调用C++构造函数的过程中，对象还没有完全初始化，对象还不知道自己在类层次结构中的位置。因此对虚拟方法的调用不能传递给派生对象。</p>\n<p>然而在 PHP 中，__construct() 方法有不同的行为。当它被调用时，对象已经被初始化了，因此对派生类中实现的抽象方法的调用是完全合法的。下面的 PHP 脚本是完全有效的，但是在 C++ 中不可能做类似的事情。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// base class in PHP, in which the an abstract method is called</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BASE</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// constructor</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// call abstract method</span></span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// abstract method to be implemented by derived classes</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the derived class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DERIVED</span> <span class=\"keyword\">extends</span> <span class=\"title\">BASE</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// implement the abstract method</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span>(<span class=\"string\">\"doSomething()\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create an instance of the derived class</span></span><br><span class=\"line\">$d = <span class=\"keyword\">new</span> DERIVED();</span><br></pre></td></tr></table></figure>\n<p>这个脚本输出的是’doSomething()’。原因是<code>__construct()</code>根本就不是一个构造函数，而是一个很普通的方法，只是恰好是第一个被调用的方法，而且是在对象被构造后自动调用的。</p>\n<p>这个区别对于作为一个C++程序员的你来说是很重要的，因为你千万不要把你的C++构造函数和PHP的<code>__construct()</code>方法混淆。在C++构造函数中，对象正在被构造，而且还不是所有的数据都可用。虚拟方法不能被调用，对象也还不存在于 PHP 用户空间中。</p>\n<p>在构造函数完成后，PHP引擎接管控制并创建PHP对象，然后PHP-CPP库将该PHP对象链接到你的C++对象。只有在PHP对象和C++对象都完全构造完成之后，才会调用<strong>construct()方法（就像普通方法一样）。因此，在你的类中同时拥有 C++ 构造函数和 </strong>construct() 方法是很常见的。<strong>C++ 构造函数用来初始化成员变量，而 __construct() 方法用来激活对象。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Simple counter class</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Internal value</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  c++ constructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Counter() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  c++ destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Counter() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  php \"constructor\"</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __construct(Php::Parameters &amp;params)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// copy first parameter (if available)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!params.empty()) _value = params[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  functions to increment and decrement</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> ++_value; &#125;</span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">decrement</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> --_value; &#125;</span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context so that the get_module() function can be</span></span><br><span class=\"line\"><span class=\"comment\"> *  called by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function for the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Counter&gt; counter(<span class=\"string\">\"Counter\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::__construct&gt;(<span class=\"string\">\"__construct\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::increment&gt;(<span class=\"string\">\"increment\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::decrement&gt;(<span class=\"string\">\"decrement\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::value&gt;(<span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(counter));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码显示 <code>__construct()</code> 被注册为一个普通的方法。我们之前使用的例子（有Counter类的例子）现在被扩展了，这样就可以通过向 “构造函数”传递一个值来给它一个计数器的初始值。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">$counter = <span class=\"keyword\">new</span> Counter(<span class=\"number\">10</span>);</span><br><span class=\"line\">$counter-&gt;increment();</span><br><span class=\"line\"><span class=\"keyword\">echo</span>($counter-&gt;value().<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>因为<code>__construct()</code>方法被看作是一个普通的方法，所以你也可以指定它的参数，以及该方法是公共的、私有的还是保护的。<code>__construct()</code>也可以从PHP用户空间直接调用，所以派生方法可以显式调用<code>parent::__construct()</code>。</p>\n<h3 id=\"私有构造函数\"><a href=\"#私有构造函数\" class=\"headerlink\" title=\"私有构造函数\"></a>私有构造函数</h3><p>就像其他方法一样，<strong>construct()方法也可以被标记为私有或保护。如果你这样做，你将使你的类无法从PHP脚本中创建实例。重要的是要意识到，在这种情况下，C++ 构造函数和 C++ 解构函数仍然会被调用，因为会失败的是<code></code></strong>construct()<code></code>调用，而不是实际的对象构造。</p>\n<p>是的，如果你把<code>__construct()</code>方法设为私有，并且在 PHP 脚本中执行了<code>new Counter()</code>调用，PHP-CPP 库将首先实例化你的类的一个新实例，然后报告一个错误，因为<code>__construct()</code>方法是私有的，然后立即析构对象（并调用 C++ 析构函数）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add a private __construct method to the class, so that objects can </span></span><br><span class=\"line\"><span class=\"comment\">// not be constructed from PHP scripts. Be aware that the C++ constructer </span></span><br><span class=\"line\"><span class=\"comment\">// does get called - it will be the call to the first __construct() </span></span><br><span class=\"line\"><span class=\"comment\">// function that will fail, and not the actual object construction.</span></span><br><span class=\"line\">counter.method&lt;&amp;Counter::__construct&gt;(<span class=\"string\">\"__construct\"</span>, Php::Private);</span><br></pre></td></tr></table></figure>\n<h3 id=\"克隆对象\"><a href=\"#克隆对象\" class=\"headerlink\" title=\"克隆对象\"></a>克隆对象</h3><p>如果你的类有一个复制构造函数，它就会自动成为可克隆的类。如果你不希望你的类可以被 PHP 脚本克隆，你可以做两件事：</p>\n<ol>\n<li>你可以从你的类中删除复制构造函数;</li>\n<li>你可以注册一个私有的 <code>__clone()</code> 方法，就像我们之前注册一个私有的 <code>__construct()</code> 方法一样。</li>\n</ol>\n<p>删除复制构造函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  Remove the copy constructor</span></span><br><span class=\"line\"><span class=\"comment\">*  </span></span><br><span class=\"line\"><span class=\"comment\">*  By removing the copy constructor, the PHP clone operator will</span></span><br><span class=\"line\"><span class=\"comment\">*  automatically be deactivated. PHP will trigger an error if </span></span><br><span class=\"line\"><span class=\"comment\">*  an object is attempted to be cloned.</span></span><br><span class=\"line\"><span class=\"comment\">*  </span></span><br><span class=\"line\"><span class=\"comment\">*  @param  counter</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">Counter(<span class=\"keyword\">const</span> Counter &amp;counter) = <span class=\"keyword\">delete</span>;</span><br></pre></td></tr></table></figure>\n<p>把克隆方法注册为私有</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// alternative way to make an object unclonable</span></span><br><span class=\"line\">counter.method(<span class=\"string\">\"__clone\"</span>, Php::Private);</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造对象\"><a href=\"#构造对象\" class=\"headerlink\" title=\"构造对象\"></a>构造对象</h3><p><code>Php::Value</code>类可以作为一个常规的PHP <code>$variable</code>使用，因此你也可以用它来存储对象实例。但是如何创建全新的对象呢？为此，我们有 <code>Php::Object</code> 类，它是一个简单的重写的 <code>Php::Value</code> 类，带有可供选择的构造函数，还有一些额外的检查，以防止你使用 <code>Php::Object</code> 对象来存储对象以外的值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new variable holding the string \"Counter\"</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">counter0</span><span class=\"params\">(<span class=\"string\">\"Counter\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// new variable holding a newly created object of type \"Counter\",</span></span><br><span class=\"line\"><span class=\"comment\">// the __construct() gets called without parameters</span></span><br><span class=\"line\">Php::<span class=\"function\">Object <span class=\"title\">counter1</span><span class=\"params\">(<span class=\"string\">\"Counter\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// new variable holding a newly created object, and </span></span><br><span class=\"line\"><span class=\"comment\">// the __construct() is being called with value 10</span></span><br><span class=\"line\">Php::<span class=\"function\">Object <span class=\"title\">counter2</span><span class=\"params\">(<span class=\"string\">\"Counter\"</span>, <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// new built-in DateTime object, constructed with \"now\"</span></span><br><span class=\"line\">Php::<span class=\"function\">Object <span class=\"title\">time</span><span class=\"params\">(<span class=\"string\">\"DateTime\"</span>, <span class=\"string\">\"now\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// valid, a Php::Object is an extended Php::Value, and </span></span><br><span class=\"line\"><span class=\"comment\">// can thus be assigned to a base Php::Value object</span></span><br><span class=\"line\">Php::Value copy1 = counter1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// invalid statement, a Php::Object can only be used for storing objects</span></span><br><span class=\"line\">Php::Object copy2 = counter0;</span><br></pre></td></tr></table></figure>\n<p><code>Php::Object</code> 的构造函数接收一个类的名称，以及一个可选的参数列表，这些参数将被传递给 <code>__construct()</code> 函数。你可以使用内置的 PHP 类和其他扩展的名称（如 DateTime），你的扩展的类（如 Counter），甚至是 PHP 用户空间的类。</p>\n<p>如果你想在不调用 <code>__construct()</code> 函数的情况下构造一个你自己的 C++ 类的实例，也可以使用 <code>Php::Object</code> 类。例如，当 <code>__construct()</code> 方法是私有的，或者当你想绕过对你自己的 <code>__construct()</code> 方法的调用时，这就很有用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// actual class implementation</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// c++ constructor</span></span><br><span class=\"line\">    Counter(<span class=\"keyword\">int</span> value) : _value(value) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// c++ destructor</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Counter() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// php \"constructor\"</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __construct() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// functions to increment and decrement</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function to create a new timer</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">createTimer</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Php::Object(<span class=\"string\">\"Counter\"</span>, <span class=\"keyword\">new</span> Counter(<span class=\"number\">100</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows which methods are accessible,</span></span><br><span class=\"line\">        <span class=\"comment\">// the __construct method is private because PHP scripts are not allowed</span></span><br><span class=\"line\">        <span class=\"comment\">// to create Counter instances</span></span><br><span class=\"line\">        Php::Class&lt;Counter&gt; counter(<span class=\"string\">\"Counter\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::__construct&gt;(<span class=\"string\">\"__construct\"</span>, Php::Private);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::value&gt;(<span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(counter));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the factory function to create a timer to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"string\">\"createTimer\"</span>, createTimer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们将 Counter 类的 <code>__construct()</code> 函数设为私有。这使得不可能创建这个类的实例（无论是从 PHP 用户脚本中，还是通过调用 <code>Php::Object(&quot;Counter&quot;)</code>），因为用这些方法构造对象最终会导致一个被禁止的 <code>__construct()</code> 调用。</p>\n<p><code>Php::Object</code> 确实有一种替代的语法，它可以接受一个指向 C++ 类的指针（在堆上分配，使用运算符 <code>new</code>！），并将这个指针变成一个 PHP 变量，而无需调用 <code>__construct()</code> 方法。请注意，你还必须指定类名，因为 C++ 类不保存任何关于它们自己的信息（比如它们的名字），而在 PHP 中，这样的信息是处理<code>反射</code>和 <code>get_class()</code> 等函数所需要的。</p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>PHP和C++都是支持类继承的面向对象编程语言。有一些区别。C++支持多继承，而PHP类只能有一个基类。为了弥补没有多重继承的不足，PHP支持接口和<code>traits</code>。</p>\n<p>PHP-CPP库还允许你定义PHP接口，并创建PHP类和PHP接口的层次结构。</p>\n<h3 id=\"定义接口\"><a href=\"#定义接口\" class=\"headerlink\" title=\"定义接口\"></a>定义接口</h3><p>如果你想让你的扩展定义一个接口，这样接口就可以从 PHP 用户空间脚本中实现，你可以用类似于定义类的方式来实现。唯一不同的是，你不使用<code>Php::Class&lt;YourClass&gt;</code>，而是使用<code>Php::Interface</code>实例。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// description of the interface so that PHP knows which methods </span></span><br><span class=\"line\"><span class=\"comment\">// are defined by it</span></span><br><span class=\"line\">Php::<span class=\"function\">Interface <span class=\"title\">interface</span><span class=\"params\">(<span class=\"string\">\"MyInterface\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// define an interface method</span></span><br><span class=\"line\">interface.method(<span class=\"string\">\"myMethod\"</span>, &#123; </span><br><span class=\"line\">    Php::ByVal(<span class=\"string\">\"value\"</span>, Php::Type::String, <span class=\"literal\">true</span>) </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"派生和实现\"><a href=\"#派生和实现\" class=\"headerlink\" title=\"派生和实现\"></a>派生和实现</h3><p>PHP-CPP 库试图使 PHP 和 C++ 的工作尽可能的透明。C++函数可以从PHP用户空间脚本中调用，C++类可以从PHP中访问。然而，归根结底PHP和C++还是不同的语言，由于C++没有PHP那样的反射功能，所以你必须显式地告诉PHP引擎该类实现了哪些基类和接口。</p>\n<p><code>Php::Class&lt;YourClass&gt;</code>对象有一个方法 <code>extends()</code>和一个方法 <code>implements()</code>，可以用来指定基类和实现的接口。你需要传入一个你之前配置的类或接口。我们来看一个例子。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static instance of the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the interface so that PHP knows which methods </span></span><br><span class=\"line\">        <span class=\"comment\">// are defined by it</span></span><br><span class=\"line\">        Php::<span class=\"function\">Interface <span class=\"title\">myInterface</span><span class=\"params\">(<span class=\"string\">\"MyInterface\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// define an interface method</span></span><br><span class=\"line\">        myInterface.method(<span class=\"string\">\"myMethod\"</span>, &#123; </span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"value\"</span>, Php::Type::String, <span class=\"literal\">true</span>) </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// register our own class</span></span><br><span class=\"line\">        Php::Class&lt;MyClass&gt; myClass(<span class=\"string\">\"MyClass\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// from PHP user space scripts, it must look like the myClass implements</span></span><br><span class=\"line\">        <span class=\"comment\">// the MyInterface interface</span></span><br><span class=\"line\">        myClass.implements(myInterface);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the interface requires that the myMethod method is implemented</span></span><br><span class=\"line\">        myClass.method&lt;&amp;MyClass::myMethod&gt;(<span class=\"string\">\"myMethod\"</span>, &#123;</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"value\"</span>, Php::Type::String, <span class=\"literal\">true</span>) </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create a third class</span></span><br><span class=\"line\">        Php::Class&lt;DerivedClass&gt; derivedClass(<span class=\"string\">\"DerivedClass\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// in PHP scripts, it should look like DerivedClass has \"MyClass\" </span></span><br><span class=\"line\">        <span class=\"comment\">// as its base</span></span><br><span class=\"line\">        derivedClass.extends(myClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the interface and the classes to the extension</span></span><br><span class=\"line\">        myExtension.add(myInterface);</span><br><span class=\"line\">        myExtension.add(myClass);</span><br><span class=\"line\">        myExtension.add(derivedClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，在 <code>get_module()</code> 函数中定义的 PHP 类的层次结构不一定要和 C++ 类的层次结构一致。你的 C++ 类 <code>DerivedClass</code> 根本不需要以 “MyClass”为基础，尽管在 PHP 脚本中它看起来像这样。为了代码的可维护性，当然最好让 PHP 的签名与 C++ 的实现多少有些相似。</p>\n<h2 id=\"魔术方法\"><a href=\"#魔术方法\" class=\"headerlink\" title=\"魔术方法\"></a>魔术方法</h2><p>每个PHP类都有 “魔术方法”。你可能已经在写PHP代码时知道这些方法：这些方法以两个下划线开头，名字像<code>__set()</code>,<code>__isset()</code>,<code>__call()</code>等等。</p>\n<p>PHP-CPP库也支持这些魔术方法。使用一些C++编译器的技巧，C++编译器会检测你的类中是否存在方法，如果存在，它们会被编译到你的扩展中，并从PHP访问时被调用。</p>\n<h3 id=\"编译时检测\"><a href=\"#编译时检测\" class=\"headerlink\" title=\"编译时检测\"></a>编译时检测</h3><p>虽然你可能已经预料到这些魔术方法是<code>Php::Base</code>类中的虚函数，可以被重写，但其实不然。这些方法在编译时被C++编译器检测到（而且是非常正常的方法），只是碰巧有一个特定的名字。</p>\n<p>由于编译时的检测，方法的签名有一定的灵活性。许多魔术方法的返回值都是分配给<code>Php::Value</code>对象的，这意味着只要你确保你的魔术方法返回的类型是可以分配给<code>Php::Value</code>的，你就可以在你的类中使用它。因此，你的 <code>__toString()</code> 方法可以返回一个 <code>char*</code>、一个 <code>std::string</code>、<code>Php::Value</code> (甚至是一个整数！)，因为所有这些类型都可以分配给 <code>Php::Value</code>。</p>\n<p>用PHP-CPP实现的魔术方法的好处是，它们不会在PHP用户空间中变得可见。换句话说，当你在你的 C++ 类中定义了 <code>__set()</code> 或 <code>__unset()</code> 这样的函数时，这些函数不能被 PHP 脚本显式地调用，但是当一个属性被访问时，它们会被调用。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>一般情况下，魔术方法不需要注册就可以使用。当你在你的类中添加了一个像<code>__toString()</code>或<code>__get()</code>这样的魔术方法时，当一个对象被转换为字符串或一个属性被访问时，它将被自动调用。不需要在<code>get_module()</code>启动函数中显式启用魔术方法。</p>\n<p>这个规则的唯一例外是<code>__construct()</code>方法。这个方法必须要明确注册。这其中的原因有很多。首先，<code>__construct()</code>方法没有固定的签名，通过显式添加到扩展中，你还可以指定它接受什么参数，以及<code>__construct()</code>方法应该是公共的、私有的还是保护的（如果你想创建不能从PHP实例化的类）。</p>\n<p>另一个必须显式注册 <code>__construct()</code> 方法的原因是，与其他魔术方法不同，<code>__construct</code> 方法必须在 PHP 中可见。在派生类的构造函数里面，经常需要对<code>parent::__construct()</code>进行调用。通过在<code>get_module()</code>函数中注册<code>__construct()</code>方法，你可以使该函数在PHP中可见。</p>\n<h3 id=\"克隆和析构\"><a href=\"#克隆和析构\" class=\"headerlink\" title=\"克隆和析构\"></a>克隆和析构</h3><p><code>__clone()</code>方法与<code>__construct()</code>方法非常相似。它也是在构造对象后直接调用的方法。区别在于<code>__clone()</code>是在一个对象被复制构造（克隆）后调用的，而<code>__construct()</code>是在普通构造函数之后调用的。</p>\n<p><code>__destruct()</code>方法会在对象被销毁之前被调用（也就是在C++的<code>destructor</code>运行之前）。</p>\n<p><code>__clone()</code> 和 <code>__destruct()</code> 方法是常规的魔术方法（与 <code>__construct()</code>不同），因此你不需要注册它们就可以使它们生效。如果你把这两个方法中的一个添加到你的类中，你将不必对<code>get_module()</code>启动函数做任何修改。如果有的话，PHP-CPP 库会自动调用它们。</p>\n<p>在正常情况下，你可能不需要这些方法，也可以使用C++复制构造函数和C++析构函数。唯一不同的是，魔术方法是在处于完全初始化状态的对象上调用的，而C++复制构造函数和C++析构函数则是针对正在初始化的对象，或者是针对正在销毁的对象。</p>\n<h3 id=\"伪属性\"><a href=\"#伪属性\" class=\"headerlink\" title=\"伪属性\"></a>伪属性</h3><p>通过<code>__get()</code>、<code>__set()</code>、<code>__unset()</code>和<code>__isset()</code>等方法，你可以定义伪属性。例如，它允许您创建只读属性，或在设置时检查其有效性的属性。</p>\n<p>这些魔术方法与PHP脚本中的对应方法的工作原理完全一样，所以你可以轻松地将使用这些属性的PHP代码移植到C++中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample class, that has some pseudo properties that map to native types</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Name of the user</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    std::string</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> _name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Email address of the user</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    std::string</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> _email;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and C++ destructpr</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    User() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~User() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Get access to a property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  name        Name of the property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value       Property value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::Value __get(<span class=\"keyword\">const</span> Php::Value &amp;name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check if the property name is supported</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"string\">\"name\"</span>) <span class=\"keyword\">return</span> _name;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"string\">\"email\"</span>) <span class=\"keyword\">return</span> _email;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// property not supported, fall back on default</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Php::Base::__get(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Overwrite a property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  name        Name of the property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  value       New property value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __set(<span class=\"keyword\">const</span> Php::Value &amp;name, <span class=\"keyword\">const</span> Php::Value &amp;value) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check the property name</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"string\">\"name\"</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// store member</span></span><br><span class=\"line\">            _name = value.stringValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// we check emails for validity</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (name == <span class=\"string\">\"email\"</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// store the email in a string</span></span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> email = value;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// must have a '@' character in it</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (email.find(<span class=\"string\">'@'</span>) == <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>::npos) </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// email address is invalid, throw exception</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> Php::Exception(<span class=\"string\">\"Invalid email address\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// store the member</span></span><br><span class=\"line\">            _email = email;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// other properties fall back to default</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// call default</span></span><br><span class=\"line\">            Php::Base::__set(name, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Check if a property is set</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  name        Name of the property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return bool</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __isset(<span class=\"keyword\">const</span> Php::Value &amp;name) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// true for name and email address</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"string\">\"name\"</span> || name == <span class=\"string\">\"email\"</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// fallback to default</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Php::Base::__isset(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Remove a property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  name        Name of the property to remove</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __unset(<span class=\"keyword\">const</span> Php::Value &amp;name)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// name and email can not be unset</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"string\">\"name\"</span> || name == <span class=\"string\">\"email\"</span>) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// warn the user with an exception that this is impossible</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> Php::Exception(<span class=\"string\">\"Name and email address can not be removed\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// fallback to default</span></span><br><span class=\"line\">        Php::Base::__unset(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows </span></span><br><span class=\"line\">        <span class=\"comment\">// which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;User&gt; user(<span class=\"string\">\"User\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(user));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子展示了如何创建一个User类，该类似乎有一个名称和电子邮件属性，但不允许你分配一个没有‘@’字符的电子邮件地址，也不允许你删除属性。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize user and set its name and email address</span></span><br><span class=\"line\">$user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">$user-&gt;name = <span class=\"string\">\"John Doe\"</span>;</span><br><span class=\"line\">$user-&gt;email = <span class=\"string\">\"john.doe@example.com\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// show the email address</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($user-&gt;email.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remove the email address (this will cause an exception)</span></span><br><span class=\"line\"><span class=\"keyword\">unset</span>($user-&gt;email);</span><br></pre></td></tr></table></figure>\n<h3 id=\"魔术方法-call-callStatic-and-invoke\"><a href=\"#魔术方法-call-callStatic-and-invoke\" class=\"headerlink\" title=\"魔术方法 call(), callStatic() and __invoke()\"></a>魔术方法 <strong>call(), </strong>callStatic() and __invoke()</h3><p>C++方法需要在你的扩展<code>get_module()</code>启动函数中明确注册，才能从PHP用户空间访问。然而，当你重写 <code>__call()</code> 方法时，你可以接受所有的调用（甚至是对不存在的方法的调用）。当有人从用户空间对一些看起来像方法的东西进行调用时，它将被传递给这个<code>__call()</code>方法。在脚本中，你可以这样使用<code>$object-&gt;something()</code>，<code>$object-&gt;whatever()</code>或者<code>$object-&gt;anything()</code>（方法的名称是什么并不重要），所有这些调用都会传递给C++类中的<code>__call()</code>方法。</p>\n<p><code>__callStatic()</code>方法类似于<code>__call()</code>方法，但适用于静态方法。对<code>YourClass::someMethod()</code>的静态调用可以自动传递给你的C++类的<code>__callStatic()</code>方法。</p>\n<p>除了<code>__call()</code>和<code>__callStatic</code>函数，PHP-CPP库还支持<code>__invoke()</code>方法。这是一个当对象实例被当作函数使用时被调用的方法。这可以与C++类中的运算符<code>（）</code>重载相比。通过实现<code>__invoke()</code>方法，PHP用户空间的脚本可以创建一个对象，然后将其作为函数使用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample class, that accepts all thinkable method calls</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and C++ destructpr</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    MyClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~MyClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Regular method</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params      Parameters that were passed to the method</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value       The return value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">regular</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"this is a regular method\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Overriden __call() method to accept all method calls</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  name        Name of the method that is called</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params      Parameters that were passed to the method</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value       The return value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::Value __call(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, Php::Parameters &amp;params)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// the return value</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> retval = <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(<span class=\"string\">\"__call \"</span>) + name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// loop through the parameters</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;param : params)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// append parameter string value to return value</span></span><br><span class=\"line\">            retval += <span class=\"string\">\" \"</span> + param.stringValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// done</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Overriden __callStatic() method to accept all static method calls</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  name        Name of the method that is called</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params      Parameters that were passed to the method</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value       The return value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Php::Value __callStatic(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, Php::Parameters &amp;params)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// the return value</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> retval = <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(<span class=\"string\">\"__callStatic \"</span>) + name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// loop through the parameters</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;param : params)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// append parameter string value to return value</span></span><br><span class=\"line\">            retval += <span class=\"string\">\" \"</span> + param.stringValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// done</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Overridden __invoke() method so that objects can be called directly</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params      Parameters that were passed to the method</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value       The return value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::Value __invoke(Php::Parameters &amp;params)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// the return value</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> retval = <span class=\"string\">\"invoke\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// loop through the parameters</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;param : params)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// append parameter string value to return value</span></span><br><span class=\"line\">            retval += <span class=\"string\">\" \"</span> + param.stringValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// done</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> retval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows </span></span><br><span class=\"line\">        <span class=\"comment\">// which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;MyClass&gt; myClass(<span class=\"string\">\"MyClass\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// register the regular method</span></span><br><span class=\"line\">        myClass.method&lt;&amp;MyClass::regular&gt;(<span class=\"string\">\"regular\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(myClass));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在php中使用</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize an object</span></span><br><span class=\"line\">$object = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call a regular method</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($object-&gt;regular().<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call some pseudo-methods</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($object-&gt;something().<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>($object-&gt;myMethod(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>($object-&gt;whatever(<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call some pseudo-methods in a static context</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MyClass::something().<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MyClass::myMethod(<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MyClass::whatever(<span class=\"string\">\"x\"</span>,<span class=\"string\">\"y\"</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call the object as if it was a function</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($object(<span class=\"string\">\"parameter\"</span>,<span class=\"string\">\"passed\"</span>,<span class=\"string\">\"to\"</span>,<span class=\"string\">\"invoke\"</span>).<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>输出如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">regular</span><br><span class=\"line\">__call something</span><br><span class=\"line\">__call myMethod 1 2 3 4</span><br><span class=\"line\">__call whatever a b</span><br><span class=\"line\">__callStatic something</span><br><span class=\"line\">__callStatic myMethod 5 6 7</span><br><span class=\"line\">__callStatic whatever x y</span><br><span class=\"line\">invoke parameter passed to invoke</span><br></pre></td></tr></table></figure>\n<h3 id=\"转换为字符串\"><a href=\"#转换为字符串\" class=\"headerlink\" title=\"转换为字符串\"></a>转换为字符串</h3><p>在PHP中，你可以在一个类中添加一个<code>__toString()</code>方法。当一个对象被转换为字符串时，或者当一个对象在字符串上下文中被使用时，这个方法会被自动调用。PHP-CPP 也支持这个 <code>__toString()</code> 方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample class, with methods to cast objects to scalars</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and C++ destructpr</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    MyClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~MyClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Cast to a string</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::Value __toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"abcd\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows </span></span><br><span class=\"line\">        <span class=\"comment\">// which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;MyClass&gt; myClass(<span class=\"string\">\"MyClass\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(myClass));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了这里描述的魔术方法，你可能已经在编写PHP脚本时知道了，PHP-CPP库还引入了一些额外的魔术方法。这些方法包括额外的转换方法，以及比较对象的方法。</p>\n<h2 id=\"魔术接口\"><a href=\"#魔术接口\" class=\"headerlink\" title=\"魔术接口\"></a>魔术接口</h2><p>在PHP内核中，自带了一些特殊的”魔术”PHP接口，脚本编写者可以通过这些接口来实现为一个类添加特殊功能。这些接口的名称是’Countable’、’ArrayAccess’和’Serializable’。这些接口带来的功能，也可以用PHP-CPP来实现。</p>\n<p>你可能会好奇为什么PHP有时会使用魔术方法（例如<code>__set</code>和<code>__unset</code>），有时会使用接口来改变一个类的行为。这种选择似乎并不统一。对我们来说，不清楚为什么有些特殊功能是用魔术方法来实现的，而有些特殊功能是通过实现接口来激活的。在我们看来，<code>Serializable</code>接口也可以用神奇的<code>__serialize()</code>和<code>__unserialize()</code>方法来实现，或者<code>__invoke()</code>方法也可以是一个”Invokable”接口。PHP 不是一种标准化的语言，有些东西看起来就是这样，因为有人觉得这样或那样的方式来实现它。</p>\n<p>尽管如此，PHP-CPP库还是试图尽可能地接近PHP。这就是为什么在你的C++类中，你也可以使用特殊的接口（因为C++没有像PHP那样的接口），所以用纯虚函数的类来代替。</p>\n<h3 id=\"SPL的支持\"><a href=\"#SPL的支持\" class=\"headerlink\" title=\"SPL的支持\"></a>SPL的支持</h3><p>一个标准的PHP安装程序会附带标准PHP库（SPL）。这是一个建立在Zend引擎之上的扩展，它使用Zend引擎的特性来创建类和接口，如Countable、Iterator和ArrayAccess。</p>\n<p>PHP-CPP 库也有这些名称的接口，它们的行为方式与 SPL 接口大致相同。但在内核中，PHP-CPP库不依赖于SPL。如果你实现了像<code>Php::ArrayAccess</code>或<code>Php::Countable</code>这样的C++接口，这和在PHP中写一个实现SPL接口的类是不同的。</p>\n<p>PHP-CPP和SPL都是直接建立在Zend核心之上的，并且提供了相同的功能，但它们并不相互依赖。因此，如果没有加载SPL扩展，可以安全地使用PHP-CPP。</p>\n<h3 id=\"Countable接口\"><a href=\"#Countable接口\" class=\"headerlink\" title=\"Countable接口\"></a>Countable接口</h3><p>通过实现<code>Php::Countable</code>接口，你可以创建能传递给PHP <code>count()</code>函数的对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  The famous counter class, now also implements</span></span><br><span class=\"line\"><span class=\"comment\"> *  the Php::Countable interface</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> :</span> <span class=\"keyword\">public</span> Php::Base, <span class=\"keyword\">public</span> Php::Countable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The internal counter value</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and C++ destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Counter() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Counter() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Methods to increment and decrement the counter</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> ++_value; &#125;</span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">decrement</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> --_value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method from the Php::Countable interface, that</span></span><br><span class=\"line\"><span class=\"comment\">     *  is used when a Counter instance is passed to the</span></span><br><span class=\"line\"><span class=\"comment\">     *  PHP count() function</span></span><br><span class=\"line\"><span class=\"comment\">     *  </span></span><br><span class=\"line\"><span class=\"comment\">     *  @return long</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">()</span> override </span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows</span></span><br><span class=\"line\">        <span class=\"comment\">// which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Counter&gt; counter(<span class=\"string\">\"Counter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add methods</span></span><br><span class=\"line\">        counter.method(<span class=\"string\">\"increment\"</span>, &amp;Counter::increment);</span><br><span class=\"line\">        counter.method(<span class=\"string\">\"decrement\"</span>, &amp;Counter::decrement);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(counter));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们之前使用的Counter类已经被修改，展示了如何制作实现<code>Php::Countable</code>接口的类。这很简单，你只需要添加<code>Php::Countable</code>类作为基类。这个<code>Php::Countable</code>类有一个纯虚函数<code>count()</code>，必须要实现。</p>\n<p>而这就是你要做的一切。不需要在<code>get_module()</code>函数里面注册专门的<code>count()</code>函数，添加<code>Php::Countable</code>作为基类即可。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a counter</span></span><br><span class=\"line\">$counter = <span class=\"keyword\">new</span> Counter();</span><br><span class=\"line\">$counter-&gt;increment();</span><br><span class=\"line\">$counter-&gt;increment();</span><br><span class=\"line\">$counter-&gt;increment();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// show the current value</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>(count($counter).<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>输出的结果是，正如预期的那样，数值为3。</p>\n<h3 id=\"ArrayAccess接口\"><a href=\"#ArrayAccess接口\" class=\"headerlink\" title=\"ArrayAccess接口\"></a>ArrayAccess接口</h3><p>一个PHP对象可以通过实现<code>Php::ArrayAccess</code>接口变成一个变量，它的行为就像一个数组。当你这样做的时候，可以使用数组访问操作符（<code>$object[&quot;property&quot;]</code>）访问对象。</p>\n<p>在下面的例子中，我们使用<code>Php::Countable</code>和<code>Php::ArrayAccess</code>接口来创建一个可以用来存储字符串的关联数组类（记住：这只是一个例子，PHP已经支持关联数组了，所以这个例子有多大用处还值得商榷）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample Map class, that can be used to map string-to-strings</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Map</span> :</span> <span class=\"keyword\">public</span> Php::Base, <span class=\"keyword\">public</span> Php::Countable, <span class=\"keyword\">public</span> Php::ArrayAccess</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Internally, a C++ map is used</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    std::map&lt;std::string,std::string&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>,<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; _map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and C++ destructpr</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Map() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Map() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method from the Php::Countable interface that</span></span><br><span class=\"line\"><span class=\"comment\">     *  returns the number of elements in the map</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return long</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _map.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method from the Php::ArrayAccess interface that is</span></span><br><span class=\"line\"><span class=\"comment\">     *  called to check if a certain key exists in the map</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  key</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return bool</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">offsetExists</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _map.find(key) != _map.end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Set a member</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  key</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">offsetSet</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key, <span class=\"keyword\">const</span> Php::Value &amp;value)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _map[key] = value.stringValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Retrieve a member</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  key</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> Php::<span class=\"function\">Value <span class=\"title\">offsetGet</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _map[key];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Remove a member</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">offsetUnset</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _map.erase(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows</span></span><br><span class=\"line\">        <span class=\"comment\">// which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Map&gt; <span class=\"built_in\">map</span>(<span class=\"string\">\"Map\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(<span class=\"built_in\">map</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Php::ArrayAccess</code>有四个纯虚函数必须要实现。这些方法是用来检索和覆盖一个元素的方法，用来检查是否存在某个键的元素，以及用来删除一个元素的方法。在这个例子中，这些方法都已经实现了转发到一个常规的C++ <code>std::map</code>对象。</p>\n<p>在<code>get_module()</code>函数里面，Map被注册并添加到扩展中。但与其他许多例子不同的是，没有一个类方法被导出到PHP中。它只实现了<code>Php::Countable</code>接口和<code>Php::ArrayAccess</code>接口，所以它完全可以用来存储和检索属性，但是从一个PHP脚本来看，它没有任何可调用的方法。下面的脚本展示了如何使用它。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a map</span></span><br><span class=\"line\">$map = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// store some values</span></span><br><span class=\"line\">$map[<span class=\"string\">\"a\"</span>] = <span class=\"number\">1234</span>;</span><br><span class=\"line\">$map[<span class=\"string\">\"b\"</span>] = <span class=\"string\">\"xyz\"</span>;</span><br><span class=\"line\">$map[<span class=\"string\">\"c\"</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// show the values</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($map[<span class=\"string\">\"a\"</span>].<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>($map[<span class=\"string\">\"b\"</span>].<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>($map[<span class=\"string\">\"c\"</span>].<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// access a value that does not exist</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($map[<span class=\"string\">\"d\"</span>].<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this will result in a fatal error,</span></span><br><span class=\"line\"><span class=\"comment\">// the ArrayAccess methods are not exported to user space</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($map-&gt;offsetGet(<span class=\"string\">\"a\"</span>).<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>输出不言而喻。该Map有三个成员，”1234”（字符串变量）、”xyz “和 “0”。</p>\n<h3 id=\"Traversable接口\"><a href=\"#Traversable接口\" class=\"headerlink\" title=\"Traversable接口\"></a>Traversable接口</h3><p>类也可以像普通数组一样，在foreach循环中使用。如果你想启用这个功能，你的类应该从<code>Php::Traverable</code>基类中扩展出来并实现<code>getIterator()</code>方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fill a map</span></span><br><span class=\"line\">$map = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\">$map[<span class=\"string\">\"a\"</span>] = <span class=\"number\">1234</span>;</span><br><span class=\"line\">$map[<span class=\"string\">\"b\"</span>] = <span class=\"number\">5678</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// iterate over it</span></span><br><span class=\"line\"><span class=\"keyword\">foreach</span> ($map <span class=\"keyword\">as</span> $key =&gt; $value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// output the key and value</span></span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(<span class=\"string\">\"$key: $value\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PHP-CPP 库实现迭代器的方式与 SPL 略有不同，如果你一直在使用 PHP，你就会习惯这种方式。在PHP中，为了使一个类可以遍历（在foreach循环中使用），你必须实现<code>Iterator</code>接口或<code>IteratorAggregate</code>接口。这是一个奇特的架构。仔细想想，迭代器不是容器对象本身，那个容器对象才是可迭代的!。在我们上面的例子中，$map变量不是实际的迭代器，而是被迭代的容器。真正的迭代器是一个隐藏的对象，不会暴露在你的PHP脚本中，它控制着foreach循环。然而，SPL也会将该map称为迭代器。</p>\n<p>因此，在 PHP-CPP 中，我们决定不遵循 SPL API，而是创建了一种全新的方式来实现可遍历类。要使一个类可遍历，必须从<code>Php::Traversable</code>基类中扩展出来，这就迫使你实现<code>getIterator()</code>方法。这个方法应该返回一个<code>Php::Iterator</code>实例。</p>\n<p><code>Php::Iterator</code>对象有五个方法是运行foreach循环所需要的。请注意，你的 <code>Iterator</code> 类不需要是一个可以从 PHP 中访问的类，也不需要从 <code>Php::Base</code> 派生。它是一个内部类，被foreach循环使用，但它并不（必须）存在于PHP用户空间。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample iterator class that can be used to iterate</span></span><br><span class=\"line\"><span class=\"comment\"> *  over a map of strings</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapIterator</span> :</span> <span class=\"keyword\">public</span> Php::Iterator</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The map that is being iterated over</span></span><br><span class=\"line\"><span class=\"comment\">     *  This is a reference to the actual map</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    std::map&lt;std::string,std::string&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>,<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; &amp;_map;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The actual C++ iterator</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    std::map&lt;std::string,std::string&gt;l;::const_iterator;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>,<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;::const_iterator _iter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Constructor</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  object      The object that is being iterated over</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  map         The internal C++ map that is being iterated over</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    MapIterator(Map *object, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>,<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; &amp;<span class=\"built_in\">map</span>) :</span><br><span class=\"line\">        Php::Iterator(object), _map(<span class=\"built_in\">map</span>), _iter(<span class=\"built_in\">map</span>.begin()) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~MapIterator() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Is the iterator on a valid position</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return bool</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">valid</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _iter != _map.end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The value at the current position</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> Php::<span class=\"function\">Value <span class=\"title\">current</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _iter-&gt;second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The key at the current position</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> Php::<span class=\"function\">Value <span class=\"title\">key</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _iter-&gt;first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Move to the next position</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _iter++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Rewind the iterator to the front position</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">rewind</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _iter = _map.begin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample Map class, that can be used to map string-to-strings</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Map</span> :</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Php::Base,</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Php::Countable,</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Php::ArrayAccess,</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Php::Traversable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Internally, a C++ map is used</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    std::map&lt;std::string,std::string&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>,<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; _map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and C++ destructpr</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Map() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Map() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method from the Php::Countable interface that</span></span><br><span class=\"line\"><span class=\"comment\">     *  returns the number of elements in the map</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return long</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">long</span> <span class=\"title\">count</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _map.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method from the Php::ArrayAccess interface that is</span></span><br><span class=\"line\"><span class=\"comment\">     *  called to check if a certain key exists in the map</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  key</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return bool</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">offsetExists</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _map.find(key) != _map.end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Set a member</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  key</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">offsetSet</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key, <span class=\"keyword\">const</span> Php::Value &amp;value)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _map[key] = value.stringValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Retrieve a member</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  key</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> Php::<span class=\"function\">Value <span class=\"title\">offsetGet</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _map[key];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Remove a member</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param key</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">offsetUnset</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;key)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _map.erase(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Get the iterator</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Php::Iterator</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> Php::<span class=\"function\">Iterator *<span class=\"title\">getIterator</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// construct a new map iterator on the heap</span></span><br><span class=\"line\">        <span class=\"comment\">// the (PHP-CPP library will delete it when ready)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MapIterator(<span class=\"keyword\">this</span>, _map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows</span></span><br><span class=\"line\">        <span class=\"comment\">// which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Map&gt; <span class=\"built_in\">map</span>(<span class=\"string\">\"Map\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(<span class=\"built_in\">map</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子进一步扩展了Map类。现在它实现了<code>Php::Countable</code>、<code>Php::ArrayAccess</code>和<code>Php::Traversable</code>。这意味着现在也可以在foreach循环中使用Map对象来迭代属性。</p>\n<p>为了达到这个目的，我们必须将<code>Php::Traversable</code>类作为基类添加到Map类中，并实现<code>getIterator()</code>方法。这个方法返回一个新的<code>MapIterator</code>类，它是在堆上分配的。不用担心内存管理：PHP-CPP 库会在 foreach 循环结束的那一刻销毁迭代器。</p>\n<p><code>MapIterator</code>类是由<code>Php::Iterator</code>类派生出来的，实现了运行foreach循环所需的五个方法（current()、key()、next()、rewind()和valid()）。请注意，基本的<code>Php::Iterator</code>类期望将迭代过的对象传递给构造函数。这一点是必须的，这样迭代器对象才能确保只要迭代器存在，这个迭代对象就会一直在范围内。</p>\n<p>我们内部的<code>MapIterator</code>实现只是一个C++迭代器类的小包装。当然，在需要的时候，你可以创建更复杂的迭代器。</p>\n<h3 id=\"Serializable接口\"><a href=\"#Serializable接口\" class=\"headerlink\" title=\"Serializable接口\"></a>Serializable接口</h3><p>通过实现 <code>Php::Serializable</code> 接口，你可以为一个类安装自定义的序列化和非序列化处理程序。PHP内置的<code>serialize()</code>函数是一个可以将数组或对象（甚至是充满数组和对象的嵌套数据结构变成简单字符串的函数。<code>unserialize()</code>方法正好相反，它将这样的字符串变回原始数据结构。</p>\n<p>一个类的默认序列化实现将一个对象的所有公开可见的属性，并将它们连接成一个字符串。但由于你的类有一个本地实现，而且可能没有公共属性，你可能想安装一个自定义的序列化处理程序。在这个处理程序中，你就可以存储本地对象成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Counter class that can be used for counting</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> :</span> <span class=\"keyword\">public</span> Php::Base, <span class=\"keyword\">public</span> Php::Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The initial value</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Counter() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Counter() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Update methods to increment or decrement the counter</span></span><br><span class=\"line\"><span class=\"comment\">     *  Both methods return the NEW value of the counter</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">increment</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> ++_value; &#125;</span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">decrement</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> --_value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method to retrieve the current counter value</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> _value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Serialize the object into a string</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return std::string</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> <span class=\"built_in\">std</span>::<span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">serialize</span><span class=\"params\">()</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::to_string(_value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Unserialize the object from a string</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  buffer</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  size</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">unserialize</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *buffer, <span class=\"keyword\">size_t</span> size)</span> override</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        _value = <span class=\"built_in\">std</span>::atoi(buffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static instance of the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Counter&gt; counter(<span class=\"string\">\"Counter\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::increment&gt;(<span class=\"string\">\"increment\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::decrement&gt;(<span class=\"string\">\"decrement\"</span>);</span><br><span class=\"line\">        counter.method&lt;&amp;Counter::value&gt;(<span class=\"string\">\"value\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(counter));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子将之前看到的Counter例子，变成了一个可序列化的对象。<code>Php::Serializable</code>有两个纯虚函数，应该添加到你的类中。调用<code>serialize()</code>方法将对象变成一个字符串，对一个未初始化的对象调用<code>unserialize()</code>方法将其从一个序列化的字符串中恢复出来。请注意，如果一个对象正在使用<code>unserialize()</code>恢复，那么 <code>__construct()</code>方法将不会被调用!</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an empty counter and increment it a few times</span></span><br><span class=\"line\">$counter = <span class=\"keyword\">new</span> Counter();</span><br><span class=\"line\">$counter-&gt;increment();</span><br><span class=\"line\">$counter-&gt;increment();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// turn the counter into a storable string</span></span><br><span class=\"line\">$serializedCounter = serialize($counter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// revive the counter back into an object</span></span><br><span class=\"line\">$revivedCounter = unserialize($serializedCounter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// show the counter value</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($revivedCounter-&gt;value().<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>输出结果是2</p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><p>当我们开发 PHP-CPP 库时，我们不得不问自己一个问题，那就是我们应该遵循 PHP 惯例还是遵循 C++ 惯例来实现库中的许多功能。</p>\n<p>在 PHP 脚本中，你可以使用<code>魔术方法</code>和<code>魔术接口</code>来为类添加特殊的行为。在C++类中，你也可以实现同样的功能，不过是通过使用<code>操作符重载</code>、<code>隐式构造函数</code>和<code>转换操作符</code>等技术。例如PHP的<code>__invoke()</code>方法，与C++中的<code>operator()</code>多少有些相同。我们问自己的问题是，我们是否应该自动将 PHP 的 <code>__invoke</code> 方法传递给 C++ 的 <code>operator()</code> 调用，还是在 C++ 中也使用同样的 <code>__invoke()</code> 方法名？</p>\n<p>我们决定遵循PHP的惯例，在C++中也使用<code>魔术方法</code>和<code>魔术接口</code>（尽管我们必须承认，以两个下划线开头的方法并不能使代码看起来非常漂亮），但是通过使用魔术方法，对于初学C++的程序员来说，从PHP到C++的转换保持了更简单的状态。而且最重要的是，并不是所有的魔术方法和接口都能用C++的核心特性来实现（比如运算符重载），所以我们不得不使用一些魔术方法或接口。这就是为什么我们决定，既然我们必须在C++中使用一些魔术方法，那么我们也可以完全遵循PHP，在C++中也支持所有的PHP魔术方法。</p>\n<p>除了PHP用户空间中的魔术方法和接口外，Zend引擎还有一些额外的功能是PHP用户空间脚本无法接触到的。这些功能只有扩展程序员才能使用。PHP-CPP库也支持这些特殊功能。这意味着，如果使用PHP-CPP来编写函数和类，可以实现编写纯PHP代码无法实现的事情。</p>\n<h3 id=\"额外的转换函数\"><a href=\"#额外的转换函数\" class=\"headerlink\" title=\"额外的转换函数\"></a>额外的转换函数</h3><p>在内部，Zend引擎有特殊的转换例程来将对象转换为整数、布尔值和浮点值。由于这样或那样的原因，一个PHP脚本只能实现<code>__toString()</code>方法，而其他所有的转换操作都远离它。PHP-CPP 库解决了这一限制，并允许实现其他的转换函数。</p>\n<p>PHP-CPP 库的设计目标之一是尽可能地接近 PHP。出于这个原因，转换函数被赋予了与 <code>__toString()</code> 方法相匹配的名称：<code>__toInteger()</code>, <code>__toFloat()</code> 和 <code>__toBool()</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample class, with methods to cast objects to scalars</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor and C++ destructpr</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    MyClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~MyClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Cast to a string</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *  Note that now we use const char* as return value, and not Php::Value.</span></span><br><span class=\"line\"><span class=\"comment\">     *  The __toString function is detected at compile time, and it does</span></span><br><span class=\"line\"><span class=\"comment\">     *  not have a fixed signature. You can return any value that can be picked</span></span><br><span class=\"line\"><span class=\"comment\">     *  up by a Php::Value object.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return const char *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *__toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"abcd\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Cast to a integer</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return long</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> __toInteger()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1234</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Cast to a floating point number</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return double</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> __toFloat()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">88.88</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Cast to a boolean</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return bool</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> __toBool()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\"> *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows</span></span><br><span class=\"line\">        <span class=\"comment\">// which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;MyClass&gt; myClass(<span class=\"string\">\"MyClass\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(myClass));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当一个对象被转换为标量类型时，或者在标量上下文中使用时，会自动调用转换方法。下面的例子说明了这一点。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize an object</span></span><br><span class=\"line\">$object = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cast it</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>((string)$object.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>((int)$object.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>((bool)$object.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>((float)$object.<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象比较\"><a href=\"#对象比较\" class=\"headerlink\" title=\"对象比较\"></a>对象比较</h3><p>如果你在PHP中用<code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>等比较运算符比较两个对象，Zend引擎会运行一个对象比较函数。PHP-CPP库会拦截这个方法，并将比较方法传递给你的类的<code>__compare</code>方法。换句话说，如果你想安装一个自定义的比较操作符，你可以通过实现<code>__compare()</code>来实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  A sample class, that shows how objects can be compared</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Internal value of the class</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _value;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ constructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    MyClass()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// start with random value</span></span><br><span class=\"line\">        _value = rand();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  C++ destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~MyClass() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Cast the object to a string</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return std::string</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> __toString()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::to_string(_value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Compare with a different object</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  that</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> __compare(<span class=\"keyword\">const</span> MyClass &amp;that) <span class=\"keyword\">const</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _value - that._value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当你在PHP脚本中尝试比较对象时，比较函数会被自动调用。当两个对象相同时，它应该返回0，当’this’对象较小时，返回小于0的值，当’this’对象较大时，返回大于0的值。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// initialize a couple of objects</span></span><br><span class=\"line\">$object1 = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">$object2 = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\">$object3 = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// compare the objects</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($object1 &lt; $object2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(<span class=\"string\">\"$object1 is smaller than $object2\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(<span class=\"string\">\"$object1 is bigger than $object2\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ($object1 == $object3)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(<span class=\"string\">\"$object1 is equal to $object3\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(<span class=\"string\">\"$object1 is not equal to $object3\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类成员属性\"><a href=\"#类成员属性\" class=\"headerlink\" title=\"类成员属性\"></a>类成员属性</h2><p>当你在PHP中定义一个类时，你可以为它添加属性（成员变量）。然而，当你在一个本地C++类中添加成员变量时，你最好使用常规的本地成员变量，而不是PHP变量。原生变量的性能比PHP变量好得多，如果你也能用<code>int&#39;s</code>和<code>std::string</code>对象来存储整数或字符串，那么在<code>Php::Value</code>对象中存储这些变量就太疯狂了。</p>\n<h3 id=\"普通成员变量\"><a href=\"#普通成员变量\" class=\"headerlink\" title=\"普通成员变量\"></a>普通成员变量</h3><p>很难想象，世界上有人愿意创建一个原生类，上面有常规的弱类型的PHP公共属性。然而，如果你坚持，你可以使用PHP-CPP库来实现。让我们以PHP中的一个类为例，看看它在C++中会是什么样子。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Define a public property</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $property1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Constructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// initialize the property</span></span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;property1 = <span class=\"string\">\"xyz\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Example method</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something with the public property (like changing it)</span></span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;property = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create an instance</span></span><br><span class=\"line\">$example = <span class=\"keyword\">new</span> Example();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// overwrite the public property</span></span><br><span class=\"line\">$example-&gt;property1 = <span class=\"string\">\"new value\"</span>;</span><br></pre></td></tr></table></figure>\n<p>上面的例子创建了一个具有一个公共属性的类。这个属性可以被Example类访问，并且因为它是公共的，也可以被其他所有人访问，如示例中所示。如果你喜欢这样的类，你可以用PHP-CPP写一些类似的东西。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  C++ Example class</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  c++ constructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Example() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  c++ destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Example() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  php \"constructor\"</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> __construct()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// get self reference as Php::Value object</span></span><br><span class=\"line\">        Php::<span class=\"function\">Value <span class=\"title\">self</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// initialize a public property</span></span><br><span class=\"line\">        self[<span class=\"string\">\"property1\"</span>] = <span class=\"string\">\"xyz\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Example method</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// get self reference as Php::Value object</span></span><br><span class=\"line\">        Php::<span class=\"function\">Value <span class=\"title\">self</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// overwrite the property</span></span><br><span class=\"line\">        self[<span class=\"string\">\"property1\"</span>] = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context so that the get_module() function can be</span></span><br><span class=\"line\"><span class=\"comment\"> *  called by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function for the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Example&gt; example(<span class=\"string\">\"Example\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// register the methods</span></span><br><span class=\"line\">        example.method&lt;&amp;Example::__construct&gt;(<span class=\"string\">\"__construct\"</span>);</span><br><span class=\"line\">        example.method&lt;&amp;Example::method&gt;(<span class=\"string\">\"method\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the Example class has one public property</span></span><br><span class=\"line\">        example.property(<span class=\"string\">\"property1\"</span>, <span class=\"string\">\"xyz\"</span>, Php::Public);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(example));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该示例代码显示了如何在<code>get_module()</code>函数中初始化属性。</p>\n<p>你也可以定义私有或受保护的属性，而不是公共属性，但即使是这样也可能不是你想要的，因为在原生C++变量中存储数据要快得多。</p>\n<h3 id=\"静态属性和类常量\"><a href=\"#静态属性和类常量\" class=\"headerlink\" title=\"静态属性和类常量\"></a>静态属性和类常量</h3><p>静态属性和类常量可以用类似于属性的方式来定义。唯一不同的是，你必须传递<code>Php::Static</code>或<code>Php::Const</code>标志，而不是<code>Php::Public</code>、<code>Php::Private</code>或<code>Php::Protected</code>访问修饰符。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @todo your class definition</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Switch to C context so that the get_module() function can be</span></span><br><span class=\"line\"><span class=\"comment\">    *  called by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        *  Startup function for the extension</span></span><br><span class=\"line\"><span class=\"comment\">        *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Example&gt; example(<span class=\"string\">\"Example\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the Example class has a class constant</span></span><br><span class=\"line\">        example.property(<span class=\"string\">\"MY_CONSTANT\"</span>, <span class=\"string\">\"some value\"</span>, Php::Const);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// and a public static propertie</span></span><br><span class=\"line\">        example.property(<span class=\"string\">\"my_property\"</span>, <span class=\"string\">\"initial value\"</span>, Php::Public | Php::Static);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(example));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类常量可以通过使用<code>Example::MY_CONSTANT</code>从PHP脚本中访问，静态属性可以使用<code>Example::$my_property</code>访问。</p>\n<p>除了使用<code>property()</code>方法，你还可以使用<code>constant()</code>方法，或者使用<code>Php::Constant</code>类创建类常量。</p>\n<h3 id=\"Smart-properties\"><a href=\"#Smart-properties\" class=\"headerlink\" title=\"Smart properties\"></a>Smart properties</h3><p>通过<code>get()</code>和<code>set()</code>魔术方法，你可以制作更高级的属性，这些属性可以直接映射到C++变量上，并且当一个属性被覆盖时，你可以执行额外的检查，从而使一个对象始终处于有效状态。</p>\n<p>除此之外，通过 PHP-CPP 库，你还可以为属性分配 <code>getter</code> 和 <code>setter</code> 方法。每当一个属性被访问时，你的getter或setter方法就会被自动调用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  C++ Example class</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Example property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @var    int</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> _value = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  c++ constructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Example() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  c++ destructor</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Example() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method to get access to the property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Php::Value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">getValue</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method to overwrite the property</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;value)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// overwrite property</span></span><br><span class=\"line\">        _value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// sanity check: the value should never exceed 100</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_value &gt; <span class=\"number\">100</span>) _value = <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method to retrieve the double property value</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Php::Value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">getDouble</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _value * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context so that the get_module() function can be</span></span><br><span class=\"line\"><span class=\"comment\"> *  called by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function for the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// description of the class so that PHP knows which methods are accessible</span></span><br><span class=\"line\">        Php::Class&lt;Example&gt; example(<span class=\"string\">\"Example\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// register the \"value\" property, with the methods to get and set it</span></span><br><span class=\"line\">        example.property(<span class=\"string\">\"value\"</span>, &amp;Example::getValue, &amp;Example::setValue);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// register a read-only \"double\" property, with a method to get it</span></span><br><span class=\"line\">        example.property(<span class=\"string\">\"double\"</span>, &amp;Example::getDouble);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(example));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的PHP脚本使用了这一点。它创建了一个示例对象，将值属性设置为500（这是不允许的，高于100的值会被四舍五入到100），然后它读出双倍值。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create object</span></span><br><span class=\"line\">$object = <span class=\"keyword\">new</span> Example();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set the value</span></span><br><span class=\"line\">$object-&gt;value = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// show the double value</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>($object-&gt;double.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// update the double value</span></span><br><span class=\"line\"><span class=\"comment\">// (this will trigger an error, this is a read-only property)</span></span><br><span class=\"line\">$object-&gt;double = <span class=\"number\">300</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>PHP和C++都支持异常，通过PHP-CPP库，这两种语言之间的异常处理是完全透明的。在 C++ 中抛出的异常会自动传递给 PHP 脚本，而 PHP 脚本抛出的异常可以被 C++ 代码捕获，就像一个普通的 C++ 异常一样。</p>\n<p>让我们从一个简单的抛出异常的C++函数开始。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Simple function that takes two numeric parameters,</span></span><br><span class=\"line\"><span class=\"comment\"> *  and that divides them. Division by zero is of course</span></span><br><span class=\"line\"><span class=\"comment\"> *  not permitted - it will throw an exception then</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">myDiv</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// division by zero is not permitted, throw an exception when this happens</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (params[<span class=\"number\">1</span>] == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> Php::Exception(<span class=\"string\">\"Division by zero\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// divide the two parameters</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> params[<span class=\"number\">0</span>] / params[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\">        extension.add&lt;myDiv&gt;(<span class=\"string\">\"myDiv\"</span>, &#123;</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"a\"</span>, Php::Type::Numeric, <span class=\"literal\">true</span>),</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"b\"</span>, Php::Type::Numeric, <span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你又一次看到了一个非常简单的扩展。在这个扩展中，我们创建了一个 “myDiv “函数，用来除以两个数字。但是除以零当然是不允许的，所以当试图除以零时，会产生一个异常。下面的 PHP 脚本就使用了这个功能。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(myDiv(<span class=\"number\">10</span>,<span class=\"number\">2</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(myDiv(<span class=\"number\">8</span>,<span class=\"number\">4</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(myDiv(<span class=\"number\">5</span>,<span class=\"number\">0</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(myDiv(<span class=\"number\">100</span>,<span class=\"number\">10</span>).<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (<span class=\"keyword\">Exception</span> $exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">echo</span>(<span class=\"string\">\"exception caught\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子显示了从C++代码中抛出异常并在PHP脚本中捕获异常是多么的简单。PHP-CPP 库会在内部捕获你的 C++ 异常并将其转换为 PHP 异常，但这一切都发生在引擎盖下。对于你这个扩展程序员来说，就好像你根本没有在两种不同的语言中工作，你可以简单地抛出一个Php::Exception对象，就好像它是一个普通的PHP异常一样。</p>\n<h3 id=\"在C-中捕获异常\"><a href=\"#在C-中捕获异常\" class=\"headerlink\" title=\"在C++中捕获异常\"></a>在C++中捕获异常</h3><p>反过来，如果你的扩展调用了一个PHP函数，而这个PHP函数恰好抛出了一个异常，你可以像捕获一个普通的C++异常一样捕获它。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">callMe</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// prevent that exceptions bubble up</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// call the function that was supplied by the user</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> params[<span class=\"number\">0</span>]();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Php::Exception &amp;exception)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Exception caught!\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\">        extension.add&lt;callMe&gt;(<span class=\"string\">\"callMe\"</span>, &#123;</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"callback\"</span>, Php::Type::Callable, <span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码需要解释一下。正如我们之前提到的，<code>Php::Value</code> 对象可以像使用普通的 PHP <code>$variable</code> 一样使用，因此你可以在其中存储整数、字符串、对象、数组等等。但这也意味着你可以用它来存储函数（因为 PHP 变量也可以用来存储函数）！而这正是我们要做的。</p>\n<p>本例扩展中的 <code>callMe()</code> 函数只接收一个参数：一个它将立即调用的回调函数，回调函数的返回值也由 <code>callMe()</code> 函数返回。如果这个回调函数以某种方式抛出一个异常，它将被<code>callMe()</code>函数捕获，并返回一个替代的字符串(“Exception caught!”)。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// call \"callMe\" for the first time, and supply a function that returns \"first call\"</span></span><br><span class=\"line\">$output = callMe(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"First call\"</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// show output (this will be \"First call\")</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>(<span class=\"string\">\"$output\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// call \"callMe\" for the second time, but throw an exception this time</span></span><br><span class=\"line\">$output = callMe(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"keyword\">Exception</span>(<span class=\"string\">\"Sorry...\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Second call\\n\"</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// show output (this will be \"Exception caught\")</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span>(<span class=\"string\">\"$output\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这个 PHP 脚本使用了我们的扩展，并连续两次调用 callMe() 函数。首先用一个普通函数返回一个字符串，然后用一个抛出异常的函数（扩展会捕捉到这个异常）。输出结果正如你所期望的那样。</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>PHP中的变量是弱类型的。因此，一个变量可以容纳任何可能的类型：整数、字符串、浮点数，甚至一个对象或数组。而C++则是一种强类型语言。在C++中，一个整数变量总是有一个数值，而一个字符串变量总是持有一个字符串值。</p>\n<p>当你把本地代码和PHP代码混合在一起时，你需要把弱类型的PHP变量转换成本地变量，反之则是：把本地变量转换成弱类型的PHP变量。PHP-CPP库提供了<code>Php::Value</code>类，使这个任务变得非常简单。</p>\n<h3 id=\"Zval’s\"><a href=\"#Zval’s\" class=\"headerlink\" title=\"Zval’s\"></a>Zval’s</h3><p>如果你曾经花时间用纯C语言编写过PHP扩展，或者你曾经读过一些关于PHP内部的东西，你一定听说过<code>zval</code>的。zval是一个存储PHP变量的C结构。在内核中，这个zval保留了一个<code>refcount</code>、一个多种类型的联合体和一些其他成员。每次访问这样的zval，对它进行复制，或者对它进行写入，你都必须打破头正确更新<code>refcount</code>，或将zval分割成不同的zval，显式调用复制构造函数，分配或释放内存（使用特殊的内存分配例程），或者选择不这样做，让zval单独存在。</p>\n<p>更糟糕的是，在Zend引擎中，有数百个不同的未被记录的宏和函数可以操作这些zval变量。有专门的宏针对zval，有通过<code>指针</code>指向zval的宏，有通过<code>指针的指针</code>指向zval的宏，甚至有通过<code>指针的指针的指针</code>指向zval的宏。</p>\n<p>每一个PHP模块、每一个PHP扩展和每一个内置的PHP函数都在忙于处理这些zval结构。没有人花时间把这样的zval包在一个简单的C++类中，为你完成所有这些管理，这是一个很大的惊喜。C++就是这样一门不错的语言，它的构造函数、析构函数、转换运算符和运算符重载，可以封装这些复杂的zval处理。</p>\n<p>PHP-CPP引入了<code>Php::Value</code>对象，它的接口非常简单，可以消除所有zval处理的问题。在内部，<code>Php::Value</code>对象是zval变量的一个包装器，但它完全隐藏了zval处理的复杂性。</p>\n<h3 id=\"标量类型\"><a href=\"#标量类型\" class=\"headerlink\" title=\"标量类型\"></a>标量类型</h3><p><code>Php::Value</code>对象可以用来存储标量类型。可以是整数、浮点数、字符串、布尔值和空值等变量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Php::Value value1 = <span class=\"number\">1234</span>;</span><br><span class=\"line\">Php::Value value2 = <span class=\"string\">\"this is a string\"</span>;</span><br><span class=\"line\">Php::Value value3 = <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>(<span class=\"string\">\"another string\"</span>);</span><br><span class=\"line\">Php::Value value4 = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">Php::Value value5 = <span class=\"number\">123.45</span>;</span><br><span class=\"line\">Php::Value value6 = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p><code>Php::Value</code>类有转换操作符，可以将对象转换成几乎所有可以想到的本地类型。当你可以访问一个<code>Php::Value</code>对象，但想把它存储在一个（访问速度快得多的）本地变量中时，你可以简单地赋值它。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value1 = value;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> value2 = value;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> value3 = value;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> value4 = value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 <code>Php::Value</code> 对象持有一个对象，并且你把它用成一个字符串，那么对象的 <code>__toString()</code> 方法就会被调用，这和你在 PHP 脚本中把变量用成字符串的情况完全一样。</p>\n<p>许多不同的操作符也被重载，因此你可以在算术操作中直接使用<code>Php::Value</code>对象，将其与其他变量进行比较，或者将其发送到一个输出流。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(Php::Value &amp;value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    value += <span class=\"number\">10</span>;</span><br><span class=\"line\">    Php::out &lt;&lt; value &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"string\">\"some string\"</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = value - <span class=\"number\">8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Php::Value</code>对象对大多数类型都有隐式构造函数。这意味着每一个接受<code>Php::Value</code>作为参数的函数也可以用原生类型来调用，在应该返回<code>Php::Value</code>的函数中，你可以简单地指定一个标量返回值（它将被编译器自动转换为<code>Php::Value</code>对象）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"number\">12</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &gt; <span class=\"number\">100</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> myFunction(<span class=\"number\">12</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如你在例子中看到的，你几乎可以用<code>Php::Value</code>对象做任何事情。在内部，它完成了所有的zval操作，有时会变得很复杂，但对于你这个扩展程序员来说，没什么好担心的。</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串可以轻松地存储在<code>Php::Value</code>对象中。将一个字符串赋给<code>Php::Value</code>，或者将一个<code>Php::Value</code>转换为一个字符串是如此的简单，以至于几乎没有任何解释的必要。通常情况下，赋值运算符和转换运算符即可。然而，当性能是一个问题时，你可以考虑直接访问<code>Php::Value</code>对象的内部缓冲区。</p>\n<p>当一个<code>Php::Value</code>被转换为<code>std::string</code>时，整个字符串的内容会从<code>Php::Value</code>对象复制到<code>std::string</code>对象中。如果你不想做这样一个完整的拷贝，你可以把值投给一个<code>const char *</code>来代替。这使你可以直接访问<code>Php::Value</code>对象内部的缓冲区。字符串的大小可以用<code>size()</code>方法来检索。但你必须意识到，一旦<code>Php::Value</code>脱离了作用域，缓冲区的指针就不再保证有效了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Example function</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  params</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// store the first parameter in a std::string (the entire string</span></span><br><span class=\"line\">    <span class=\"comment\">// buffer is copied from the Php::Value object to the std::string)</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> var1 = params[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// it also is possible to cast the object into a const char *. This works</span></span><br><span class=\"line\">    <span class=\"comment\">// too, but the buffer is only valid for as long as the Php::Value object</span></span><br><span class=\"line\">    <span class=\"comment\">// stays in scope</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *var2 = params[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> var2size = params[<span class=\"number\">0</span>].size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以直接写到内核的<code>Php::Value</code>缓冲区。当你把一个字符串分配给<code>Php::Value</code>对象时，整个字符串缓冲区也会被复制。不管你赋值的字符串是<code>std::string</code>还是<code>char*</code>都会有一个拷贝。对于少量字节来说，这几乎不是问题，如果你换一种方式，会让你的代码可读性大大降低。但如果你要复制很多字节，你最好能直接访问缓冲区。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Example function to read bytes from a filedescriptor, and</span></span><br><span class=\"line\"><span class=\"comment\"> *  return it as a Php::Value object</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  fd          Filedescriptor</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return Php::Value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">readExample1</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// buffer to read the bytes in</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buffer[<span class=\"number\">4096</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// read the buffer</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes = read(fd, buffer, <span class=\"number\">4096</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>) bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// convert the buffer to a Php::Value object and return it</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Php::Value(buffer, bytes);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Another example function, that does the same as the previous</span></span><br><span class=\"line\"><span class=\"comment\"> *  function, but now it reads the bytes directly into a Php::Value</span></span><br><span class=\"line\"><span class=\"comment\"> *  buffer, and does not use an intermediate buffer.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  fd          Filedescriptor</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  Php::Value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">readExample2</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// result variable</span></span><br><span class=\"line\">    Php::Value result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// resize the buffer to 4096 bytes, the reserve() method resizes</span></span><br><span class=\"line\">    <span class=\"comment\">// the internal buffer to the appropriate size, and returns a pointer</span></span><br><span class=\"line\">    <span class=\"comment\">// to the buffer</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *buffer = result.reserve(<span class=\"number\">4096</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// read in the bytes directly into the just allocated buffer</span></span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes = read(fd, buffer, <span class=\"number\">4096</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>) bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// resize the buffer to the actual number of bytes in it (this</span></span><br><span class=\"line\">    <span class=\"comment\">// is necessary, otherwise the PHP strlen() returns 4096 even</span></span><br><span class=\"line\">    <span class=\"comment\">// when less bytes were available</span></span><br><span class=\"line\">    result.reserve(bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// return the result</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个例子函数比较容易读懂。<code>read()</code>系统调用用于向本地缓冲区填充字节。然后将这个本地缓冲区转换为<code>Php::Value</code>对象并返回。</p>\n<p>第二个示例函数更有效率，因为现在系统调用<code>read()</code>会立即将字节读到<code>Php::Value</code>对象的缓冲区中，而不是读到一个临时缓冲区中。作为一个程序员，你必须根据你的需求在这些算法中选择一种：<strong>简单的代码或更高效的代码</strong>。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>PHP支持两种数组类型：常规数组（以数字为索引）和关联数组（以字符串为索引）。<code>Php::Value</code>对象也支持数组。通过使用数组访问操作符(方括号)给<code>Php::Value</code>对象赋值，你会自动把它变成一个数组。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a regular array</span></span><br><span class=\"line\">Php::Value <span class=\"built_in\">array</span>;</span><br><span class=\"line\"><span class=\"built_in\">array</span>[<span class=\"number\">0</span>] = <span class=\"string\">\"apple\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">array</span>[<span class=\"number\">1</span>] = <span class=\"string\">\"banana\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">array</span>[<span class=\"number\">2</span>] = <span class=\"string\">\"tomato\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// an initializer list can be used to create a filled array</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">filled</span><span class=\"params\">(&#123; <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>&#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// you can cast an array to a vector, template parameter can be</span></span><br><span class=\"line\"><span class=\"comment\">// any type that a Value object is compatible with (string, int, etc)</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; fruit = <span class=\"built_in\">array</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create an associative array</span></span><br><span class=\"line\">Php::Value assoc;</span><br><span class=\"line\">assoc[<span class=\"string\">\"apple\"</span>] = <span class=\"string\">\"green\"</span>;</span><br><span class=\"line\">assoc[<span class=\"string\">\"banana\"</span>] = <span class=\"string\">\"yellow\"</span>;</span><br><span class=\"line\">assoc[<span class=\"string\">\"tomato\"</span>] = <span class=\"string\">\"green\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the variables in an array do not all have to be of the same type</span></span><br><span class=\"line\">Php::Value assoc2;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"x\"</span>] = <span class=\"string\">\"info@example.com\"</span>;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"y\"</span>] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"z\"</span>] = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nested arrays are possible too</span></span><br><span class=\"line\">Php::Value assoc2;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"x\"</span>] = <span class=\"string\">\"info@example.com\"</span>;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"y\"</span>] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"z\"</span>][<span class=\"number\">0</span>] = <span class=\"string\">\"a\"</span>;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"z\"</span>][<span class=\"number\">1</span>] = <span class=\"string\">\"b\"</span>;</span><br><span class=\"line\">assoc2[<span class=\"string\">\"z\"</span>][<span class=\"number\">2</span>] = <span class=\"string\">\"c\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// assoc arrays can be cast to a map, indexed by string</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>,<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; <span class=\"built_in\">map</span> = assoc2;</span><br></pre></td></tr></table></figure>\n<p>从数组中读取数据也同样简单。你也可以使用数组访问运算符（方括号）来实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Php::Value <span class=\"built_in\">array</span>;</span><br><span class=\"line\"><span class=\"built_in\">array</span>[<span class=\"string\">\"x\"</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">array</span>[<span class=\"string\">\"y\"</span>] = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Php::out &lt;&lt; <span class=\"built_in\">array</span>[<span class=\"string\">\"x\"</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">Php::out &lt;&lt; <span class=\"built_in\">array</span>[<span class=\"string\">\"y\"</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>还有一个特殊的<code>Php::Array</code>类。这是一个扩展的<code>Php::Value</code>类，在构造时，立即以空数组开始（不像<code>Php::Value</code>对象默认构造为<code>NULL</code>值）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create empty array</span></span><br><span class=\"line\">Php::Array array1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Php::Value is the base class, so you can assign Php::Array objects</span></span><br><span class=\"line\">Php::Value array2 = array1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// impossible, a Php::Array must always be an array</span></span><br><span class=\"line\">array1 = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>就像<code>Php::Array</code>类是一个扩展的<code>Php::Value</code>，初始化为一个空数组一样，也有一个<code>Php::Object</code>类在构造时成为一个对象。默认情况下，这是一个<code>stdClass</code>的实例（PHP最简单的类）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create empty object of type stdClass</span></span><br><span class=\"line\">Php::Object object;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Php::Value is the base class, so you can assign Php::Object objects</span></span><br><span class=\"line\">Php::Value value = object;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// impossible, a Php::Object must always be an object</span></span><br><span class=\"line\">object = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// object properties can be accessed with square brackets</span></span><br><span class=\"line\">object[<span class=\"string\">\"property1\"</span>] = <span class=\"string\">\"value1\"</span>;</span><br><span class=\"line\">object[<span class=\"string\">\"property2\"</span>] = <span class=\"string\">\"value2\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// to create an object of a different type, pass in the class name</span></span><br><span class=\"line\"><span class=\"comment\">// to the constructor with optional constructor parameters</span></span><br><span class=\"line\">object = Php::Object(<span class=\"string\">\"DateTime\"</span>, <span class=\"string\">\"now\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// methods can be called with the call() method</span></span><br><span class=\"line\">Php::out &lt;&lt; object.call(<span class=\"string\">\"format\"</span>, <span class=\"string\">\"Y-m-d H:i:s\"</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// all these methods can be called on a Php::Value object too</span></span><br><span class=\"line\">Php::Value value = Php::Object(<span class=\"string\">\"DateTime\"</span>, <span class=\"string\">\"now\"</span>);</span><br><span class=\"line\">Php::out &lt;&lt; value.call(<span class=\"string\">\"format\"</span>, <span class=\"string\">\"Y-m-d H:i:s\"</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>当你用PHP-CPP库创建了自己的类，你可以使用相同的<code>Php::Object</code>类来制作它的实例。因为PHP和C++是不同的语言，所以从函数中返回的对象实例（<code>Php::Value</code>或<code>Php::Object</code>实例）和在C++代码中内核使用的变量（普通的C++指针）是有区别的。PHP-CPP允许你轻松转换这两种类型。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  First factory method</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Php::Value      object holding a new MyClass instance</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Php::<span class=\"function\">Value <span class=\"title\">factory1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// use the Php::Object class to create an instance (this will</span></span><br><span class=\"line\">        <span class=\"comment\">// result in __construct() being called)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Php::Object(<span class=\"string\">\"MyClass\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Alternative factory method</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Php::Value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Php::<span class=\"function\">Value <span class=\"title\">factory2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create an instance ourselves</span></span><br><span class=\"line\">        MyClass *object = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the object now only exists as C++ object, to ensure that it is also</span></span><br><span class=\"line\">        <span class=\"comment\">// registered as an object in PHP user space, we wrap it in a</span></span><br><span class=\"line\">        <span class=\"comment\">// Php::Object class (which is an extended Php::Value class). Because</span></span><br><span class=\"line\">        <span class=\"comment\">// PHP supports reflection it is necessary to also pass in the class</span></span><br><span class=\"line\">        <span class=\"comment\">// name. The __construct() method will _not_ be called - because the</span></span><br><span class=\"line\">        <span class=\"comment\">// C++ object is already instantiated.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Php::Object(<span class=\"string\">\"MyClass\"</span>, object);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method that returns 'this' to allow chaining ($x-&gt;chain()-&gt;chain()).</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return Php::Value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Php::<span class=\"function\">Value <span class=\"title\">chain</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// the Php::Value has an implicit constructor for Php::Base pointers.</span></span><br><span class=\"line\">        <span class=\"comment\">// This means that you can safely return 'this' from a method, which</span></span><br><span class=\"line\">        <span class=\"comment\">// will automatically be converted into a valid Php::Value object. This</span></span><br><span class=\"line\">        <span class=\"comment\">// works only for pointers to objects that already exist in PHP user</span></span><br><span class=\"line\">        <span class=\"comment\">// space.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Method that gets a MyClass instance as parameter</span></span><br><span class=\"line\"><span class=\"comment\">     *  @param  params      vector holding all parameters</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// store the first parameter in a Php::Value object</span></span><br><span class=\"line\">        Php::Value value = params[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// if you know for sure that the 'value' variable holds a (wrapped)</span></span><br><span class=\"line\">        <span class=\"comment\">// instance of a MyClass object, you can convert the value back into</span></span><br><span class=\"line\">        <span class=\"comment\">// a pointer to the original C++ object by calling the 'implementation'</span></span><br><span class=\"line\">        <span class=\"comment\">// method.</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// Note that this only works for value objects that hold instances of</span></span><br><span class=\"line\">        <span class=\"comment\">// C++ classes defined by your extension! Calling the 'implementation()'</span></span><br><span class=\"line\">        <span class=\"comment\">// method on a non-object, on an object of a user space class, or of</span></span><br><span class=\"line\">        <span class=\"comment\">// a core PHP class or a class from a different extension will probably</span></span><br><span class=\"line\">        <span class=\"comment\">// result in a crash!</span></span><br><span class=\"line\">        MyClass *object = (MyClass *)value.implementation();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p><code>Php::Value</code>类实现了<code>begin()</code>和<code>end()</code>方法，就像许多C++ STL容器一样。因此，你可以像遍历一个<code>std::map</code>类一样遍历一个<code>Php::Value</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Function that accepts an array as parameter</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param  array</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">(<span class=\"keyword\">const</span> Php::Value &amp;value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assum the value variable holds an array or object, it then</span></span><br><span class=\"line\">    <span class=\"comment\">// is possible to iterate over the values or properties</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;iter : value)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// output key and value</span></span><br><span class=\"line\">        Php::out &lt;&lt; iter.first &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; iter.second &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>迭代值是一个<code>std::pair&lt;Php::Value::Php::Value&gt;</code>。你可以访问它的属性’first’来获取当前的键，而属性’second’来获取当前的值。这和你在<code>std::map</code>上迭代的方式是一样的。</p>\n<p>你可以遍历所有持有对象或数组的<code>Php::Value</code>对象。当你在一个数组上迭代时，迭代器只是简单地迭代数组中的所有记录。</p>\n<p>对于对象来说，有一些东西需要考虑。如果你迭代的对象实现了<code>Iterator</code>或<code>IteratorAggregate</code>接口，C++迭代器就会使用这些内置的接口并调用它的方法来遍历对象。对于常规对象（那些没有实现<code>Iterator</code>或<code>IteratorAggregate</code>的对象），迭代器只是简单地迭代对象的所有公共属性。</p>\n<p>一个迭代器可以在两个方向上使用：操作符<code>++</code>以及操作符<code>--</code>都可以使用。但要注意使用<code>--</code>操作符。如果<code>Php::Value</code>对象持有一个实现了<code>Iterator</code>或<code>IteratorAggregate</code>的对象，反向迭代就无法进行，因为内部迭代器只有一个<code>next()</code>方法，PHP-CPP库没有办法指示内部迭代器向后移动。</p>\n<p>同时要注意<code>++</code>后缀操作符的返回值。通常情况下，后缀增量操作会返回操作前的原始值。当你在实现了 <code>Iterator</code> 或 <code>IteratorAggregate</code> 的对象上进行迭代时，情况就不同了，因为 PHP-CPP 库不可能复制一个 PHP 迭代器。因此，<code>++</code>后缀操作符（只有在<code>Iterator</code>或<code>IteratorAggregate</code>对象上使用时）会返回一个全新的迭代器，该迭代器回到对象的前部位置。但请记住，在C++和PHP（以及许多其他编程语言）中，使用<code>++</code>前缀操作符要明智得多，因为这不需要对原始对象进行复制，所以无论如何你都不应该使用<code>++</code>后缀操作符。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>当一个<code>Php::Value</code>对象持有一个可调用的对象时，你可以使用<code>（）</code>操作符来调用这个函数或方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a string with a function name</span></span><br><span class=\"line\">Php::Value date = <span class=\"string\">\"date\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"date\" is a built-in PHP function and thus can it be called</span></span><br><span class=\"line\">Php::out &lt;&lt; date(<span class=\"string\">\"Y-m-d H:i:s\"</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create a date-time object</span></span><br><span class=\"line\">Php::Object now = Php::Object(<span class=\"string\">\"DateTime\"</span>,<span class=\"string\">\"now\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create an array with two members, the datetime object</span></span><br><span class=\"line\"><span class=\"comment\">// and the name of a method</span></span><br><span class=\"line\">Php::<span class=\"function\">Array <span class=\"title\">array</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">array</span>[<span class=\"number\">0</span>] = now;</span><br><span class=\"line\"><span class=\"built_in\">array</span>[<span class=\"number\">1</span>] = <span class=\"string\">\"format\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// an array with two members can be called too, the first</span></span><br><span class=\"line\"><span class=\"comment\">// member is seen as the object, and the second as the</span></span><br><span class=\"line\"><span class=\"comment\">// name of the method</span></span><br><span class=\"line\">Php::out &lt;&lt; <span class=\"built_in\">array</span>(<span class=\"string\">\"Y-m-d H:i:s\"</span>) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>要读取或更新全局PHP变量，你可以使用<code>Php::GLOBALS</code>变量。这个变量的工作原理和PHP脚本中的<code>$GLOBALS</code>变量差不多。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// set a global PHP variable</span></span><br><span class=\"line\">Php::GLOBALS[<span class=\"string\">\"a\"</span>] = <span class=\"number\">12345</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// global variables can be of any type</span></span><br><span class=\"line\">Php::GLOBALS[<span class=\"string\">\"b\"</span>] = Php::Array(&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nested calls are (of course) supported</span></span><br><span class=\"line\">Php::GLOBALS[<span class=\"string\">\"b\"</span>][<span class=\"number\">4</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// and global variables can also be read</span></span><br><span class=\"line\">Php::out &lt;&lt; Php::GLOBALS[<span class=\"string\">\"b\"</span>] &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n<p>除了<code>$GLOBALS</code>变量之外，PHP还允许你使用<code>$_GET</code>、<code>$_POST</code>、<code>$_COOKIE</code>、<code>$_FILES</code>、<code>$_SERVER</code>、<code>$_REQUEST</code>和<code>$_ENV</code>变量来访问变量。在你的C++扩展中，你可以用全局变量<code>Php::GET</code>, <code>Php::POST</code>, <code>Php::COOKIE</code>, <code>Php::FILES</code>, <code>Php::SERVER</code>, <code>Php::REQUEST</code>和<code>Php::ENV</code>做类似的事情。这些都是全局的、只读的、具有重载操作符<code>[]</code>方法的对象。因此，你可以像访问关联数组一样访问它们。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// retrieve the value of a request variable</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> age = Php::REQUEST[<span class=\"string\">\"name\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or retrieve the value of a server variable</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> referer = Php::SERVER[<span class=\"string\">\"HTTP_REFERER\"</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"小心C-全局变量\"><a href=\"#小心C-全局变量\" class=\"headerlink\" title=\"小心C++全局变量\"></a>小心C++全局变量</h3><p>与PHP脚本不同的是，PHP脚本只能处理单个请求会话，而扩展则是用来处理多个请求会话。这意味着当你在扩展中使用全局C++(!)变量时，这些变量不会在会话之间被设置回初始值。然而，<code>Php::GLOBALS</code>变量总是在每个新的会话开始时重新初始化。</p>\n<h2 id=\"全局常量和类级常量\"><a href=\"#全局常量和类级常量\" class=\"headerlink\" title=\"全局常量和类级常量\"></a>全局常量和类级常量</h2><h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>在 PHP 脚本中可以定义常量（包括全局常量和类级常量）。这也可以通过 PHP-CPP 来实现。如果你想把常量暴露在用户空间的PHP代码中，你可以通过在<code>get_module()</code>调用中添加常量到<code>Php::Extension</code>对象中来实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add integer constants</span></span><br><span class=\"line\">myExtension.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_1\"</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">myExtension.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_2\"</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// floating point constants</span></span><br><span class=\"line\">myExtension.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_3\"</span>, <span class=\"number\">3.1415927</span>));</span><br><span class=\"line\">myExtension.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_4\"</span>, <span class=\"number\">4.932843</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// string constants</span></span><br><span class=\"line\">myExtension.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_5\"</span>, <span class=\"string\">\"This is a constant value\"</span>));</span><br><span class=\"line\">myExtension.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_6\"</span>, <span class=\"string\">\"Another constant value\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null constants</span></span><br><span class=\"line\">myExtension.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_7\"</span>, <span class=\"literal\">nullptr</span>));</span><br></pre></td></tr></table></figure>\n<p>在php中使用常量</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">echo</span>(MY_CONSTANT_1.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MY_CONSTANT_2.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MY_CONSTANT_3.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MY_CONSTANT_4.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MY_CONSTANT_5.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MY_CONSTANT_6.<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span>(MY_CONSTANT_7.<span class=\"string\">\"\\n\"</span>);</span><br></pre></td></tr></table></figure>\n<p>PHP也支持类级常量的概念。在内部，在Zend引擎中，类级常量被实现为常规的类成员，但是常量属性没有 “public “或 “private “标志，而是用 “constant “标志来标记。PHP-CPP也暴露了这一点。你可以用<code>Php::Const</code>标志来注册类属性。</p>\n<p>除此之外，一个<code>Php::Class</code>实例也有一个 “constant”方法，你可以将<code>Php::Constant</code>的实例添加到类中。从语义上看，这三种创建类级常量的方法都是相同的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  The C++ class that we're going to expose</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  (For this example we use a completely empty class, as only examples</span></span><br><span class=\"line\"><span class=\"comment\"> *  are given on how to use constants)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dummy</span> :</span> <span class=\"keyword\">public</span> Php::Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context so that the get_module() function can be</span></span><br><span class=\"line\"><span class=\"comment\"> *  called by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function for the extension</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create a class objects</span></span><br><span class=\"line\">        Php::Class&lt;Dummy&gt; dummy(<span class=\"string\">\"Dummy\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// there are many different ways to add constants, but semantically,</span></span><br><span class=\"line\">        <span class=\"comment\">// they're all the same</span></span><br><span class=\"line\">        dummy.property(<span class=\"string\">\"MY_CONSTANT_1\"</span>, <span class=\"number\">1</span>, Php::Const);</span><br><span class=\"line\">        dummy.property(<span class=\"string\">\"MY_CONSTANT_2\"</span>, <span class=\"string\">\"abcd\"</span>, Php::Const);</span><br><span class=\"line\">        dummy.constant(<span class=\"string\">\"MY_CONSTANT_3\"</span>, <span class=\"string\">\"xyz\"</span>);</span><br><span class=\"line\">        dummy.constant(<span class=\"string\">\"MY_CONSTANT_4\"</span>, <span class=\"number\">3.1415</span>);</span><br><span class=\"line\">        dummy.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_5\"</span>, <span class=\"string\">\"constant string\"</span>));</span><br><span class=\"line\">        dummy.add(Php::Constant(<span class=\"string\">\"MY_CONSTANT_5\"</span>, <span class=\"literal\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the class to the extension</span></span><br><span class=\"line\">        myExtension.add(<span class=\"built_in\">std</span>::move(dummy));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行时常量\"><a href=\"#运行时常量\" class=\"headerlink\" title=\"运行时常量\"></a>运行时常量</h3><p>如果你想在运行时从你的C++代码中找出一个用户空间常量的值，或者当你想找出一个常量是否被定义时，你可以简单地使用<code>Php::constant()</code>或<code>Php::defined()</code>函数。要在运行时定义常量，请使用<code>Php::define()</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Function that can be called from a PHP script</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">example_function</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// check if a certain user space constant is defined</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Php::defined(<span class=\"string\">\"USER_SPACE_CONSTANT\"</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// retrieve the value of a constant</span></span><br><span class=\"line\">        Php::Value constant = Php::constant(<span class=\"string\">\"ANOTHER_CONSTANT\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// define other constants at runtime</span></span><br><span class=\"line\">        Php::define(<span class=\"string\">\"DYNAMIC_CONSTANT\"</span>, <span class=\"number\">12345</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从php-ini读取配置\"><a href=\"#从php-ini读取配置\" class=\"headerlink\" title=\"从php.ini读取配置\"></a>从php.ini读取配置</h2><p>从php.ini文件中读取设置就像从普通PHP脚本中获取设置一样简单。在PHP脚本中，你可以使用内置的<code>ini_get()</code>函数从php.ini文件中读取设置，而在你的C++扩展中，你可以使用<code>Php::ini_get()</code>函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Simple function that is used to demonstrate how settings from the</span></span><br><span class=\"line\"><span class=\"comment\"> *  php.ini file can be read</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// read in the \"output_buffering\" variable from the php.ini file</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> output_buffering = Php::ini_get(<span class=\"string\">\"output_buffering\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// read in the \"variables_order\" variable</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> variables_order = Php::ini_get(<span class=\"string\">\"variables_order\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Php::ini_get()</code>函数返回一个可以分配给字符串、整数和浮点数的对象。在上面的例子中，我们使用这个函数将设置直接分配给一个整数和一个<code>std::string</code>。</p>\n<p>你只能从php.ini中获取预定义的变量。因此不可能用随机字符串调用<code>Php::ini_get()</code>. 如果你想使用你自己的变量，你必须先在get_module()函数中注册它们，然后才能调用<code>Php::ini_get()</code>来获取当前值。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Simple function that is used to demonstrate how settings from the</span></span><br><span class=\"line\"><span class=\"comment\"> *  php.ini file can be read</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// read in a variable defined for this extension</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> var1 = Php::ini_get(<span class=\"string\">\"my_extension.var1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// read in a string variable</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> var2 = Php::ini_get(<span class=\"string\">\"my_extension.var2\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C contect so that the get_module() function can be</span></span><br><span class=\"line\"><span class=\"comment\"> *  called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  The get_module() startup function</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// create extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// export one function</span></span><br><span class=\"line\">        extension.add(<span class=\"string\">\"myFunction\"</span>, myFunction);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// tell the PHP engine that the php.ini variables my_extension.var1</span></span><br><span class=\"line\">        <span class=\"comment\">// and my_extension.var2 are usable</span></span><br><span class=\"line\">        extension.add(Php::Ini(<span class=\"string\">\"my_extension.var1\"</span>, <span class=\"string\">\"default-value\"</span>));</span><br><span class=\"line\">        extension.add(Php::Ini(<span class=\"string\">\"my_extension.var2\"</span>, <span class=\"number\">12345</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return a pointer to the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"扩展回调函数\"><a href=\"#扩展回调函数\" class=\"headerlink\" title=\"扩展回调函数\"></a>扩展回调函数</h2><p><code>get_module()</code>函数在你的扩展启动时被调用。它返回一个内存地址，在那里Zend引擎可以找到关于你的扩展的所有相关信息。</p>\n<p>在这个<code>get_module()</code>的调用之后，你的扩展就会被加载，并将被用来处理多个请求会话。这是标准PHP脚本和本地扩展之间的一个重要区别，因为标准PHP脚本只处理单个请求。但扩展服务于多个请求后。</p>\n<p>如果你使用全局的C++变量，这种区别就显得尤为重要。这样的全局变量会在扩展加载时被初始化（而不是在每个请求开始时）。你对全局变量所做的更改会保留它们的值，因此后续的请求会看到更新后的值。</p>\n<p>顺便说一下，这只发生在本地变量上。存储在<code>Php::GLOBALS</code>对象中的全局PHP变量，会在每次请求开始时重新初始化。你不必担心你对全局PHP变量所做的修改：在下一个请求开始时，<code>Php::GLOBALS</code>对象是全新的，你在上一个请求中所做的修改不再可见。</p>\n<p>回到全局的C++变量。如果你想在一个新的请求开始时重置一个全局变量，你可以注册一个特殊的回调函数，这个函数在每个请求前被调用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Global variable that stores the number of times</span></span><br><span class=\"line\"><span class=\"comment\"> *  the function updateCounters() has been called in total</span></span><br><span class=\"line\"><span class=\"comment\"> *  @var    int</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> invokeTotalCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Global variable that keeps track how many times the</span></span><br><span class=\"line\"><span class=\"comment\"> *  function updateCounters() was called during the</span></span><br><span class=\"line\"><span class=\"comment\"> *  current request</span></span><br><span class=\"line\"><span class=\"comment\"> *  @var    int</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> invokeDuringRequestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Native function that is callable from PHP</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  This function updates a number of global variables that count</span></span><br><span class=\"line\"><span class=\"comment\"> *  the number of times a function was called</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateCounters</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// increment global counters</span></span><br><span class=\"line\">    invokeTotalCount++;</span><br><span class=\"line\">    invokeDuringRequestCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Switch to C context, because the Zend engine expects get get_module()</span></span><br><span class=\"line\"><span class=\"comment\"> *  to have a C style function signature</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *  Startup function that is automatically called by the Zend engine</span></span><br><span class=\"line\"><span class=\"comment\">     *  when PHP starts, and that should return the extension details</span></span><br><span class=\"line\"><span class=\"comment\">     *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">extension</span><span class=\"params\">(<span class=\"string\">\"my_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// install a callback that is called at the beginning</span></span><br><span class=\"line\">        <span class=\"comment\">// of each request</span></span><br><span class=\"line\">        extension.onRequest([]() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// re-initialize the counter</span></span><br><span class=\"line\">            invokeDuringRequestCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// add the updateCounter method to the extension</span></span><br><span class=\"line\">        extension.add(<span class=\"string\">\"updateCounters\"</span>, updateCounters);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension details</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Php::Extension</code>类有一个方法<code>onRequest()</code>，在上面的例子中用来注册一个回调函数。这个回调会在每个请求之前被调用。正如你所看到的，它是允许使用C++ lambda函数的。</p>\n<p><code>onRequest()</code>并不是<code>Php::Extension</code>对象中唯一可以注册回调的方法。事实上，有四种不同的<code>on*()</code>方法可以使用。</p>\n<ul>\n<li>void onStartup(const std::function&lt;void()&gt; &amp;callback);</li>\n<li>void onRequest(const std::function&lt;void()&gt; &amp;callback);</li>\n<li>void onIdle(const std::function&lt;void()&gt; &amp;callback);</li>\n<li>void onShutdown(const std::function&lt;void()&gt; &amp;callback);</li>\n</ul>\n<p>当Zend引擎已经加载了你的扩展，并且其中的所有函数和类都被注册时，启动回调被调用。如果你想在函数被调用之前初始化扩展中的其他变量，你可以使用onStartup()函数并注册一个回调来运行这个初始化代码。</p>\n<p>Zend引擎初始化后，就可以处理请求了。在上面的例子中，我们使用了onRequest()方法来注册一个回调，这个回调会在每个请求前被调用。除此之外，你还可以安装一个回调，当Zend引擎进入空闲状态时，这个回调会在每次请求后被调用。</p>\n<p>等待下一个请求。这可以通过Php::Extension对象中的onIdle()方法来实现。</p>\n<p>第四个可以注册的回调是在PHP关闭前被调用的回调。如果有什么需要清理的地方，可以安装这样的回调，并从中运行清理代码。</p>\n<h3 id=\"预先fork的Web引擎-如Apache\"><a href=\"#预先fork的Web引擎-如Apache\" class=\"headerlink\" title=\"预先fork的Web引擎 (如Apache)\"></a>预先fork的Web引擎 (如Apache)</h3><p>如果你在一个<code>pre-forked</code>的web服务器（比如Apache）上运行PHP，你的扩展会在各种工作进程被fork之前被加载和初始化。这样做的后果是，<code>get_module()</code>函数和你可选的<code>onStartup()</code>回调函数被父进程调用，而所有其他回调和实际的页面处理被子进程调用。因此，对<code>getpid()</code>的调用(或其他用于检索当前进程信息的函数)将在<code>onStartup</code>回调中返回其他东西，就像在其他扩展函数中一样。</p>\n<p>你可能要因此而小心。最好不要在启动函数中做一些在进程fork成不同子进程时可能无法工作的事情（比如打开文件描述符）。还有一点需要注意的是，启动函数只在Apache启动（或重载，见后文）时被父进程调用，而关闭函数则被每个平滑退出的子进程调用。因此，<code>onShutdown</code>不仅在Apache进程停止时被调用，而且在其中一个工作进程因为不再需要而退出时，或者因为它被一个新的工作进程取代而被调用。</p>\n<p><code>get_module()</code>函数在你的扩展被初始化时被调用。但不仅如此。当apache被重载时(例如通过给命令行指令 “apachectl reload”)，你的<code>get_module()</code>会被第二次调用，你在<code>Extension::onStartup()</code>中注册的回调也会被再次调用。这通常不是问题，因为在第一次调用<code>get_module()</code>后，静态扩展对象处于锁定状态，在第二次调用<code>get_module()</code>时，你试图添加到扩展对象中的函数和类会被直接忽略。</p>\n<h3 id=\"注意多线程\"><a href=\"#注意多线程\" class=\"headerlink\" title=\"注意多线程\"></a>注意多线程</h3><p>如果你的扩展运行在多线程的PHP安装模式上，你需要格外小心。大多数PHP安装模式（Apache、CLI脚本等）一次只服务一个请求，按顺序进行。然而，有一些PHP安装模式使用了多线程，并且可以并行处理多个请求。如果你的扩展在这样的环境中运行，你应该知道你的全局（和静态）变量也可以被多个线程同时访问。使用<code>std::mutex</code>或<code>std::atomic</code>等技术来防止数据竞态条件和冲突是你自己的责任。</p>\n<p>如果你的扩展是为多线程环境编译的，PHP-CPP头文件定义了宏<code>ZTS</code>。你可以使用这个宏来检查是否需要创建特殊的代码来处理线程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;phpcpp.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Global variable that store the number of times</span></span><br><span class=\"line\"><span class=\"comment\"> *  the function updateCounters() has been called in total</span></span><br><span class=\"line\"><span class=\"comment\"> *  @var    int</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> invokeTotalCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ZTS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Mutex so that the 'invokeTotalCount' variable is only accessed</span></span><br><span class=\"line\"><span class=\"comment\"> *  by one process at a time</span></span><br><span class=\"line\"><span class=\"comment\"> *  @var    std::mutex</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex invokeTotalMutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  Native function that is callable from PHP</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  This function updates a number of global variables that count</span></span><br><span class=\"line\"><span class=\"comment\"> *  the number of times a function was called</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateCounters</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ZTS</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lock the mutex</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::unique_lock&lt;<span class=\"built_in\">std</span>::mutex&gt; lock(invokeTotalMutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increment counters</span></span><br><span class=\"line\">    invokeTotalCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另一个重要的事情是，PHP内部也做了这种锁定。如果你从你的C++代码中调用一个PHP函数（比如<code>Php::Value(&quot;myFunction&quot;)()</code>），或者当你访问<code>Php::GLOBALS</code>数组中的一个PHP变量（或者其他超级全局变量之一）时，PHP必须锁定一些东西以确保没有其他线程同时访问相同的信息。这些操作可能很昂贵。</p>\n<p>因此，用 PHP-CPP 编写本地扩展的良好经验：</p>\n<ul>\n<li>不要使用全局变量</li>\n<li>只调用其他本地函数，不要回调到PHP中。</li>\n</ul>\n<p>这些规则并不像它们看起来那样具有局限性。全局变量的使用并不被认为是优秀的软件设计，所以你可能根本就没有使用它们，你之所以要写一个本地扩展，首先是因为你想摆脱PHP。从你的扩展代码中调用（慢的）PHP函数，无论如何都应该被阻止。</p>\n<h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>尽管在 PHP 脚本中，命名空间有非常丰富的实现方式，有特殊的关键字，如 <code>use</code> 和 <code>namespace</code> 以及特殊的常量，如 <code>__NAMESPACE__</code>，但它们内部非常简单。</p>\n<p>命名空间无非就是一个类或函数的前缀。如果你想让你的类或函数出现在一个特定的命名空间中，你只需要在类或函数名中添加一个前缀。下面的代码在 “myNamespace”命名空间中创建了一个函数 “myFunction”。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add the myFunction function to the extension, </span></span><br><span class=\"line\"><span class=\"comment\">// and put it in namespace \"myNamespace\"</span></span><br><span class=\"line\">extension.add(<span class=\"string\">\"myNamespace\\\\myFunction\"</span>, myFunction);</span><br></pre></td></tr></table></figure>\n<p>如果你愿意，你可以使用<code>Php::Namespace</code>实用类来实现。这个类的签名和<code>Php::Extension</code>类完全一样，你也可以用它来注册类和函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a namespace</span></span><br><span class=\"line\">Php::<span class=\"function\">Namespace <span class=\"title\">myNamespace</span><span class=\"params\">(<span class=\"string\">\"myNamespace\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add the myFunction function to the namespace</span></span><br><span class=\"line\">myNamespace.add(<span class=\"string\">\"myFunction\"</span>, myFunction);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @todo add more functions and classes to the namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create a nested namespace</span></span><br><span class=\"line\">Php::<span class=\"function\">Namespace <span class=\"title\">nestedNamespace</span><span class=\"params\">(<span class=\"string\">\"nestedNamespace\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// @todo add functions and classes to the nested namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add the nested namespace to the first namespace</span></span><br><span class=\"line\">myNamespace.add(<span class=\"built_in\">std</span>::move(nestedNamespace));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add the namespace to the extension</span></span><br><span class=\"line\">extension.add(<span class=\"built_in\">std</span>::move(myNamespace));</span><br></pre></td></tr></table></figure>\n<p><code>Php::Namespace</code>类只是一个容器，它会自动为你添加的所有类和函数添加一个前缀。正如你在例子中看到的那样，嵌套命名空间也是可能的。</p>\n<p>在这个例子中，我们使用std::move()函数将嵌套的命名空间移动到父命名空间中，并将第一个命名空间移动到扩展中。移动比添加更有效率，尽管常规的<code>extension.add(myNamespace)</code>也是有效的。</p>\n<h2 id=\"动态加载扩展\"><a href=\"#动态加载扩展\" class=\"headerlink\" title=\"动态加载扩展\"></a>动态加载扩展</h2><p>从PHP转到C++的用户经常会问，如果用C++代码代替PHP代码，是否会增加系统管理的难度。我们必须在这里说实话：使用PHP比使用C++更容易。例如，要激活一个PHP脚本，你不需要root权限，你可以简单地复制脚本到Web服务器。部署原生C++扩展需要更多的工作：你需要先停止Web服务器，编译扩展，安装，然后重新启动Web服务器。</p>\n<p>除此之外，当一个扩展被部署后，它将立即对所有托管在Web服务器上的网站进行激活。一个已部署的PHP脚本只改变了单个网站的行为，但一个已部署的C++扩展会影响所有网站。其实不可能只为特定的网站激活一个扩展，也不可能只为一个网站测试一个新版本的扩展，因为扩展是由所有PHP进程共享的。如果你真的想在不同的网站上使用不同的扩展，你需要多个服务器，都有自己的配置。</p>\n<p>或者你可以使用动态加载。</p>\n<p>PHP有一个内置的<code>dl()</code>函数，你可以用它来加载扩展。这允许你从PHP脚本中调用<code>dl(&quot;myextension.so&quot;)</code>函数来加载一个扩展，这样一个扩展只适用于一个特定的站点。出于安全考虑，这个内置的<code>dl()</code>函数有一些限制(否则会允许用户运行任意的本地代码)，但如果只有你一个人负责一个系统，或者当一个服务器不是由多个组织共享时，你可以使用PHP-CPP创建一个类似于<code>dl()</code>的函数，但没有这个限制。</p>\n<h3 id=\"为什么dl-会受到限制？\"><a href=\"#为什么dl-会受到限制？\" class=\"headerlink\" title=\"为什么dl()会受到限制？\"></a>为什么dl()会受到限制？</h3><p>由于安全问题，<code>dl()</code>函数受到限制。当你使用<code>dl()</code>时，只能加载存储在系统范围扩展目录中的扩展，而不能用于加载用户放在其他位置的扩展。因此，调用 dl(“/home/user/myextension.so”)会失败，因为”/home/user “不是官方的扩展目录。为什么会有这种限制？</p>\n<p>要理解这一点，首先必须认识到，在正常的PHP安装中，PHP脚本是由没有root权限的用户编辑的。在共享主机环境下，不同的用户都在同一个系统上运行自己的网站。在这样的设置中，如果一个用户可以编写一个可以访问他人数据的脚本或程序，那是绝对不行的。然而，如果使用一个不受限制的<code>dl()</code>函数，恰恰可以做到这一点。一个不受限制的 <code>dl()</code> 调用将允许 PHP 程序员编写一个本地扩展，将其存储在他们的主目录或 /tmp 目录中，并由 webserver 进程加载。然后，他们可以执行任意代码，并可能在其他人的网站内安装记录器或其他恶意代码。<strong>通过只允许从系统范围内的扩展目录中加载扩展，PHP 保证了每一个动态加载的扩展必须至少由系统管理员安装</strong>。</p>\n<p>然而，当你写你自己的扩展时（无论是直接在Zend API之上，还是通过使用PHP-CPP库）你已经可以写和执行任意代码了。这里不需要安检。从你的C/C++代码中，你可以做任何你想做的事情。如果你能根据网站的要求动态加载一个扩展，那不是很酷吗？一个网站需要稳定，并加载你的扩展测试良好的1.0版本，而第二个网站更多的是实验性的，并加载2.0版本。你可能在同一台机器上运行两个版本的扩展。</p>\n<h3 id=\"Thin-loader-extension\"><a href=\"#Thin-loader-extension\" class=\"headerlink\" title=\"Thin loader extension\"></a>Thin loader extension</h3><p>想象一下，你正在编写你自己的扩展 “MyExtension”，它有许多不同的类和功能，而且你计划一直为它推出新的版本。你不希望以 “大爆炸 “的方式部署新版本，而是希望慢慢地推出新版本，一次一个客户或一个网站。你会怎么做？</p>\n<p>你首先要开发一个瘦加载器扩展：ExtensionLoader扩展。这个扩展只有一个函数：<code>enable_my_extension()</code>，它接收你的实际扩展的版本号，并动态地加载你的扩展的那个版本。这是一个简单的扩展（它只有一个功能），你可以在全球范围内安装，而且你可能永远不会有更新。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Function to load an extension by its version number</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  It takes one argument: the version number of your extension,</span></span><br><span class=\"line\"><span class=\"comment\">    *  and returns a boolean to indicate whether the extension was </span></span><br><span class=\"line\"><span class=\"comment\">    *  correctly loaded.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  @param  params      Vector of parameters</span></span><br><span class=\"line\"><span class=\"comment\">    *  @return boolean</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">enable_my_extension</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// get version number</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> version = params[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// construct pathname to your extension (this is for example</span></span><br><span class=\"line\">    <span class=\"comment\">// /path/to/MyExtension.so.1 or /path/to/MyExtension.so.2)</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> path = <span class=\"string\">\"/path/to/MyExtension.so.\"</span> + <span class=\"built_in\">std</span>::to_string(version);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// load the extension</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Php::dl(path);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\">    *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">        *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">        *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static instance of the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"ExtensionLoader\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the extension has one method</span></span><br><span class=\"line\">        myExtension.add(<span class=\"string\">\"enable_my_extension\"</span>, enable_my_extension, &#123;</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"version\"</span>, Php::Type::Numeric)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码保存了ExtensionLoader扩展的全部源代码。你可以在你的系统上安装这个扩展，把它复制到全局php扩展目录下并更新<code>php.ini</code>文件。</p>\n<p>当你安装了这个thin loader扩展之后，你就可以用类和函数写满你的实际大扩展，并将这个扩展编译成*.so文件：第一个版本你编译成MyExtension.so.1，以后的版本编译成MyExtension.so.2、MyExtension.so.3等。对于每一个新的版本，你都会引入一个新的版本号，并将这些共享对象复制到/path/to目录下（与上面显示的”ExtensionLoader”扩展中的路径相同）。虽然这不是官方的PHP扩展目录，但是这些扩展可以通过enable_my_extension()函数加载。</p>\n<p>你不需要将扩展程序复制到PHP扩展目录中，也不需要更新php.ini配置。要激活一个扩展，你只需要调用引入的enable_my_extension()函数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// enable version 2 of the extension (this will load MyExtension.so.2)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!enable_my_extension(<span class=\"number\">2</span>)) <span class=\"keyword\">die</span>(<span class=\"string\">\"Version 2 of extension is missing\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// from now on we can use classes and functions from version 2 of the extension</span></span><br><span class=\"line\">$object = <span class=\"keyword\">new</span> ClassFromMyExtension();</span><br><span class=\"line\">$object-&gt;methodFromMyExtension();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// you get the idea...</span></span><br></pre></td></tr></table></figure>\n<p>上面我们展示的ExtensionLoader还是很安全的。不能运行任意代码，也不能打开任意*.so文件。最糟糕的事情是有人用错误的版本号打开了一个扩展。</p>\n<p>但如果你真的信任你系统上的用户，你可以很容易地调整thin loader扩展来允许其他类型的参数。在最开放的情况下，你甚至可以写一个函数，让用户从字面上打开所有可能的共享对象文件。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Function to load every possible extension by pathname</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  It takes one argument: the filename of the PHP extension, and returns a </span></span><br><span class=\"line\"><span class=\"comment\">    *  boolean to indicate whether the extension was correctly loaded.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  This function goes further than the original PHP dl() fuction, because</span></span><br><span class=\"line\"><span class=\"comment\">    *  it does not check whether the passed in extension object is stored in the</span></span><br><span class=\"line\"><span class=\"comment\">    *  right directory. Literally every possible extension, also local ones </span></span><br><span class=\"line\"><span class=\"comment\">    *  created by end users, can be loaded.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  @param  params      Vector of parameters</span></span><br><span class=\"line\"><span class=\"comment\">    *  @return boolean</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">dl_unrestricted</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// get extension name</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> pathname = params[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// load the extension</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Php::dl(pathname);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\">    *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">        *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">        *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static instance of the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"load_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the extension has one method</span></span><br><span class=\"line\">        myExtension.add(<span class=\"string\">\"dl_unrestricted\"</span>, dl_unrestricted, &#123;</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"pathname\"</span>, Php::Type::String)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码将允许PHP脚本动态加载PHP扩展，无论它们存储在系统的哪个位置。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// load the C++ extension stored in the same directory as this file</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!dl_unrestricted(<span class=\"keyword\">__DIR__</span>.<span class=\"string\">'/MyExtension.so'</span>)) <span class=\"keyword\">die</span>(<span class=\"string\">\"Extension could not be loaded\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// from now on we can use classes and functions from the extension</span></span><br><span class=\"line\">$object = <span class=\"keyword\">new</span> ClassFromMyExtension();</span><br><span class=\"line\">$object-&gt;methodFromMyExtension();</span><br></pre></td></tr></table></figure>\n<p><code>dl_unrestricted()</code>函数是一个很厉害的函数，但这里要注意：如果你是共享主机平台的管理员，你绝对不要安装它!</p>\n<h3 id=\"Persistent-extensions\"><a href=\"#Persistent-extensions\" class=\"headerlink\" title=\"Persistent extensions\"></a>Persistent extensions</h3><p>动态加载的扩展会在请求结束时自动卸载。如果后续的请求也动态加载相同的扩展，那么它将以一个全新的环境开始。如果你想写一个使用静态数据或静态资源的扩展（比如一个持久的数据库连接，或者一个处理任务的工作线程），这不一定是你想要的行为。你要保持数据库连接的活跃性，或者线程的运行，也是在扩展被卸载之后。</p>\n<p>为了克服这个问题，<code>Php::dl()</code>函数附带了第二个布尔参数，你可以用它来指定你是想持久地加载扩展，还是只为那个特定的请求加载。</p>\n<p>请注意，如果你把这个参数设置为true，唯一持久化的就是扩展中的数据。在后续的请求中，你仍然需要加载扩展来激活其中的函数和类，即使你已经在之前的请求中持续加载了扩展。但由于之前已经加载了扩展，所以其中的静态数据（如数据库连接或线程）会被保存下来。</p>\n<p>我们上面演示的<code>dl_unrestricted()</code>函数可以被修改为包含这个持久参数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Function to load every possible extension by pathname</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  It takes two arguments: the filename of the PHP extension, and a boolean to</span></span><br><span class=\"line\"><span class=\"comment\">    *  specify whether the extension data should be kept in memory. It returns a </span></span><br><span class=\"line\"><span class=\"comment\">    *  boolean to indicate whether the extension was correctly loaded.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  This function goes further than the original PHP dl() fuction, because</span></span><br><span class=\"line\"><span class=\"comment\">    *  it does not check whether the passed in extension object is stored in the</span></span><br><span class=\"line\"><span class=\"comment\">    *  right directory, and because it allows persistent loading of extensions. </span></span><br><span class=\"line\"><span class=\"comment\">    *  Literally every possible extension, also local ones created by end users, </span></span><br><span class=\"line\"><span class=\"comment\">    *  can be loaded.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  @param  params      Vector of parameters</span></span><br><span class=\"line\"><span class=\"comment\">    *  @return boolean</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">Php::<span class=\"function\">Value <span class=\"title\">dl_unrestricted</span><span class=\"params\">(Php::Parameters &amp;params)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// get extension name</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> pathname = params[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// persistent setting</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> persistent = params.size() &gt; <span class=\"number\">1</span> ? params[<span class=\"number\">1</span>].boolValue() : <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// load the extension</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Php::dl(pathname, persistent);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Switch to C context to ensure that the get_module() function</span></span><br><span class=\"line\"><span class=\"comment\">    *  is callable by C programs (which the Zend engine is)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        *  Startup function that is called by the Zend engine </span></span><br><span class=\"line\"><span class=\"comment\">        *  to retrieve all information about the extension</span></span><br><span class=\"line\"><span class=\"comment\">        *  @return void*</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\">PHPCPP_EXPORT <span class=\"keyword\">void</span> *<span class=\"title\">get_module</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// create static instance of the extension object</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> Php::<span class=\"function\">Extension <span class=\"title\">myExtension</span><span class=\"params\">(<span class=\"string\">\"load_extension\"</span>, <span class=\"string\">\"1.0\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// the extension has one method</span></span><br><span class=\"line\">        myExtension.add(<span class=\"string\">\"dl_unrestricted\"</span>, dl_unrestricted, &#123;</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"pathname\"</span>, Php::Type::String),</span><br><span class=\"line\">            Php::ByVal(<span class=\"string\">\"persistent\"</span>, Php::Type::Bool, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// return the extension</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> myExtension;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而这个扩展允许我们动态加载扩展，同时保留扩展内部的持久化数据。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// load the C++ extension stored in the same directory as this file, the</span></span><br><span class=\"line\"><span class=\"comment\">// extension is persistently loaded, so it may use persistent data like</span></span><br><span class=\"line\"><span class=\"comment\">// database connections and so on.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!dl_unrestricted(<span class=\"keyword\">__DIR__</span>.<span class=\"string\">'/MyExtension.so'</span>, <span class=\"keyword\">true</span>)) <span class=\"keyword\">die</span>(<span class=\"string\">\"Extension could not be loaded\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// from now on we can use classes and functions from the extension</span></span><br><span class=\"line\">$object = <span class=\"keyword\">new</span> ClassFromMyExtension();</span><br><span class=\"line\">$object-&gt;methodFromMyExtension();</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"php-cpp.com\">php-cpp</a></li>\n</ol>\n","categories":["技术"],"tags":["PHP","C/C++"]},{"title":"如何在impala-shell之外使用特定用户set变量","url":"/2020/05/20/%E5%A6%82%E4%BD%95%E5%9C%A8impala-shell%E4%B9%8B%E5%A4%96%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9Aset%E5%8F%98%E9%87%8F/","content":"<h2 id=\"版本信息\"><a href=\"#版本信息\" class=\"headerlink\" title=\"版本信息\"></a>版本信息</h2><ul>\n<li>impalad 2.5.0-cdh5.7.*</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>通过查阅<a href=\"https://docs.cloudera.com/documentation/enterprise/5-7-x/topics/impala_set.html#set\" target=\"_blank\" rel=\"noopener\">官网</a>可以知道，用户特定变量无法在除<code>impala-shell</code>外使用，这对使用odbc、jdbc或thrift的客户端来说，SQL维护会造成很大困扰 —— 在长SQL中改变一个或多个条件的值</p>\n<a id=\"more\"></a>\n<p>在impala-shell中，可以通过<code>set</code>语句或<code>--var</code>参数设置会话上下文中的变量，如下</p>\n<h3 id=\"使用set\"><a href=\"#使用set\" class=\"headerlink\" title=\"使用set\"></a>使用set</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[localhost:21000] &gt; <span class=\"built_in\">set</span> var:table_name=production_table;</span><br><span class=\"line\">[localhost:21000] &gt; <span class=\"built_in\">set</span> var:cutoff=3;</span><br><span class=\"line\">[localhost:21000] &gt; select s from <span class=\"variable\">$&#123;var:table_name&#125;</span> order by s <span class=\"built_in\">limit</span> <span class=\"variable\">$&#123;var:cutoff&#125;</span>;</span><br><span class=\"line\">Query: select s from production_table order by s <span class=\"built_in\">limit</span> 3</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用–var\"><a href=\"#使用–var\" class=\"headerlink\" title=\"使用–var\"></a>使用–var</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ impala-shell --var=table_name=staging_table --var=cutoff=2</span><br><span class=\"line\">[localhost:21000] &gt; select s from <span class=\"variable\">$&#123;var:table_name&#125;</span> order by s <span class=\"built_in\">limit</span> <span class=\"variable\">$&#123;var:cutoff&#125;</span>;</span><br><span class=\"line\">Query: select s from staging_table order by s <span class=\"built_in\">limit</span> 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"模拟impala-shell：通过程序替换\"><a href=\"#模拟impala-shell：通过程序替换\" class=\"headerlink\" title=\"模拟impala-shell：通过程序替换\"></a>模拟impala-shell：通过程序替换</h2><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">var</span>:table_name=production_table;</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">var</span>:cutoff=<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> s <span class=\"keyword\">from</span> $&#123;<span class=\"keyword\">var</span>:table_name&#125; <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> s <span class=\"keyword\">limit</span> $&#123;<span class=\"keyword\">var</span>:cutoff&#125;;</span><br></pre></td></tr></table></figure>\n<p>有以上sql，</p>\n<ol>\n<li>通过正则表达式抽出<code>set语句</code></li>\n<li>替换到由<code>${}</code>包裹的变量名</li>\n<li>使用odbc/jdbc/thrift执行替换变量后的sql</li>\n</ol>\n","categories":["技术"],"tags":["PHP","impala"]},{"title":"ImpalaODBC StringColumnLength导致的乱码问题","url":"/2018/07/02/%E6%8E%A2%E7%B4%A2ImpalaODBC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E6%9C%80%E5%A4%A7%E5%AD%97%E7%AC%A6%E6%95%B0%E9%99%90%E5%88%B6%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A2%AB%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98/","content":"<h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3><ul>\n<li>mhue:自研的类似hue的hadoop查询系统</li>\n</ul>\n<h3 id=\"这个字段有点大\"><a href=\"#这个字段有点大\" class=\"headerlink\" title=\"这个字段有点大\"></a>这个字段有点大</h3><p>有一个新表，记录游戏前端发来的appdata数据，这个appdata就是本次问题的主角，存储的是玩家手机里所有应用的安装信息（应用名称、安装时间等等）。在这里，刚开始我很惊讶，为什么这些数据如此容易就能获得，直觉告诉我，这些信息非常敏感。后来才知道，原来也是需要授权的，高版本的安卓系统更难获得，而苹果手机就不用想了。了解后才知道，原来这些数据是用来做机器学习的，或许能够通过这些数据，推测出玩家的兴趣、性格等等？看起来似乎有一定的研究价值。不过，这里有一个问题，就是这个app_data实在是太“大”了，一个字段就占了几K到几十K不止（目前的实际数据，最大约47K），而且，随着玩家手机里面的应用增加而增加，也就是说，有可能会更多。这些信息都使用json格式发送到数据库中。</p>\n<a id=\"more\"></a>\n<h3 id=\"乱码排查开始\"><a href=\"#乱码排查开始\" class=\"headerlink\" title=\"乱码排查开始\"></a>乱码排查开始</h3><p>前面说的乱码问题，正是这个表的appdata数据导致的，其他数据表不会出现这个问题。一开始报错的提示非常奇怪，第一，在mhue中直接查询并展示数据，appdata字段呈现“抖动”情况（整个页面都不太正常），后来才知道，这个数据太大了，页面要正常显示出来非常难，Element官方估计也会表示无奈= =。其次，直接点击页面上的“下载”按钮下载数据后，数据是乱码的。以前我有探讨过乱码产生的原因，无非是字符集对不上了，于是我把impala odbc取到的数据拿出来，看看是不是UTF8编码。果然不是！打印出来的结果是CP936，这是GBK的编码吧，于是我很高兴的说，这是编码的问题，看看是不是建表有误。但是，得到的回答并非如此，建库建表有非常完善的流程，基本不会出现编码的问题，都是统一的。</p>\n<h3 id=\"PHP缓冲区满导致的字段被截断\"><a href=\"#PHP缓冲区满导致的字段被截断\" class=\"headerlink\" title=\"PHP缓冲区满导致的字段被截断\"></a>PHP缓冲区满导致的字段被截断</h3><p>既然不是编码问题，也就是说，拿到数据后，这个字符串就是不完整的，而我是在PHP层检测编码的，那是不是说，PHP拿到impala odbc的数据时，并没有拿到完整的数据呢？为了印证我的想法，我把缓冲区变为无限制，默认的output buffer是4096个字符，再看看发现并没有用。其实细想之下，缓冲区只是一个“缓冲带”，解决不同设备的读写速度差异问题，只要及时把缓冲区写到内存，根本不会出现这种问题。而稳定重现乱码问题，说明操作系统调度没有问题，没有阻塞写内存的操作。接着看</p>\n<h3 id=\"odbc-longreadlen太短，导致字符串被截断\"><a href=\"#odbc-longreadlen太短，导致字符串被截断\" class=\"headerlink\" title=\"odbc longreadlen太短，导致字符串被截断\"></a>odbc longreadlen太短，导致字符串被截断</h3><p>翻查php odbc的文档可以发现一个配置，longreadlen，这个配置决定了每一行数据中字段的最大长度，咋一看应该是它了，而且文档说明，设置为0的时候，长字段限制将会去掉。设为0试试看，发现还是没有用。</p>\n<h3 id=\"impala-odbc-StringColumnLength太短，导致字符串被截断\"><a href=\"#impala-odbc-StringColumnLength太短，导致字符串被截断\" class=\"headerlink\" title=\"impala odbc StringColumnLength太短，导致字符串被截断\"></a>impala odbc StringColumnLength太短，导致字符串被截断</h3><p>既然PHP层的配置没有起效，那么还可能是别的模块出现了错误，由于mhue的查询使用的是impala odbc连接hadoop进行查询的，所以有可能是这里的问题。查一下odbc.ini，发现确实有一个这样的字段，StringColumnLength，这个字段和longreadlen的意思相近，不过没有0这种无限制的选项。按理说，字符串限制最大应该可以去到2G，我尝试改大一点，就1M吧，1024x1024，删掉原来的32767。再试试看，发现还是没有用，下载的长度只有40k左右，而实际大小为47k。</p>\n<h3 id=\"impala-odbc-StringColumnLength最大限制为32k，导致字符串被截断\"><a href=\"#impala-odbc-StringColumnLength最大限制为32k，导致字符串被截断\" class=\"headerlink\" title=\"impala odbc StringColumnLength最大限制为32k，导致字符串被截断\"></a>impala odbc StringColumnLength最大限制为32k，导致字符串被截断</h3><p>查阅了国外的一些帖子，看到有个开发者似乎很有权威，难道是官方开发者？先不管了，看看说了什么，他说，这个StringColumnLength是一个max limit，最大就是32k，当然根据操作系统位数、内存等因素决定，可能会大一点，但是呢，这个32k在性能考虑下，是一个最佳配置…..怪不得我改了没有用，估计代码里面写死了。给出的建议是，更改数据类型为varchar，并配置字符数长度。这样的建议并不适合于我们的需求，好吧，既然如此，那就不改了。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>既然这个库有限制，可以联想到，其他库也会做相应的限制，而app_data字段是无限制的，这样搞肯定是不合理。那么如何优化呢？针对这个需求，可以有三个方案：</p>\n<ol>\n<li>给与权限，让客户端直接连接hadoop取数据。</li>\n<li>另外建库，订阅数据，给与权限。</li>\n<li>分库，把appdata数据分包发，不要一次性发一个很大的数据包，通过roleid等字段映射数据包</li>\n</ol>\n<p>方案一权限可能会很大，毕竟一不小心来个drop database and rm -rf /咋办？这个东西需要斟酌一下。</p>\n<p>方案二建个库给你订阅一份数据问题也不大，看成本。再者，机器学习那边如何能够更有效率的拿到数据做分析也需要考量在内，这一点，第三个方案可能略显粗鲁，毕竟，机器学习如果以excel做数据集，未免有点奇葩..</p>\n<p>方案三，联表查数据，做归并，导出excel，也就是mhue现在这套机制。</p>\n","categories":["技术"],"tags":["PHP","ODBC"]},{"title":"详解PHP连接Impala安装与配置","url":"/2017/12/08/%E8%AF%A6%E8%A7%A3PHP%E8%BF%9E%E6%8E%A5Impala%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","content":"<h3 id=\"Impala的SQL语法参考\"><a href=\"#Impala的SQL语法参考\" class=\"headerlink\" title=\"Impala的SQL语法参考\"></a>Impala的SQL语法参考</h3><p><a href=\"https://www.cloudera.com/documentation/enterprise/latest/topics/impala_langref_sql.html\" target=\"_blank\" rel=\"noopener\">https://www.cloudera.com/documentation/enterprise/latest/topics/impala_langref_sql.html</a></p>\n<a id=\"more\"></a>\n<h3 id=\"PHP通过Thrift连接Impala\"><a href=\"#PHP通过Thrift连接Impala\" class=\"headerlink\" title=\"PHP通过Thrift连接Impala\"></a>PHP通过Thrift连接Impala</h3><h4 id=\"安装thrift服务\"><a href=\"#安装thrift服务\" class=\"headerlink\" title=\"安装thrift服务\"></a>安装thrift服务</h4><ul>\n<li>Thrift最初由Facebook开发用做系统内各语言之间的RPC通信.</li>\n<li>Thrift是一款可伸缩跨语言的服务开发框架, 该框架已经开源并且加入的Apache项目.</li>\n<li>Thrift主要功能是: 通过自定义的Interface Definition Language(IDL), 可以创建基于RPC的客户端和服务端的服务代码.</li>\n<li>数据和服务代码的生成是通过Thrift内置的代码生成器来实现的, Thrift的跨语言性体现在:它可以生成C++/Java/Python/PHP/Ruby/Erlang/Perl/Haskell/C#/Cocoa/JavaScript/Node.js/Smalltalk/OCaml/Delphi等语言的代码,且它们之间可以进行透明的通信.</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost tools]<span class=\"comment\"># rpm -ivh thrift-0.9.0-28.1.i686.rpm</span></span><br><span class=\"line\"></span><br><span class=\"line\">warning: thrift-0.9.0-28.1.i686.rpm: Header V3 DSA/SHA1 Signature, key ID a949b429: NOKEY</span><br><span class=\"line\">error: Failed dependencies:</span><br><span class=\"line\">libc.so.6 is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libc.so.6(GLIBC_2.0) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libc.so.6(GLIBC_2.1) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libc.so.6(GLIBC_2.1.3) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libc.so.6(GLIBC_2.3) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libc.so.6(GLIBC_2.3.4) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libc.so.6(GLIBC_2.4) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libgcc_s.so.1 is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libgcc_s.so.1(GCC_3.0) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libm.so.6 is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libstdc++.so.6 is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libstdc++.so.6(CXXABI_1.3) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libstdc++.so.6(CXXABI_1.3.1) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libstdc++.so.6(GLIBCXX_3.4) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libstdc++.so.6(GLIBCXX_3.4.11) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\">libstdc++.so.6(GLIBCXX_3.4.9) is needed by thrift-0.9.0-28.1.i686</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#报错, 缺少相关依赖.</span></span><br><span class=\"line\"><span class=\"comment\">#解决libc.so.6依赖:</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost tools]<span class=\"comment\"># yum list glibc*</span></span><br><span class=\"line\">[root@localhost tools]<span class=\"comment\"># yum install glibc.i686</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#解决libgcc_s.so.1依赖:到https://rpmfind.net/linux/rpm2html/search.php?query=libgcc_s.so.1下载相关依赖rpm包</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost tools]<span class=\"comment\"># rpm -ivh libgcc-4.4.7-18.el6.x86_64.rpm</span></span><br><span class=\"line\">[root@localhost tools]<span class=\"comment\"># rpm -ivh libgcc-4.4.7-18.el6.i686.rpm</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#解决libstdc++.so.6依赖:</span></span><br><span class=\"line\"><span class=\"comment\">#到https://rpmfind.net/linux/rpm2html/search.php?query=libstdc++.so.6下载相关依赖rpm包</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost tools]<span class=\"comment\"># rpm -ivh libstdc++-4.4.7-18.el6.i686.rpm</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#最后重新安装即可:</span></span><br><span class=\"line\">[root@localhost tools]<span class=\"comment\"># rpm -ivh thrift-0.9.0-28.1.i686.rpm</span></span><br><span class=\"line\">        warning: thrift-0.9.0-28.1.i686.rpm: Header V3 DSA/SHA1 Signature, key ID a949b429: NOKEY</span><br><span class=\"line\">        Preparing...                <span class=\"comment\">########################################### [100%]</span></span><br><span class=\"line\">           1:thrift                 <span class=\"comment\">########################################### [100%]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"检查是否安装成功\"><a href=\"#检查是否安装成功\" class=\"headerlink\" title=\"检查是否安装成功\"></a>检查是否安装成功</h4><p>a. 首先创建Thrift的语法规则文件, 命名为server.thrift, 内容如下:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct message</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    i32 seqId,</span><br><span class=\"line\">    <span class=\"built_in\">string</span> content</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">service serDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void <span class=\"keyword\">put</span>(message msg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>b. 然后shell下执行命令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># thrift -gen php server.thrift</span></span><br></pre></td></tr></table></figure>\n<p>该语句用于创建php服务框架, 创建成功后会在该目录下生成gen-php文件夹.</p>\n<h4 id=\"impala的SQL查询参考\"><a href=\"#impala的SQL查询参考\" class=\"headerlink\" title=\"impala的SQL查询参考\"></a>impala的SQL查询参考</h4><p><a href=\"http://www.cloudera.com/documentation/archive/impala/2-x/2-1-x/topics/impala_select.html\" target=\"_blank\" rel=\"noopener\">http://www.cloudera.com/documentation/archive/impala/2-x/2-1-x/topics/impala_select.html</a></p>\n<h4 id=\"连接PHP例子参考\"><a href=\"#连接PHP例子参考\" class=\"headerlink\" title=\"连接PHP例子参考\"></a>连接PHP例子参考</h4><p><a href=\"https://github.com/Automattic/php-thrift-sql\" target=\"_blank\" rel=\"noopener\">https://github.com/Automattic/php-thrift-sql</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git clone https://github.com/Automattic/php-thrift-sql.git</span></span><br><span class=\"line\"><span class=\"comment\"># cd php-thrift-sql/</span></span><br><span class=\"line\"><span class=\"comment\"># php -c php.ini build.php  【重新生成ThriftSQL.phar文件】</span></span><br><span class=\"line\"><span class=\"comment\"># vim test.php</span></span><br></pre></td></tr></table></figure>\n<p>内容如下:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// Load this lib</span></span><br><span class=\"line\"><span class=\"keyword\">require_once</span> <span class=\"keyword\">__DIR__</span> . <span class=\"string\">'/ThriftSQL.phar'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 1.Try out a Hive query</span></span><br><span class=\"line\">$hive = <span class=\"keyword\">new</span> \\ThriftSQL\\Hive(<span class=\"string\">'192.168.8.207'</span>, <span class=\"number\">21050</span>);</span><br><span class=\"line\">$hiveTables = $hive</span><br><span class=\"line\">    -&gt;setSasl(<span class=\"keyword\">false</span>) <span class=\"comment\">// To turn SASL auth off, on by default</span></span><br><span class=\"line\">    -&gt;connect()</span><br><span class=\"line\">    -&gt;queryAndFetchAll(<span class=\"string\">'SHOW TABLES'</span>);</span><br><span class=\"line\">print_r($hiveTables);</span><br><span class=\"line\"><span class=\"comment\">// 2.Try out an Impala query</span></span><br><span class=\"line\">$impala = <span class=\"keyword\">new</span> \\ThriftSQL\\Impala(<span class=\"string\">'192.168.8.207'</span>);</span><br><span class=\"line\">$impalaTables = $impala</span><br><span class=\"line\">    -&gt;connect()</span><br><span class=\"line\">    -&gt;queryAndFetchAll(<span class=\"string\">'SHOW TABLES'</span>);</span><br><span class=\"line\">print_r($impalaTables);</span><br><span class=\"line\"><span class=\"comment\">// 3.Try out an Impala query</span></span><br><span class=\"line\">$impalaDatas = $impala</span><br><span class=\"line\">    -&gt;connect()</span><br><span class=\"line\">    -&gt;queryAndFetchAll(<span class=\"string\">'select * from db_mcfx_log.t_log_sdk_log_user'</span>);</span><br><span class=\"line\">print_r($impalaDatas);</span><br><span class=\"line\"><span class=\"comment\">// 4.Don't forget to clear the client and close socket.</span></span><br><span class=\"line\">$hive-&gt;disconnect();</span><br><span class=\"line\">$impala-&gt;disconnect();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后执行test.php</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># php test.php</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使PHP通过ODBC连接Impala-方法1\"><a href=\"#使PHP通过ODBC连接Impala-方法1\" class=\"headerlink\" title=\"使PHP通过ODBC连接Impala(方法1)\"></a>使PHP通过ODBC连接Impala(方法1)</h3><h4 id=\"安装ODBC相关软件包以及ImpalaODBC驱动\"><a href=\"#安装ODBC相关软件包以及ImpalaODBC驱动\" class=\"headerlink\" title=\"安装ODBC相关软件包以及ImpalaODBC驱动\"></a>安装ODBC相关软件包以及ImpalaODBC驱动</h4><h5 id=\"系统版本\"><a href=\"#系统版本\" class=\"headerlink\" title=\"系统版本\"></a>系统版本</h5><p>centos6，别用centos7，很多lib不兼容，经常会看到这样的错误，解决起来非常棘手，即使下载安装了i686相关的包也不行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">libxxx()(64bit) is needed by xxx</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用ODBC连接数据库-分为两个主要部分\"><a href=\"#使用ODBC连接数据库-分为两个主要部分\" class=\"headerlink\" title=\"使用ODBC连接数据库, 分为两个主要部分:\"></a>使用ODBC连接数据库, 分为两个主要部分:</h4><ul>\n<li>安装ODBC管理程序(例如unixODBC/iODBC等), 这里管理程序选择unixODBC</li>\n<li>安装每个数据库对应的ODBC驱动程序, 而Impala的ODBC驱动则参考Cloudera-ODBC-Driver-for-Impala-Install-Guide</li>\n</ul>\n<h4 id=\"ClouderaImpalaODBC到Cloudera官网下载\"><a href=\"#ClouderaImpalaODBC到Cloudera官网下载\" class=\"headerlink\" title=\"ClouderaImpalaODBC到Cloudera官网下载:\"></a>ClouderaImpalaODBC到Cloudera官网下载:</h4><p><a href=\"https://downloads.cloudera.com/connectors/impala-2.5.15.1015/Linux/EL6/ClouderaImpalaODBC-2.5.15.1015-1.el6.x86_64.rpm\" target=\"_blank\" rel=\"noopener\">https://downloads.cloudera.com/connectors/impala-2.5.15.1015/Linux/EL6/ClouderaImpalaODBC-2.5.15.1015-1.el6.x86_64.rpm</a></p>\n<h4 id=\"若已安装其他版本则先卸载原来安装的\"><a href=\"#若已安装其他版本则先卸载原来安装的\" class=\"headerlink\" title=\"若已安装其他版本则先卸载原来安装的\"></a>若已安装其他版本则先卸载原来安装的</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rpm -q ClouderaImpalaODBC</span></span><br><span class=\"line\"><span class=\"comment\"># rpm -e ClouderaImpalaODBC-2.5.30.1011-1.x86_64</span></span><br><span class=\"line\"><span class=\"comment\"># yum install -y unixODBC*</span></span><br><span class=\"line\"><span class=\"comment\"># rpm -ivh ClouderaImpalaODBC-2.5.15.1015-1.el6.x86_64.rpm</span></span><br></pre></td></tr></table></figure>\n<p>使用odbcinst命令查看unixODBC配置文件路径.<br>不同版本的unixODBC配置文件路径是不同的, 如果是源代码方式安装unixODBC, 也可以通过编译参数–sysconfdir指定.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># odbcinst -j</span></span><br><span class=\"line\">unixODBC 2.2.14</span><br><span class=\"line\">DRIVERS............: /etc/odbcinst.ini</span><br><span class=\"line\">SYSTEM DATA SOURCES: /etc/odbc.ini</span><br><span class=\"line\">FILE DATA SOURCES..: /etc/ODBCDataSources</span><br><span class=\"line\">USER DATA SOURCES..: /root/.odbc.ini</span><br><span class=\"line\">SQLULEN Size.......: 8</span><br><span class=\"line\">SQLLEN Size........: 8</span><br><span class=\"line\">SQLSETPOSIROW Size.: 8</span><br></pre></td></tr></table></figure>\n<h4 id=\"增加环境变量-注意重启后失效-可在-etc-profile里面改使永久生效\"><a href=\"#增加环境变量-注意重启后失效-可在-etc-profile里面改使永久生效\" class=\"headerlink\" title=\"增加环境变量(注意重启后失效, 可在/etc/profile里面改使永久生效)\"></a>增加环境变量(注意重启后失效, 可在/etc/profile里面改使永久生效)</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># export LD_LIBRARY_PATH=/usr/local/lib:/opt/cloudera/impalaodbc/lib/64</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"动态编译pdo-odbc扩展\"><a href=\"#动态编译pdo-odbc扩展\" class=\"headerlink\" title=\"动态编译pdo-odbc扩展\"></a>动态编译pdo-odbc扩展</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cd /home/xxx/php-7.1.3 # 根据自己的PHP源码路径</span></span><br><span class=\"line\">[root@localhost php-7.1.3]<span class=\"comment\"># cd ext/pdo_odbc/</span></span><br><span class=\"line\">[root@localhost pdo_odbc]<span class=\"comment\"># /application/php/bin/phpize</span></span><br><span class=\"line\">[root@localhost pdo_odbc]<span class=\"comment\"># ./configure --help </span></span><br><span class=\"line\"><span class=\"comment\"># 注意，PHP多版本共存下需要指定PHP</span></span><br><span class=\"line\">[root@localhost pdo_odbc]<span class=\"comment\"># ./configure --with-php-config=/xxx/bin/php-config --with-pdo-odbc=unixODBC,/usr/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># configure: error: Cannot find header file(s) for pdo_odbc</span></span><br><span class=\"line\"><span class=\"comment\"># 完全安装好unixODBC和unixODBC-devel</span></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost pdo_odbc]<span class=\"comment\"># make &amp;&amp; make install</span></span><br><span class=\"line\"><span class=\"comment\"># 编辑php.ini加入pdo_odbc.so扩展</span></span><br><span class=\"line\">[root@localhost pdo_odbc]<span class=\"comment\"># vim /xxx/php.ini</span></span><br><span class=\"line\">extension = pdo_odbc.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启php查看配置如下:</span></span><br><span class=\"line\">[root@localhost pdo_odbc]<span class=\"comment\"># /etc/init.d/php-fpm restart</span></span><br><span class=\"line\">[root@localhost pdo_odbc]<span class=\"comment\"># php -i |grep odbc</span></span><br><span class=\"line\">PDO drivers =&gt; mysql, sqlite, odbc</span><br><span class=\"line\">LD_LIBRARY_PATH =&gt; /usr/<span class=\"built_in\">local</span>/lib:/opt/cloudera/impalaodbc/lib/64</span><br><span class=\"line\"><span class=\"variable\">$_SERVER</span>[<span class=\"string\">'LD_LIBRARY_PATH'</span>] =&gt; /usr/<span class=\"built_in\">local</span>/lib:/opt/cloudera/impalaodbc/lib/64</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态编译odbc扩展\"><a href=\"#动态编译odbc扩展\" class=\"headerlink\" title=\"动态编译odbc扩展\"></a>动态编译odbc扩展</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cd /home/xxx/php-7.1.3</span></span><br><span class=\"line\">[root@localhost php-7.1.3]<span class=\"comment\"># cd ext/odbc/</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># /application/php/bin/phpize</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># ./configure --help</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># ./configure --with-php-config=/xxx/php7.1.3/bin/php-config --with-unixODBC=/usr/</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># make</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># make install</span></span><br><span class=\"line\">Installing shared extensions:     /xxx/php7.1.3/lib/php/extensions/no-debug-non-zts-20160303/</span><br><span class=\"line\">root@localhost odbc]<span class=\"comment\"># ll /xxx/php7.1.3/lib/php/extensions/no-debug-non-zts-20160303/</span></span><br><span class=\"line\">total 5556</span><br><span class=\"line\">-rwxr-xr-x 1 root root  350680 Mar 24 15:42 memcached.so</span><br><span class=\"line\">-rwxr-xr-x 1 root root  255310 Mar 24 15:00 memcache.so</span><br><span class=\"line\">-rwxr-xr-x 1 root root  173215 Jun 12 09:24 odbc.so</span><br><span class=\"line\">-rwxr-xr-x 1 root root 3020972 Mar 24 14:23 opcache.a</span><br><span class=\"line\">-rwxr-xr-x 1 root root 1750437 Mar 24 14:23 opcache.so</span><br><span class=\"line\">-rwxr-xr-x 1 root root  126680 May 23 14:04 pdo_odbc.so</span><br><span class=\"line\"><span class=\"comment\"># 编辑php.ini加入odbc.so扩展</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># vim /xxx/php/lib/php.ini</span></span><br><span class=\"line\">extension = odbc.so</span><br><span class=\"line\"><span class=\"comment\"># 重启php查看配置信息:</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># /etc/init.d/php-fpm restart</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># php -i |grep odbc</span></span><br><span class=\"line\">odbc</span><br><span class=\"line\">odbc.allow_persistent =&gt; On =&gt; On</span><br><span class=\"line\">odbc.check_persistent =&gt; On =&gt; On</span><br><span class=\"line\">odbc.default_cursortype =&gt; Static cursor =&gt; Static cursor</span><br><span class=\"line\">odbc.default_db =&gt; no value =&gt; no value</span><br><span class=\"line\">odbc.default_pw =&gt; no value =&gt; no value</span><br><span class=\"line\">odbc.default_user =&gt; no value =&gt; no value</span><br><span class=\"line\">odbc.defaultbinmode =&gt; <span class=\"built_in\">return</span> as is =&gt; <span class=\"built_in\">return</span> as is</span><br><span class=\"line\">odbc.defaultlrl =&gt; <span class=\"built_in\">return</span> up to 4096 bytes =&gt; <span class=\"built_in\">return</span> up to 4096 bytes</span><br><span class=\"line\">odbc.max_links =&gt; Unlimited =&gt; Unlimited</span><br><span class=\"line\">odbc.max_persistent =&gt; Unlimited =&gt; Unlimited</span><br><span class=\"line\">PDO drivers =&gt; mysql, sqlite, odbc</span><br><span class=\"line\">LD_LIBRARY_PATH =&gt; /usr/<span class=\"built_in\">local</span>/lib:/opt/cloudera/impalaodbc/lib/64</span><br><span class=\"line\">PWD =&gt; /xxx/php-7.1.3/ext/odbc</span><br><span class=\"line\"><span class=\"variable\">$SERVER</span>[<span class=\"string\">'LD_LIBRARY_PATH'</span>] =&gt; /usr/<span class=\"built_in\">local</span>/lib:/opt/cloudera/impalaodbc/lib/64</span><br><span class=\"line\"><span class=\"variable\">$_SERVER</span>[<span class=\"string\">'PWD'</span>] =&gt; /xxx/php-7.1.3/ext/odbc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意, 如果configure编译的时候出现报错如下:</span></span><br><span class=\"line\">checking <span class=\"keyword\">for</span> Adabas support... cp: cannot <span class=\"built_in\">stat</span> <span class=\"string\">'/usr/local/lib/odbclib.a'</span>: No such file or directory</span><br><span class=\"line\">configure: error: ODBC header file <span class=\"string\">'/usr/local/incl/sqlext.h'</span> not found!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 那么可进行修改configure配置文件:</span></span><br><span class=\"line\">[root@localhost odbc]<span class=\"comment\"># sed -ri 's@^ *test +\"\\$PHP.\" *= *\"no\" *&amp;&amp; *PHP_.=yes *$@#&amp;@g' configure</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"修改-etc-odbc-ini替换为如下-注意！！下文所有的配置文件的每行都一定要保持左对齐！\"><a href=\"#修改-etc-odbc-ini替换为如下-注意！！下文所有的配置文件的每行都一定要保持左对齐！\" class=\"headerlink\" title=\"修改/etc/odbc.ini替换为如下:(注意！！下文所有的配置文件的每行都一定要保持左对齐！)\"></a>修改/etc/odbc.ini替换为如下:(注意！！下文所有的配置文件的每行都一定要保持左对齐！)</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ODBC]</span><br><span class=\"line\"></span><br><span class=\"line\">Specify any <span class=\"keyword\">global</span> ODBC configuration here such <span class=\"keyword\">as</span> ODBC tracing.</span><br><span class=\"line\">[ODBC Data Sources]</span><br><span class=\"line\">#Cloudera Hive <span class=\"number\">32</span>-bit=Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive <span class=\"number\">32</span>-bit</span><br><span class=\"line\">impala=Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala <span class=\"number\">64</span>-bit</span><br><span class=\"line\">[impala]</span><br><span class=\"line\"></span><br><span class=\"line\">Description: DSN Description.</span><br><span class=\"line\">This key <span class=\"keyword\">is</span> not necessary <span class=\"built_in\">and</span> <span class=\"keyword\">is</span> <span class=\"keyword\">only</span> <span class=\"keyword\">to</span> give <span class=\"keyword\">a</span> description of the data <span class=\"keyword\">source</span>.</span><br><span class=\"line\">Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala (<span class=\"number\">64</span>-bit) DSN</span><br><span class=\"line\"></span><br><span class=\"line\">Driver: The location where the ODBC driver <span class=\"keyword\">is</span> installed <span class=\"keyword\">to</span>.</span><br><span class=\"line\">Driver=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/lib/<span class=\"number\">64</span>/libclouderaimpalaodbc64.<span class=\"keyword\">so</span></span><br><span class=\"line\"></span><br><span class=\"line\">The DriverUnicodeEncoding setting <span class=\"keyword\">is</span> <span class=\"keyword\">only</span> used <span class=\"keyword\">for</span> SimbaDM</span><br><span class=\"line\">When <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">1</span>, SimbaDM runs in UTF-<span class=\"number\">16</span> <span class=\"keyword\">mode</span>.</span><br><span class=\"line\">When <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">2</span>, SimbaDM runs in UTF-<span class=\"number\">8</span> <span class=\"keyword\">mode</span>.</span><br><span class=\"line\">#DriverUnicodeEncoding=<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">Values <span class=\"keyword\">for</span> HOST, PORT, KrbFQDN, <span class=\"built_in\">and</span> KrbServiceName should <span class=\"keyword\">be</span> <span class=\"keyword\">set</span> here.</span><br><span class=\"line\">They can also <span class=\"keyword\">be</span> specified <span class=\"keyword\">on</span> the connection <span class=\"built_in\">string</span>.</span><br><span class=\"line\">HOST=xxx</span><br><span class=\"line\">PORT=xxx</span><br><span class=\"line\">Database=default</span><br><span class=\"line\"></span><br><span class=\"line\">The authentication mechanism.</span><br><span class=\"line\"><span class=\"number\">0</span> - No authentication (NOSASL)</span><br><span class=\"line\"><span class=\"number\">1</span> - Kerberos authentication (SASL)</span><br><span class=\"line\"><span class=\"number\">2</span> - Username authentication (SASL)</span><br><span class=\"line\"><span class=\"number\">3</span> - Username/password authentication (NOSASL <span class=\"built_in\">or</span> SASL depending <span class=\"keyword\">on</span> UseSASL configuration)</span><br><span class=\"line\">AuthMech=<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">to</span> use SASL <span class=\"keyword\">for</span> authentication.</span><br><span class=\"line\">Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">to</span> not use SASL.</span><br><span class=\"line\">When using Kerberos authentication (SASL) <span class=\"built_in\">or</span> Username authentication (SASL) SASL <span class=\"keyword\">is</span> always used</span><br><span class=\"line\"><span class=\"built_in\">and</span> this configuration <span class=\"keyword\">is</span> ignored. SASL <span class=\"keyword\">is</span> always not used <span class=\"keyword\">for</span> No authentication (NOSASL).</span><br><span class=\"line\">UseSASL=<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">Kerberos related settings.</span><br><span class=\"line\">KrbFQDN=</span><br><span class=\"line\">KrbRealm=</span><br><span class=\"line\">KrbServiceName=</span><br><span class=\"line\"></span><br><span class=\"line\">Username/password authentication with SASL settings.</span><br><span class=\"line\">UID=hdfs</span><br><span class=\"line\">PWD=</span><br><span class=\"line\"></span><br><span class=\"line\">Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">to</span> disable SSL.</span><br><span class=\"line\">Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">to</span> enable SSL.</span><br><span class=\"line\">SSL=<span class=\"number\">0</span></span><br><span class=\"line\">CAIssuedCertNamesMismatch=<span class=\"number\">1</span></span><br><span class=\"line\">TrustedCerts=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/lib/<span class=\"number\">64</span>/cacerts.pem</span><br><span class=\"line\"></span><br><span class=\"line\">General settings</span><br><span class=\"line\">TSaslTransportBufSize=<span class=\"number\">1000</span></span><br><span class=\"line\">RowsFetchedPerBlock=<span class=\"number\">10000</span></span><br><span class=\"line\">SocketTimeout=<span class=\"number\">0</span></span><br><span class=\"line\">StringColumnLength=<span class=\"number\">32767</span></span><br><span class=\"line\">UseNativeQuery=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"修改-etc-odbcins-ini替换为如下\"><a href=\"#修改-etc-odbcins-ini替换为如下\" class=\"headerlink\" title=\"修改/etc/odbcins.ini替换为如下:\"></a>修改/etc/odbcins.ini替换为如下:</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ODBC Drivers]</span><br><span class=\"line\">Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala <span class=\"number\">64</span>-bit=Installed</span><br><span class=\"line\">#[Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive <span class=\"number\">32</span>-bit]</span><br><span class=\"line\">#Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive (<span class=\"number\">32</span>-bit)</span><br><span class=\"line\">#Driver=/<span class=\"keyword\">opt</span>/cloudera/hiveodbc/lib/<span class=\"number\">32</span>/libclouderahiveodbc32.<span class=\"keyword\">so</span></span><br><span class=\"line\"></span><br><span class=\"line\">The option below <span class=\"keyword\">is</span> <span class=\"keyword\">for</span> using unixODBC when compiled with -DSQL_WCHART_CONVERT.</span><br><span class=\"line\">Execute <span class=\"string\">'odbc_config --cflags'</span> <span class=\"keyword\">to</span> determine <span class=\"keyword\">if</span> you need <span class=\"keyword\">to</span> uncomment it.</span><br><span class=\"line\">IconvEncoding=UCS-<span class=\"number\">4</span>LE</span><br><span class=\"line\">[Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala <span class=\"number\">64</span>-bit]</span><br><span class=\"line\">Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala (<span class=\"number\">64</span>-bit)</span><br><span class=\"line\">Driver=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/lib/<span class=\"number\">64</span>/libclouderaimpalaodbc64.<span class=\"keyword\">so</span></span><br><span class=\"line\"></span><br><span class=\"line\">The option below <span class=\"keyword\">is</span> <span class=\"keyword\">for</span> using unixODBC when compiled with -DSQL_WCHART_CONVERT.</span><br><span class=\"line\">Execute <span class=\"string\">'odbc_config --cflags'</span> <span class=\"keyword\">to</span> determine <span class=\"keyword\">if</span> you need <span class=\"keyword\">to</span> uncomment it.</span><br><span class=\"line\">IconvEncoding=UCS-<span class=\"number\">4</span>LE</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改-etc-cloudera-impalaodbc-ini\"><a href=\"#修改-etc-cloudera-impalaodbc-ini\" class=\"headerlink\" title=\"修改/etc/cloudera.impalaodbc.ini\"></a>修改/etc/cloudera.impalaodbc.ini</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Driver]</span><br><span class=\"line\"></span><br><span class=\"line\">- Note that this default DriverManagerEncoding of UTF-<span class=\"number\">32</span> <span class=\"keyword\">is</span> <span class=\"keyword\">for</span> iODBC.</span><br><span class=\"line\">- unixODBC uses UTF-<span class=\"number\">16</span> by default.</span><br><span class=\"line\">- If unixODBC was compiled with -DSQL_WCHART_CONVERT, then UTF-<span class=\"number\">32</span> <span class=\"keyword\">is</span> the correct value.</span><br><span class=\"line\">##   Execute <span class=\"string\">'odbc_config --cflags'</span> <span class=\"keyword\">to</span> determine <span class=\"keyword\">if</span> you need UTF-<span class=\"number\">32</span> <span class=\"built_in\">or</span> UTF-<span class=\"number\">16</span> <span class=\"keyword\">on</span> unixODBC</span><br><span class=\"line\"></span><br><span class=\"line\">- SimbaDM can <span class=\"keyword\">be</span> used with UTF-<span class=\"number\">8</span> <span class=\"built_in\">or</span> UTF-<span class=\"number\">16</span>.</span><br><span class=\"line\">##   The DriverUnicodeEncoding setting will cause SimbaDM <span class=\"keyword\">to</span> run in UTF-<span class=\"number\">8</span> when <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">2</span> <span class=\"built_in\">or</span> UTF-<span class=\"number\">16</span> when <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">1</span>.</span><br><span class=\"line\">DriverManagerEncoding=UTF-<span class=\"number\">32</span></span><br><span class=\"line\">ErrorMessagesPath=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/ErrorMessages</span><br><span class=\"line\">LogLevel=<span class=\"number\">0</span></span><br><span class=\"line\">LogPath=</span><br><span class=\"line\"></span><br><span class=\"line\">- Uncomment the ODBCInstLib corresponding <span class=\"keyword\">to</span> the Driver Manager being used.</span><br><span class=\"line\">- Note that the path <span class=\"keyword\">to</span> your ODBC Driver Manager must <span class=\"keyword\">be</span> specified in LD_LIBRARY_PATH (LIBPATH <span class=\"keyword\">for</span> AIX).</span><br><span class=\"line\">- Note that AIX <span class=\"built_in\">has</span> <span class=\"keyword\">a</span> different format <span class=\"keyword\">for</span> specifying its shared libraries.</span><br><span class=\"line\">Generic ODBCInstLib</span><br><span class=\"line\">#   iODBC</span><br><span class=\"line\">#ODBCInstLib=libiodbcinst.<span class=\"keyword\">so</span></span><br><span class=\"line\">#   SimbaDM / unixODBC</span><br><span class=\"line\">ODBCInstLib=libodbcinst.<span class=\"keyword\">so</span></span><br><span class=\"line\"></span><br><span class=\"line\">AIX specific ODBCInstLib</span><br><span class=\"line\">#   iODBC</span><br><span class=\"line\">#ODBCInstLib=libiodbcinst.<span class=\"keyword\">a</span>(libiodbcinst.<span class=\"keyword\">so</span>.<span class=\"number\">2</span>)</span><br><span class=\"line\">#   SimbaDM</span><br><span class=\"line\">#ODBCInstLib=libodbcinst.<span class=\"keyword\">a</span>(odbcinst.<span class=\"keyword\">so</span>)</span><br><span class=\"line\">#   unixODBC</span><br><span class=\"line\">#ODBCInstLib=libodbcinst.<span class=\"keyword\">a</span>(libodbcinst.<span class=\"keyword\">so</span>.<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试连接impala\"><a href=\"#测试连接impala\" class=\"headerlink\" title=\"测试连接impala\"></a>测试连接impala</h4><p>因为在/etc/odbc.ini我们设定的DSN名称为impala, 所以执行如下语句:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># isql -v 'impala'</span></span><br><span class=\"line\">        +---------------------------------------+</span><br><span class=\"line\">        | Connected!                            |</span><br><span class=\"line\">        |                                       |</span><br><span class=\"line\">        | sql-statement                         |</span><br><span class=\"line\">        | <span class=\"built_in\">help</span> [tablename]                      |</span><br><span class=\"line\">        | quit                                  |</span><br><span class=\"line\">        |                                       |</span><br><span class=\"line\">        +---------------------------------------+</span><br></pre></td></tr></table></figure>\n<h3 id=\"PHP通过ODBC连接Impala-方法2\"><a href=\"#PHP通过ODBC连接Impala-方法2\" class=\"headerlink\" title=\"PHP通过ODBC连接Impala(方法2)\"></a>PHP通过ODBC连接Impala(方法2)</h3><h4 id=\"安装ODBC相关软件包以及ImpalaODBC驱动-1\"><a href=\"#安装ODBC相关软件包以及ImpalaODBC驱动-1\" class=\"headerlink\" title=\"安装ODBC相关软件包以及ImpalaODBC驱动\"></a>安装ODBC相关软件包以及ImpalaODBC驱动</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># yum install -y unixODBC*</span></span><br><span class=\"line\"><span class=\"comment\"># rpm -ivh ClouderaImpalaODBC-2.5.15.1015-1.el6.x86_64.rpm</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"新建存放配置的目录\"><a href=\"#新建存放配置的目录\" class=\"headerlink\" title=\"新建存放配置的目录\"></a>新建存放配置的目录</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># mkdir /home/xxx/config_odbc</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cd /home/xxx/config_odbc</span></span><br><span class=\"line\">[root@localhost config_odbc]<span class=\"comment\"># mkdir odbc</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建环境变量文件common-env\"><a href=\"#创建环境变量文件common-env\" class=\"headerlink\" title=\"创建环境变量文件common.env\"></a>创建环境变量文件common.env</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost config_odbc]# <span class=\"keyword\">vim</span> common.env</span><br><span class=\"line\"></span><br><span class=\"line\">CONFIG_DIR=$(readlink -<span class=\"keyword\">f</span> $(dirname $&#123;BASH_SOURCE[<span class=\"number\">0</span>]&#125;))</span><br><span class=\"line\">ODBC_CONFIG_DIR=$&#123;CONFIG_DIR&#125;/odbc</span><br><span class=\"line\">export ODBCINI=$&#123;ODBC_CONFIG_DIR&#125;/odbc.ini</span><br><span class=\"line\">export ODBCSYSINI=$&#123;ODBC_CONFIG_DIR&#125;</span><br><span class=\"line\">export CLOUDERAIMPALAINI=$&#123;ODBC_CONFIG_DIR&#125;/cloudera.impalaodbc.ini</span><br><span class=\"line\">export CLOUDERAHIVEINI=$&#123;ODBC_CONFIG_DIR&#125;/cloudera.hiveodbc.ini</span><br><span class=\"line\">export LD_LIBRARY_PATH=/usr/local/li<span class=\"variable\">b:</span>/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/lib/<span class=\"number\">64</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置odbc-odbc-ini\"><a href=\"#创建配置odbc-odbc-ini\" class=\"headerlink\" title=\"创建配置odbc/odbc.ini\"></a>创建配置odbc/odbc.ini</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost config_odbc]# <span class=\"keyword\">vim</span> odbc/odbc.ini    【注意里面包含了ODBC连接hive和impala的配置】</span><br><span class=\"line\"></span><br><span class=\"line\">[ODBC]</span><br><span class=\"line\"># Specify any <span class=\"keyword\">global</span> ODBC configuration here such <span class=\"keyword\">as</span> ODBC tracing.</span><br><span class=\"line\">[ODBC Data Sources]</span><br><span class=\"line\">#Cloudera Hive <span class=\"number\">32</span>-bit=Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive <span class=\"number\">32</span>-bit</span><br><span class=\"line\">hive=Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive <span class=\"number\">64</span>-bit</span><br><span class=\"line\">impala=Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala <span class=\"number\">64</span>-bit</span><br><span class=\"line\">[hive]</span><br><span class=\"line\"># Description: DSN Description.</span><br><span class=\"line\"># This key <span class=\"keyword\">is</span> not necessary <span class=\"built_in\">and</span> <span class=\"keyword\">is</span> <span class=\"keyword\">only</span> <span class=\"keyword\">to</span> give <span class=\"keyword\">a</span> description of the data <span class=\"keyword\">source</span>.</span><br><span class=\"line\">Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive (<span class=\"number\">64</span>-bit) DSN</span><br><span class=\"line\"># Driver: The location where the ODBC driver <span class=\"keyword\">is</span> installed <span class=\"keyword\">to</span>.</span><br><span class=\"line\">Driver=/<span class=\"keyword\">opt</span>/cloudera/hiveodbc/lib/<span class=\"number\">64</span>/libclouderahiveodbc64.<span class=\"keyword\">so</span></span><br><span class=\"line\"># When using No Service Discovery, specify the IP address <span class=\"built_in\">or</span> host name of the Hive server.</span><br><span class=\"line\"># When using ZooKeeper <span class=\"keyword\">as</span> the Service Discovery Mode, specify <span class=\"keyword\">a</span> comma-separated <span class=\"keyword\">list</span> of ZooKeeper</span><br><span class=\"line\"># servers in the following forma<span class=\"variable\">t:</span></span><br><span class=\"line\">#       &lt;zk_host1:zk_port1&gt;,&lt;zk_host2:zk_port2&gt;,...</span><br><span class=\"line\">HOST=<span class=\"number\">192.168</span>.<span class=\"number\">11.9</span></span><br><span class=\"line\"># The TCP port Hive server <span class=\"keyword\">is</span> listening. This <span class=\"keyword\">is</span> not required when using ZooKeeper <span class=\"keyword\">as</span> the service</span><br><span class=\"line\"># discovery <span class=\"keyword\">mode</span> <span class=\"keyword\">as</span> the port <span class=\"keyword\">is</span> specified in the HOST connection attribute.</span><br><span class=\"line\">PORT=<span class=\"number\">10000</span></span><br><span class=\"line\"># The name of the database schema <span class=\"keyword\">to</span> use when <span class=\"keyword\">a</span> schema <span class=\"keyword\">is</span> not explicitly specified in <span class=\"keyword\">a</span> query.</span><br><span class=\"line\">Schema=default</span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">to</span> when connecting directory <span class=\"keyword\">to</span> Hive Server <span class=\"number\">2</span> (No Service Discovery).</span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">to</span> <span class=\"keyword\">do</span> Hive Server <span class=\"number\">2</span> service discovery using ZooKeeper.</span><br><span class=\"line\"># Note service discovery <span class=\"keyword\">is</span> not support when using Hive Server <span class=\"number\">1</span>.</span><br><span class=\"line\">ServiceDiscoveryMode=<span class=\"number\">0</span></span><br><span class=\"line\"># The namespace <span class=\"keyword\">on</span> ZooKeeper under which Hive Server <span class=\"number\">2</span> znodes are added. Required <span class=\"keyword\">only</span> when doing</span><br><span class=\"line\"># HS2 service discovery with ZooKeeper (ServiceDiscoveryMode=<span class=\"number\">1</span>).</span><br><span class=\"line\">ZKNamespace=</span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">if</span> you are connecting <span class=\"keyword\">to</span> Hive Server <span class=\"number\">1</span>. Set <span class=\"keyword\">to</span> <span class=\"number\">2</span> <span class=\"keyword\">if</span> you are connecting <span class=\"keyword\">to</span> Hive Server <span class=\"number\">2</span>.</span><br><span class=\"line\">HiveServerType=<span class=\"number\">2</span></span><br><span class=\"line\"># The authentication mechanism <span class=\"keyword\">to</span> use <span class=\"keyword\">for</span> the connection.</span><br><span class=\"line\">#   Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">for</span> No Authentication</span><br><span class=\"line\">#   Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">for</span> Kerberos</span><br><span class=\"line\">#   Set <span class=\"keyword\">to</span> <span class=\"number\">2</span> <span class=\"keyword\">for</span> User Name</span><br><span class=\"line\">#   Set <span class=\"keyword\">to</span> <span class=\"number\">3</span> <span class=\"keyword\">for</span> User Name <span class=\"built_in\">and</span> Password</span><br><span class=\"line\"># Note <span class=\"keyword\">only</span> No Authentication <span class=\"keyword\">is</span> supported when connecting <span class=\"keyword\">to</span> Hive Server <span class=\"number\">1</span>.</span><br><span class=\"line\">AuthMech=<span class=\"number\">2</span></span><br><span class=\"line\"># The Thrift transport <span class=\"keyword\">to</span> use <span class=\"keyword\">for</span> the connection.</span><br><span class=\"line\">#    Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">for</span> Binary</span><br><span class=\"line\">#    Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">for</span> SASL</span><br><span class=\"line\">#    Set <span class=\"keyword\">to</span> <span class=\"number\">2</span> <span class=\"keyword\">for</span> HTTP</span><br><span class=\"line\"># Note <span class=\"keyword\">for</span> Hive Server <span class=\"number\">1</span> <span class=\"keyword\">only</span> Binary can <span class=\"keyword\">be</span> used.</span><br><span class=\"line\">ThriftTransport=<span class=\"number\">1</span></span><br><span class=\"line\"># When this option <span class=\"keyword\">is</span> enabled (<span class=\"number\">1</span>), the driver does not transform the queries emitted by <span class=\"keyword\">an</span></span><br><span class=\"line\"># application, <span class=\"keyword\">so</span> the native query <span class=\"keyword\">is</span> used.</span><br><span class=\"line\"># When this option <span class=\"keyword\">is</span> disabled (<span class=\"number\">0</span>), the driver transforms the queries emitted by <span class=\"keyword\">an</span> application <span class=\"built_in\">and</span></span><br><span class=\"line\"># converts them into <span class=\"keyword\">an</span> equivalent from in HiveQL.</span><br><span class=\"line\">UseNativeQuery=<span class=\"number\">0</span></span><br><span class=\"line\"># Set the UID with the user name <span class=\"keyword\">to</span> use <span class=\"keyword\">to</span> access Hive when using AuthMech <span class=\"number\">2</span> <span class=\"keyword\">to</span> <span class=\"number\">8</span>.</span><br><span class=\"line\">UID=hdfs</span><br><span class=\"line\"># The following <span class=\"keyword\">is</span> settings used when using Kerberos authentication (AuthMech <span class=\"number\">1</span> <span class=\"built_in\">and</span> <span class=\"number\">10</span>)</span><br><span class=\"line\"># The fully qualified host name part of the of the Hive Server <span class=\"number\">2</span> Kerberos service principal.</span><br><span class=\"line\"># For example <span class=\"keyword\">if</span> the service principal name of you Hive Server <span class=\"number\">2</span> i<span class=\"variable\">s:</span></span><br><span class=\"line\">#   hive/myhs2.mydomain.com@EXAMPLE.COM</span><br><span class=\"line\"># Then <span class=\"keyword\">set</span> KrbHostFQDN <span class=\"keyword\">to</span> myhs2.mydomain.<span class=\"keyword\">com</span></span><br><span class=\"line\">KrbHostFQDN=_HOST</span><br><span class=\"line\"># The service name part of the of the Hive Server <span class=\"number\">2</span> Kerberos service principal.</span><br><span class=\"line\"># For example <span class=\"keyword\">if</span> the service principal name of you Hive Server <span class=\"number\">2</span> i<span class=\"variable\">s:</span></span><br><span class=\"line\">#   hive/myhs2.mydomain.com@EXAMPLE.COM</span><br><span class=\"line\"># Then <span class=\"keyword\">set</span> KrbServiceName <span class=\"keyword\">to</span> hive</span><br><span class=\"line\">KrbServiceName=hive</span><br><span class=\"line\"># The realm part of the of the Hive Server <span class=\"number\">2</span> Kerberos service principal.</span><br><span class=\"line\"># For example <span class=\"keyword\">if</span> the service principal name of you Hive Server <span class=\"number\">2</span> i<span class=\"variable\">s:</span></span><br><span class=\"line\">#   hive/myhs2.mydomain.com@EXAMPLE.COM</span><br><span class=\"line\"># Then <span class=\"keyword\">set</span> KrbRealm <span class=\"keyword\">to</span> EXAMPLE.COM</span><br><span class=\"line\">KrbRealm=</span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">to</span> enable SSL. Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">to</span> disable.</span><br><span class=\"line\">SSL=<span class=\"number\">0</span></span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">to</span> enable two-way SSL. Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">to</span> disable. You must enable SSL in order <span class=\"keyword\">to</span></span><br><span class=\"line\"># use two-way SSL.</span><br><span class=\"line\">TwoWaySSL=<span class=\"number\">0</span></span><br><span class=\"line\"># The <span class=\"keyword\">file</span> containing the client certificate in PEM format. This <span class=\"keyword\">is</span> required when using two-way SSL.</span><br><span class=\"line\">ClientCert=</span><br><span class=\"line\"># The client private key. This <span class=\"keyword\">is</span> used <span class=\"keyword\">for</span> two-way SSL authentication.</span><br><span class=\"line\">ClientPrivateKey=</span><br><span class=\"line\"># The password <span class=\"keyword\">for</span> the client private key. Password <span class=\"keyword\">is</span> <span class=\"keyword\">only</span> required <span class=\"keyword\">for</span> password protected</span><br><span class=\"line\"># client private key.</span><br><span class=\"line\">ClientPrivateKeyPassword=</span><br><span class=\"line\">[impala]</span><br><span class=\"line\"># Description: DSN Description.</span><br><span class=\"line\"># This key <span class=\"keyword\">is</span> not necessary <span class=\"built_in\">and</span> <span class=\"keyword\">is</span> <span class=\"keyword\">only</span> <span class=\"keyword\">to</span> give <span class=\"keyword\">a</span> description of the data <span class=\"keyword\">source</span>.</span><br><span class=\"line\">Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala (<span class=\"number\">64</span>-bit) DSN</span><br><span class=\"line\"># Driver: The location where the ODBC driver <span class=\"keyword\">is</span> installed <span class=\"keyword\">to</span>.</span><br><span class=\"line\">Driver=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/lib/<span class=\"number\">64</span>/libclouderaimpalaodbc64.<span class=\"keyword\">so</span></span><br><span class=\"line\"># The DriverUnicodeEncoding setting <span class=\"keyword\">is</span> <span class=\"keyword\">only</span> used <span class=\"keyword\">for</span> SimbaDM</span><br><span class=\"line\"># When <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">1</span>, SimbaDM runs in UTF-<span class=\"number\">16</span> <span class=\"keyword\">mode</span>.</span><br><span class=\"line\"># When <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">2</span>, SimbaDM runs in UTF-<span class=\"number\">8</span> <span class=\"keyword\">mode</span>.</span><br><span class=\"line\">#DriverUnicodeEncoding=<span class=\"number\">2</span></span><br><span class=\"line\"># Values <span class=\"keyword\">for</span> HOST, PORT, KrbFQDN, <span class=\"built_in\">and</span> KrbServiceName should <span class=\"keyword\">be</span> <span class=\"keyword\">set</span> here.</span><br><span class=\"line\"># They can also <span class=\"keyword\">be</span> specified <span class=\"keyword\">on</span> the connection <span class=\"built_in\">string</span>.</span><br><span class=\"line\">HOST=<span class=\"number\">192.168</span>.<span class=\"number\">11.10</span></span><br><span class=\"line\">PORT=<span class=\"number\">21050</span></span><br><span class=\"line\">Database=default</span><br><span class=\"line\"># The authentication mechanism.</span><br><span class=\"line\"># <span class=\"number\">0</span> - No authentication (NOSASL)</span><br><span class=\"line\"># <span class=\"number\">1</span> - Kerberos authentication (SASL)</span><br><span class=\"line\"># <span class=\"number\">2</span> - Username authentication (SASL)</span><br><span class=\"line\"># <span class=\"number\">3</span> - Username/password authentication (NOSASL <span class=\"built_in\">or</span> SASL depending <span class=\"keyword\">on</span> UseSASL configuration)</span><br><span class=\"line\">AuthMech=<span class=\"number\">3</span></span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">to</span> use SASL <span class=\"keyword\">for</span> authentication.</span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">to</span> not use SASL.</span><br><span class=\"line\"># When using Kerberos authentication (SASL) <span class=\"built_in\">or</span> Username authentication (SASL) SASL <span class=\"keyword\">is</span> always used</span><br><span class=\"line\"># <span class=\"built_in\">and</span> this configuration <span class=\"keyword\">is</span> ignored. SASL <span class=\"keyword\">is</span> always not used <span class=\"keyword\">for</span> No authentication (NOSASL).</span><br><span class=\"line\">UseSASL=<span class=\"number\">0</span></span><br><span class=\"line\"># Kerberos related settings.</span><br><span class=\"line\">KrbFQDN=</span><br><span class=\"line\">KrbRealm=</span><br><span class=\"line\">KrbServiceName=</span><br><span class=\"line\"># Username/password authentication with SASL settings.</span><br><span class=\"line\">UID=hdfs</span><br><span class=\"line\">PWD=</span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">0</span> <span class=\"keyword\">to</span> disable SSL.</span><br><span class=\"line\"># Set <span class=\"keyword\">to</span> <span class=\"number\">1</span> <span class=\"keyword\">to</span> enable SSL.</span><br><span class=\"line\">SSL=<span class=\"number\">0</span></span><br><span class=\"line\">CAIssuedCertNamesMismatch=<span class=\"number\">1</span></span><br><span class=\"line\">TrustedCerts=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/lib/<span class=\"number\">64</span>/cacerts.pem</span><br><span class=\"line\"># General settings</span><br><span class=\"line\">TSaslTransportBufSize=<span class=\"number\">1000</span></span><br><span class=\"line\">RowsFetchedPerBlock=<span class=\"number\">10000</span></span><br><span class=\"line\">SocketTimeout=<span class=\"number\">0</span></span><br><span class=\"line\">StringColumnLength=<span class=\"number\">32767</span></span><br><span class=\"line\">UseNativeQuery=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置odbc-odbcinst-ini\"><a href=\"#创建配置odbc-odbcinst-ini\" class=\"headerlink\" title=\"创建配置odbc/odbcinst.ini\"></a>创建配置odbc/odbcinst.ini</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost config_odbc]# <span class=\"keyword\">vim</span> odbc/odbcinst.ini    【注意里面包含了ODBC连接hive和impala的配置】</span><br><span class=\"line\"></span><br><span class=\"line\">[ODBC Drivers]</span><br><span class=\"line\">Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive <span class=\"number\">64</span>-bit=Installed</span><br><span class=\"line\">Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala <span class=\"number\">64</span>-bit=Installed</span><br><span class=\"line\">#[Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive <span class=\"number\">32</span>-bit]</span><br><span class=\"line\">#Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive (<span class=\"number\">32</span>-bit)</span><br><span class=\"line\">#Driver=/<span class=\"keyword\">opt</span>/cloudera/hiveodbc/lib/<span class=\"number\">32</span>/libclouderahiveodbc32.<span class=\"keyword\">so</span></span><br><span class=\"line\">[Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive <span class=\"number\">64</span>-bit]</span><br><span class=\"line\">Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Apache Hive (<span class=\"number\">64</span>-bit)</span><br><span class=\"line\">Driver=/<span class=\"keyword\">opt</span>/cloudera/hiveodbc/lib/<span class=\"number\">64</span>/libclouderahiveodbc64.<span class=\"keyword\">so</span></span><br><span class=\"line\">## The option below <span class=\"keyword\">is</span> <span class=\"keyword\">for</span> using unixODBC when compiled with -DSQL_WCHART_CONVERT.</span><br><span class=\"line\">## Execute <span class=\"string\">'odbc_config --cflags'</span> <span class=\"keyword\">to</span> determine <span class=\"keyword\">if</span> you need <span class=\"keyword\">to</span> uncomment it.</span><br><span class=\"line\"># IconvEncoding=UCS-<span class=\"number\">4</span>LE</span><br><span class=\"line\">[Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala <span class=\"number\">64</span>-bit]</span><br><span class=\"line\">Description=Cloudera ODBC Driver <span class=\"keyword\">for</span> Impala (<span class=\"number\">64</span>-bit)</span><br><span class=\"line\">Driver=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/lib/<span class=\"number\">64</span>/libclouderaimpalaodbc64.<span class=\"keyword\">so</span></span><br><span class=\"line\">## The option below <span class=\"keyword\">is</span> <span class=\"keyword\">for</span> using unixODBC when compiled with -DSQL_WCHART_CONVERT.</span><br><span class=\"line\">## Execute <span class=\"string\">'odbc_config --cflags'</span> <span class=\"keyword\">to</span> determine <span class=\"keyword\">if</span> you need <span class=\"keyword\">to</span> uncomment it.</span><br><span class=\"line\"># IconvEncoding=UCS-<span class=\"number\">4</span>LE</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置odbc-cloudera-impalaodbc-ini\"><a href=\"#创建配置odbc-cloudera-impalaodbc-ini\" class=\"headerlink\" title=\"创建配置odbc/cloudera.impalaodbc.ini\"></a>创建配置odbc/cloudera.impalaodbc.ini</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost config_odbc]# <span class=\"keyword\">vim</span> odbc/cloudera.impalaodbc.ini    【注意里面包含了ODBC连接hive和impala的配置】</span><br><span class=\"line\"></span><br><span class=\"line\">[Driver]</span><br><span class=\"line\">## - Note that this default DriverManagerEncoding of UTF-<span class=\"number\">32</span> <span class=\"keyword\">is</span> <span class=\"keyword\">for</span> iODBC.</span><br><span class=\"line\">## - unixODBC uses UTF-<span class=\"number\">16</span> by default.</span><br><span class=\"line\">## - If unixODBC was compiled with -DSQL_WCHART_CONVERT, then UTF-<span class=\"number\">32</span> <span class=\"keyword\">is</span> the correct value.</span><br><span class=\"line\">##   Execute <span class=\"string\">'odbc_config --cflags'</span> <span class=\"keyword\">to</span> determine <span class=\"keyword\">if</span> you need UTF-<span class=\"number\">32</span> <span class=\"built_in\">or</span> UTF-<span class=\"number\">16</span> <span class=\"keyword\">on</span> unixODBC</span><br><span class=\"line\">## - SimbaDM can <span class=\"keyword\">be</span> used with UTF-<span class=\"number\">8</span> <span class=\"built_in\">or</span> UTF-<span class=\"number\">16</span>.</span><br><span class=\"line\">##   The DriverUnicodeEncoding setting will cause SimbaDM <span class=\"keyword\">to</span> run in UTF-<span class=\"number\">8</span> when <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">2</span> <span class=\"built_in\">or</span> UTF-<span class=\"number\">16</span> when <span class=\"keyword\">set</span> <span class=\"keyword\">to</span> <span class=\"number\">1</span>.</span><br><span class=\"line\">DriverManagerEncoding=UTF-<span class=\"number\">32</span></span><br><span class=\"line\">ErrorMessagesPath=/<span class=\"keyword\">opt</span>/cloudera/impalaodbc/ErrorMessages</span><br><span class=\"line\">LogLevel=<span class=\"number\">0</span></span><br><span class=\"line\">LogPath=</span><br><span class=\"line\">## - Uncomment the ODBCInstLib corresponding <span class=\"keyword\">to</span> the Driver Manager being used.</span><br><span class=\"line\">## - Note that the path <span class=\"keyword\">to</span> your ODBC Driver Manager must <span class=\"keyword\">be</span> specified in LD_LIBRARY_PATH (LIBPATH <span class=\"keyword\">for</span> AIX).</span><br><span class=\"line\">## - Note that AIX <span class=\"built_in\">has</span> <span class=\"keyword\">a</span> different format <span class=\"keyword\">for</span> specifying its shared libraries.</span><br><span class=\"line\"># Generic ODBCInstLib</span><br><span class=\"line\">#   iODBC</span><br><span class=\"line\">#ODBCInstLib=libiodbcinst.<span class=\"keyword\">so</span></span><br><span class=\"line\">#   SimbaDM / unixODBC</span><br><span class=\"line\">ODBCInstLib=libodbcinst.<span class=\"keyword\">so</span></span><br><span class=\"line\"># AIX specific ODBCInstLib</span><br><span class=\"line\">#   iODBC</span><br><span class=\"line\">#ODBCInstLib=libiodbcinst.<span class=\"keyword\">a</span>(libiodbcinst.<span class=\"keyword\">so</span>.<span class=\"number\">2</span>)</span><br><span class=\"line\">#   SimbaDM</span><br><span class=\"line\">#ODBCInstLib=libodbcinst.<span class=\"keyword\">a</span>(odbcinst.<span class=\"keyword\">so</span>)</span><br><span class=\"line\">#   unixODBC</span><br><span class=\"line\">#ODBCInstLib=libodbcinst.<span class=\"keyword\">a</span>(libodbcinst.<span class=\"keyword\">so</span>.<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建配置cloudera-hiveodbc-ini\"><a href=\"#创建配置cloudera-hiveodbc-ini\" class=\"headerlink\" title=\"创建配置cloudera.hiveodbc.ini\"></a>创建配置cloudera.hiveodbc.ini</h4><figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost config_odbc]# <span class=\"keyword\">vim</span> odbc/cloudera.hiveodbc.ini    【注意里面包含了ODBC连接hive和impala的配置】</span><br><span class=\"line\"></span><br><span class=\"line\">[Driver]</span><br><span class=\"line\">ErrorMessagesPath=/<span class=\"keyword\">opt</span>/cloudera/hiveodbc/ErrorMessages/</span><br><span class=\"line\">LogLevel=<span class=\"number\">0</span></span><br><span class=\"line\">LogPath=</span><br><span class=\"line\">SwapFilePath=/tmp</span><br></pre></td></tr></table></figure>\n<h4 id=\"进行测试\"><a href=\"#进行测试\" class=\"headerlink\" title=\"进行测试\"></a>进行测试</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost config_odbc]<span class=\"comment\"># source common.env</span></span><br><span class=\"line\">        [root@localhost config_odbc]<span class=\"comment\"># isql -v 'impala'</span></span><br><span class=\"line\">        +---------------------------------------+</span><br><span class=\"line\">        | Connected!                            |</span><br><span class=\"line\">        |                                       |</span><br><span class=\"line\">        | sql-statement                         |</span><br><span class=\"line\">        | <span class=\"built_in\">help</span> [tablename]                      |</span><br><span class=\"line\">        | quit                                  |</span><br><span class=\"line\">        |                                       |</span><br><span class=\"line\">        +---------------------------------------+</span><br></pre></td></tr></table></figure>\n<p>注意前提是, 连接的IP的端口已经开启了此机器的访问权限, 否则会出现如下错误:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost config_odbc]<span class=\"comment\"># isql -v 'impala'</span></span><br><span class=\"line\">        [S1000][unixODBC][Cloudera][ImpalaODBC] (100) Error from the Impala Thrift API: connect() failed: Connection timed out</span><br><span class=\"line\">        [ISQL]ERROR: Could not SQLConnect</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行php进行测试\"><a href=\"#运行php进行测试\" class=\"headerlink\" title=\"运行php进行测试\"></a>运行php进行测试</h4><p>1)如果是安装odbc扩展的, 如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./configure --prefix=<span class=\"variable\">$php_root</span> --with-config-file-path=/etc --with-mysql=<span class=\"variable\">$mysql_root</span> --with-pdo-mysql=<span class=\"variable\">$mysql_root</span>/bin/mysql_config --with-mysqli=<span class=\"variable\">$mysql_root</span>/bin/mysql_config --with-iconv-dir=/usr/<span class=\"built_in\">local</span> --with-freetype-dir --with-jpeg-dir --with-png-dir --<span class=\"built_in\">enable</span>-gd-native-ttf --<span class=\"built_in\">enable</span>-zip --with-zlib --with-gd --<span class=\"built_in\">disable</span>-rpath --<span class=\"built_in\">enable</span>-bcmath --<span class=\"built_in\">enable</span>-shmop --<span class=\"built_in\">enable</span>-sysvsem --with-curl --with-curlwrappers --<span class=\"built_in\">enable</span>-mbstring --with-mcrypt --<span class=\"built_in\">disable</span>-ipv6 --<span class=\"built_in\">enable</span>-static --<span class=\"built_in\">enable</span>-maintainer-zts --<span class=\"built_in\">enable</span>-sockets --<span class=\"built_in\">enable</span>-soap --with-openssl --without-pdo-sqlite --<span class=\"built_in\">enable</span>-fpm --with-unixODBC=/usr/</span><br></pre></td></tr></table></figure>\n<p>那么, 就用面向过程的写法:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># vim test-php-odbc-impala.php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$conn = odbc_connect(<span class=\"string\">\"impala\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"开始时间:\"</span> . time() . <span class=\"string\">\"\\r\\n\"</span>;</span><br><span class=\"line\">$sql = <span class=\"string\">\"select * from db_mcfx_log.t_log_sdk_log_pay\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"准备执行sql语句: $sql\\r\\n\"</span>;</span><br><span class=\"line\">$rs = odbc_exec($conn, $sql);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"语句执行完成, 准备开始获取结果集\\r\\n\"</span>;</span><br><span class=\"line\">$result = [];</span><br><span class=\"line\"><span class=\"keyword\">while</span> ($row=odbc_fetch_array($rs)) &#123;</span><br><span class=\"line\">    $result[] = $row;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"结果获取完毕\\r\\n\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"总记录数量: \"</span> . sizeof($result) . <span class=\"string\">\"\\r\\n\"</span>;</span><br><span class=\"line\">odbc_close($conn);</span><br><span class=\"line\">var_dump($conn);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"string\">\"结束时间: \"</span> . time() . <span class=\"string\">\"\\r\\n\"</span>;</span><br></pre></td></tr></table></figure>\n<p>2)如果是安装pdo_odbc扩展的, 那么就用面向过程的方法如下测试:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$dbh= <span class=\"keyword\">new</span> PDO(<span class=\"string\">'odbc:impala'</span>, <span class=\"string\">''</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">$sql = <span class=\"string\">\"select count(*) from db_mcfx_log.t_log_sdk_log_pay\"</span>;</span><br><span class=\"line\">$stmt = $dbh-&gt;prepare(<span class=\"string\">\"$sql\"</span>);</span><br><span class=\"line\">$stmt-&gt;execute();</span><br><span class=\"line\"><span class=\"keyword\">while</span> ($row = $stmt-&gt;fetch()) &#123;</span><br><span class=\"line\">    print_r($row);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($dbh); <span class=\"keyword\">unset</span>($stmt);</span><br></pre></td></tr></table></figure>\n<p>3)注意:</p>\n<p>如果PHP开启了开机自启动, 那么可能会出现连接odbc报错说库文件找不到.<br>这时候, 可以重启PHP那么就可以解决了, 原因暂时未明.</p>\n<h3 id=\"php常用ODBC函数集\"><a href=\"#php常用ODBC函数集\" class=\"headerlink\" title=\"php常用ODBC函数集\"></a>php常用ODBC函数集</h3><ol>\n<li>ODBC连接类函数<br> odbc_connect函数: 打开一个ODBC连接<br> odbc_close函数: 关闭一个已经打开的ODBC连接<br> odbc_close_all函数: 关闭所有已经打开的ODBC连接<br> odbc_pconnect函数: 打开一个持续有效的ODBC连接</li>\n<li>ODBC操作类函数<br> odbc_commit函数: 更新所有处于未决状态的操作<br> odbc_do函数: 在打开的ODBC连接上执行SQL语句<br> odbc_exec函数: 执行SQL语句<br> odbc_execute函数: 执行一个预置的SQL语句<br> odbc_free_result函数: 释放传回资料所占用的内存<br> odbc_prepare函数: 预置SQL语句的执行<br> odbc_rollback函数: 撤销所有处于未决状态的操作</li>\n<li>ODBC信息获取类函数<br> odbc_columnprivileges函数: 列出给定表的列和相关的权限<br> odbc_columns函数: 列出指定表的列的名称<br> odbc_cursor函数: 获取光标的名称<br> odbc_data_source函数: 返回连接数据库的信息<br> odbc_error函数: 获取最后的错误代码<br> odbc_errormsg函数: 获取最后的错误信息<br> odbc_fetch_array函数: 获取结果集数组<br> odbc_fetch_into函数: 获取传回的指定列<br> odbc_fetch_object函数: 返回结果集到对象<br> odbc_fetch_row函数: 获取传回的一列<br> odbc_field_len函数: 获取字段的长度<br> odbc_field_name函数: 获取字段的名称<br> odbc_field_num函数: 获取字段的序号<br> odbc_field_precision函数: 获取字段的长度<br> odbc_field_scale函数: 获取字段的浮点数<br> odbc_field_type函数: 获取字段的资料类型<br> odbc_foreignkeys函数: 返回特定表的外来键<br> odbc_gettypeinfo函数: 返回数据库的类型信息<br> odbc_longreadlen函数: 设定传回栏的最大值<br> odbc_num_fields函数: 获取字段数目<br> odbc_num_rows函数: 获取传回的列数目<br> odbc_primarykeys函数: 返回列的名字作为表的主键<br> odbc_procedurecolumns函数: 返回检索过程的参数信息<br> odbc_procedures函数: 获取存在于特定数据源中的进程信息<br> odbc_result_all函数: 传回HTML表格信息<br> odbc_result函数: 获取结果数据<br> odbc_specialcolumns函数: 返回一个表中在传送更新时可以自动更新的列<br> odbc_statistics函数: 获取表的状态及其索引<br> odbc_tableprivileges函数: 列出表格和每个表格关联的权限<br> odbc_tables函数: 获取特定数据库上的表的名称<br> odbc_autocommit函数: 开启或关闭自动更新<br> odbc_binmode函数: 设定二进制的数据处理方式<br> odbc_next_result函数: 检查下一个结果集是否可用<br> odbc_setoption函数: 调整ODBC设定</li>\n</ol>\n","categories":["技术"],"tags":["PHP","impala"]}]