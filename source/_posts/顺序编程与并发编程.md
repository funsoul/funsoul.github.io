---
title: 顺序编程与并发编程
date: 2019-07-01
categories:
  - 技术
tags: 
  - PHP 
  - Swoole
  - Golang
  - Node
---

## 写在前

假设有一个连接数据库添加新表的操作需要耗费的时间为1秒，顺序遍历100个数据库执行加表操作，将需要100秒才能完成，也就是**顺序编程**。

## 顺序编程

```php
function timeDiff($startTime){
    return microtime(true) - $startTime;
}

function addTable(){
    /** 模拟耗时 */
    sleep(1);
}

function main(){
    $startTime = microtime(true);

    for ($i = 0; $i < 100; $i++) {
        addTable();
    }

    echo timeDiff($startTime) . 's' . PHP_EOL;
}

main();

// 100.25194597244s
```

## 进程与线程

进程是资源分配的最小单位，线程是CPU调度的最小单位。

## 多任务处理

在现代操作系统中，多任务解决方案有很多种（**以下的线程无特别说明均指内核态线程**）：

1. 单进程单线程(事件循环)
2. 多进程单线程
3. swoole4 协程（多进程单线程）
4. golang 协程（单进程多线程）

### 单进程单线程(事件循环)

![单进程单线程（事件循环）- 图片引自网络](/images/顺序编程与并发编程/单进程单线程（事件循环）.png)

```js
function getCurrentDate() {
    let now = new Date();
    let year = now.getFullYear();
    let month = now.getMonth();
    let date = now.getDate();
    let day = now.getDay();
    let hour = now.getHours();
    let minu = now.getMinutes();
    let sec = now.getSeconds();

    month = month + 1;

    if (month < 10) month = "0" + month;
    if (date < 10) date = "0" + date;
    if (hour < 10) hour = "0" + hour;
    if (minu < 10) minu = "0" + minu;
    if (sec < 10) sec = "0" + sec;

    return year + "-" + month + "-" + date+ " " + hour + ":" + minu + ":" + sec;
}

function sleep (second) {
    return new Promise((resolve) => setTimeout(resolve, second * 1000));
}

function addTable() {
    console.log('finished at ' + getCurrentDate());
}

function main() {
    console.log('start at ' + getCurrentDate());
    for (let i = 0; i < 100; i++) {
        sleep(1).then(() => addTable());
    }
    console.log('end at ' + getCurrentDate());
}

main();

// start at 2019-06-30 11:11:17
// end at 2019-06-30 11:11:17
// finished at 2019-06-30 11:11:18
// finished at 2019-06-30 11:11:18
// finished at 2019-06-30 11:11:18
// ..
```

### 多进程单线程

php可以使用PCNTL或者swoole的[Process模块](https://wiki.swoole.com/wiki/page/p-process.html)，通过fork子进程与相关进程间通信方式（管道、FIFO、消息队列..）具体使用方法可以看下[funtask](https://github.com/funsoul/funtask)的demo。

### 协程（多进程单线程：swoole4）

![协程（多进程单线程：swoole4）- 图片引自网络](/images/顺序编程与并发编程/协程（多进程单线程：swoole4）.png)

```php
function getCurrentDate(){
    return date('Y-m-d H:i:s', time());
}

function addTable(){
    Co::sleep(1);
    echo "coroutine " . Co::getuid() .  " finished at " . getCurrentDate() . PHP_EOL;
}

echo 'start at ' . getCurrentDate() . PHP_EOL;

for ($i = 0; $i < 100; $i++) {
    go(function () {
        addTable();
    });
}

echo 'end at ' . getCurrentDate() . PHP_EOL;

// start at 2019-06-30 11:23:16
// end at 2019-06-30 11:23:16
// coroutine 1 finished at 2019-06-30 11:23:17
// coroutine 2 finished at 2019-06-30 11:23:17
// coroutine 4 finished at 2019-06-30 11:23:17
// coroutine 8 finished at 2019-06-30 11:23:17
// ..
```

这段程序不能很好的说明这是多进程单线程模型的，之所以说swoole4采用该模型，是把场景放在``swoole server``下的时候，swoole通过开启**多个worker**的方式来处理请求，而每个worker是单线程（**内核态**），在单线程的基础上使用协程（**用户态**）。

### 协程（单进程多线程：golang）

![协程（多进程多线程：golang）- 图片引自网络](/images/顺序编程与并发编程/协程（多进程多线程：golang）.jpeg)

```go
package main

import (
	"fmt"
	"time"
)

func addTable(i int) {
	time.Sleep(1 * time.Second)
	fmt.Printf("goroutine %d finished at %s \n", i, getCurrentDate())
}

func getCurrentDate() time.Time {
	return time.Now()
}

func main()  {
	fmt.Printf("start at %s \n", getCurrentDate())

	for i := 0; i < 100; i++ {
		go addTable(i);
	}

	fmt.Printf("end at %s \n", getCurrentDate())
    
    // main函数也是一个goroutine，这里是为了让任务的goroutine执行完
	time.Sleep(2 * time.Second)
}

// start at 2019-06-30 19:16:41.905093 +0800 CST m=+0.000270723 
// end at 2019-06-30 19:16:41.905521 +0800 CST m=+0.000699248 
// goroutine 79 finished at 2019-06-30 19:16:42.909839 +0800 CST m=+1.005007866 
// goroutine 27 finished at 2019-06-30 19:16:42.909775 +0800 CST m=+1.004944053 
// goroutine 99 finished at 2019-06-30 19:16:42.909779 +0800 CST m=+1.004948541
// ..
```

## 总结

PHP的目标一直都是简单为主，php-fpm很受欢迎的一大原因就是多进程单线程模型（没有线程或进程间IPC）、生命周期短暂，写代码不需要手动管理内存，减少心智负担。而多线程一直令人诟病的地方是**data race**（数据竞争），因为线程间通信的方式为**共享变量**，这需要开发者提高警惕，通过加锁等方式来解决。

本文介绍顺序编程与并发编程，探索在并发编程上各语言在不同模型上的支持度，在选择并发模型前，应该综合考虑业务类型是IO密集还是CPU密集型。前面介绍的几种并发模型中，node的事件循环、swoole4协程、golang协程都适用于IO密集型应用，其中golang的协程还适用于CPU密集型应用，在多核支持上更好。不过swoole4新版本中，引入的**协程抢占式调度**避免**cpu饿死问题**，值得一试！

## 参考文献

- [《unix网络编程 卷2》](https://book.douban.com/subject/4118577/)
- [node 时间循环机制](https://www.cnblogs.com/onepixel/p/7143769.html)
- [swoole wiki](https://wiki.swoole.com/)
- [swoole 协程](https://segmentfault.com/a/1190000019089997)
- [golang goroutine理解](https://segmentfault.com/a/1190000018150987)